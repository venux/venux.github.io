<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[DDD-01介绍]]></title>
      <url>/2018/05/14/DDD-01%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> DDD </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-Tomcat]]></title>
      <url>/2018/04/18/java-Tomcat/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>Apache 基金会下的一款开源的 web 服务器。</p>
<h2 id="2-下载"><a href="#2-下载" class="headerlink" title="2.下载"></a>2.下载</h2><p><a href="http://tomcat.apache.org/download-90.cgi" target="_blank" rel="external">Tomcat下载</a></p>
<h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><p>解压缩到指定目录</p>
<h3 id="3-1-目录结构"><a href="#3-1-目录结构" class="headerlink" title="3.1 目录结构"></a>3.1 目录结构</h3><ul>
<li>bin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。</li>
<li>conf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。</li>
<li>lib：库文件。tomcat运行时需要的jar包所在的目录</li>
<li>logs：日志</li>
<li>temp：临时产生的文件，即缓存</li>
<li>webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问</li>
<li>work：编译以后的class文件。</li>
</ul>
<h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><h3 id="4-1-环境变量配置"><a href="#4-1-环境变量配置" class="headerlink" title="4.1 环境变量配置"></a>4.1 环境变量配置</h3><ol>
<li><strong>CATALINA_HOME</strong>：C:\Program Files\Tomcat 8.5（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%CATALINA_HOME%\bin;</li>
<li><strong>CLASS_PATH</strong>:%CATALINA_HOME%\lib;</li>
</ol>
<h3 id="4-2-配置文件"><a href="#4-2-配置文件" class="headerlink" title="4.2 配置文件"></a>4.2 配置文件</h3><p>$CATALINA_HOME 目录下的 conf 目录，核心配置文件 server.xml。</p>
<h2 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h2><p>进入 $CATALINA_HOME 目录下的 bin 目录，运行 startup.bat 即可。</p>
<h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h3><ul>
<li><strong>localhost:8080</strong>:Tomcat默认主页</li>
</ul>
<h3 id="7-Eclipse集成"><a href="#7-Eclipse集成" class="headerlink" title="7 Eclipse集成"></a>7 Eclipse集成</h3><ul>
<li>“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。</li>
</ul>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-JSP]]></title>
      <url>/2018/04/18/java-JSP/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>JSP（Java Server Pages），一种动态网页开发技术，类似于 ASP。通常以<code>&lt;%</code>开头，以<code>%&gt;</code>结尾。</p>
<a id="more"></a>
<h2 id="2-特点（与CGI对比）"><a href="#2-特点（与CGI对比）" class="headerlink" title="2 特点（与CGI对比）"></a>2 特点（与CGI对比）</h2><ul>
<li>性能更加优越，因为JSP可以直接在HTML网页中动态嵌入元素而不需要单独引用CGI文件。</li>
<li>服务器调用的是已经编译好的JSP文件，而不像CGI/Perl那样必须先载入解释器和目标脚本。</li>
<li>JSP 基于Java Servlet API，因此，JSP拥有各种强大的企业级Java API，包括JDBC，JNDI，EJB，JAXP等等。</li>
<li>JSP页面可以与处理业务逻辑的 Servlet 一起使用，这种模式被Java servlet 模板引擎所支持。</li>
</ul>
<h2 id="3-JSP-流程"><a href="#3-JSP-流程" class="headerlink" title="3 JSP 流程"></a>3 JSP 流程</h2><p><img src="/images/posts/jsp-arch.jpg" alt="JSP 位置"><br><img src="/images/posts/jsp-processing.jpg" alt="JSP 流程"></p>
<ul>
<li>浏览器发送一个 HTTP 请求给服务器。</li>
<li>Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成。</li>
<li>JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码。</li>
<li>JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎。</li>
<li>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。</li>
<li>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。</li>
<li>Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样。</li>
</ul>
<h2 id="4-JSP-生命周期"><a href="#4-JSP-生命周期" class="headerlink" title="4 JSP 生命周期"></a>4 JSP 生命周期</h2><p><img src="/images/posts/jsp_life_cycle.jpg" alt="JSP 生命周期"></p>
<ul>
<li><strong>编译阶段</strong>：servlet容器编译servlet源文件，生成servlet类。若未修改，则跳过。<ul>
<li>解析JSP文件。</li>
<li>将JSP文件转为servlet。</li>
<li>编译servlet。</li>
</ul>
</li>
<li><p><strong>初始化阶段</strong>：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspInit</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="comment">//JSP初始化代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>执行阶段</strong>：调用与JSP对应的servlet实例的服务方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</div><div class="line">  <span class="comment">//服务端处理代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>销毁阶段</strong>：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspDestroy</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="comment">//清理代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-JSP-语法"><a href="#5-JSP-语法" class="headerlink" title="5 JSP 语法"></a>5 JSP 语法</h2><h3 id="5-1-脚本程序"><a href="#5-1-脚本程序" class="headerlink" title="5.1 脚本程序"></a>5.1 脚本程序</h3><p>可包含任意量的Java语句、变量、方法或表达式。格式：<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;% 代码片段 %&gt;</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;jsp:scriptlet&gt;</div><div class="line">  代码片段</div><div class="line">&lt;/jsp:scriptlet&gt;</div></pre></td></tr></table></figure></p>
<h3 id="5-2-头部支持中文"><a href="#5-2-头部支持中文" class="headerlink" title="5.2 头部支持中文"></a>5.2 头部支持中文</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html;charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</div></pre></td></tr></table></figure>
<h3 id="5-3-声明"><a href="#5-3-声明" class="headerlink" title="5.3 声明"></a>5.3 声明</h3><p>一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%! declaration;[ declaration;]+ ... %&gt;</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;jsp:declaration&gt;</div><div class="line">  代码片段</div><div class="line">&lt;/jsp:declaration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="5-4-表达式"><a href="#5-4-表达式" class="headerlink" title="5.4 表达式"></a>5.4 表达式</h3><p>一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。<br><code>注意：</code>不能以分号来结束。</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%= 表达式 %&gt;</div></pre></td></tr></table></figure>
<p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;jsp:expression&gt;</div><div class="line">   表达式</div><div class="line">&lt;/jsp:expression&gt;</div></pre></td></tr></table></figure></p>
<h3 id="5-5-注释"><a href="#5-5-注释" class="headerlink" title="5.5 注释"></a>5.5 注释</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%--注释--%&gt;</div></pre></td></tr></table></figure>
<h3 id="5-6-指令"><a href="#5-6-指令" class="headerlink" title="5.6 指令"></a>5.6 指令</h3><p>设置与整个JSP页面相关的属性。</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%@ directive attribute=<span class="string">"value"</span> %&gt;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;%@ page … %&gt;</td>
<td>定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td>
</tr>
<tr>
<td>&lt;%@ include … %&gt;</td>
<td>包含其他文件</td>
</tr>
<tr>
<td>&lt;%@ taglib … %&gt;</td>
<td>引入标签库的定义，可以是自定义标签</td>
</tr>
</tbody>
</table>
<h3 id="5-7-行为"><a href="#5-7-行为" class="headerlink" title="5.7 行为"></a>5.7 行为</h3><p>使用XML语法结构来控制servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。<br>行为标签只有一种语法格式，它严格遵守XML标准。</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;jsp:action_name attribute=<span class="string">"value"</span> /&gt;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>jsp:include</td>
<td>用于在当前页面中包含静态或动态资源</td>
</tr>
<tr>
<td>jsp:useBean</td>
<td>寻找和初始化一个JavaBean组件</td>
</tr>
<tr>
<td>jsp:setProperty</td>
<td>设置 JavaBean组件的值</td>
</tr>
<tr>
<td>jsp:getProperty</td>
<td>将 JavaBean组件的值插入到 output中</td>
</tr>
<tr>
<td>jsp:forward</td>
<td>从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td>
</tr>
<tr>
<td>jsp:plugin</td>
<td>用于在生成的HTML页面中包含Applet和JavaBean对象</td>
</tr>
<tr>
<td>jsp:element</td>
<td>动态创建一个XML元素</td>
</tr>
<tr>
<td>jsp:attribute</td>
<td>定义动态创建的XML元素的属性</td>
</tr>
<tr>
<td>jsp:body</td>
<td>定义动态创建的XML元素的主体</td>
</tr>
<tr>
<td>jsp:text</td>
<td>用于封装模板数据</td>
</tr>
</tbody>
</table>
<h3 id="5-8-隐含对象"><a href="#5-8-隐含对象" class="headerlink" title="5.8 隐含对象"></a>5.8 隐含对象</h3><table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>HttpServletRequest类的实例</td>
</tr>
<tr>
<td>response</td>
<td>HttpServletResponse类的实例</td>
</tr>
<tr>
<td>out</td>
<td>PrintWriter类的实例，用于把结果输出至网页上</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession类的实例</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext类的实例，与应用上下文有关</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig类的实例</td>
</tr>
<tr>
<td>pageContext</td>
<td>PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问</td>
</tr>
<tr>
<td>page</td>
<td>类似于Java类中的this关键字</td>
</tr>
<tr>
<td>Exception</td>
<td>Exception类的对象，代表发生错误的JSP页面中对应的异常对象</td>
</tr>
</tbody>
</table>
<h3 id="5-9-控制流语句"><a href="#5-9-控制流语句" class="headerlink" title="5.9 控制流语句"></a>5.9 控制流语句</h3><h4 id="5-9-1-判断语句"><a href="#5-9-1-判断语句" class="headerlink" title="5.9.1 判断语句"></a>5.9.1 判断语句</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;% <span class="keyword">if</span>(flag)&#123; %&gt;</div><div class="line">  &lt;p&gt;True&lt;/p&gt;</div><div class="line">&lt;% &#125;<span class="keyword">else</span>&#123; %&gt;</div><div class="line">  &lt;p&gt;False&lt;/p&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>
<h4 id="5-9-2-循环语句"><a href="#5-9-2-循环语句" class="headerlink" title="5.9.2 循环语句"></a>5.9.2 循环语句</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;% <span class="keyword">for</span> ( index = <span class="number">1</span>; index &lt;= <span class="number">3</span>; index++)&#123; %&gt;</div><div class="line">  &lt;p&gt;</div><div class="line">    &lt;%= index %&gt; </div><div class="line">  &lt;/p&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>
<h3 id="5-10-运算符"><a href="#5-10-运算符" class="headerlink" title="5.10 运算符"></a>5.10 运算符</h3><p>JSP支持所有Java逻辑和算术运算符。</p>
<h3 id="5-11-字面量"><a href="#5-11-字面量" class="headerlink" title="5.11 字面量"></a>5.11 字面量</h3><ul>
<li>布尔值(boolean)：true 和 false;</li>
<li>整型(int)：与 Java 中的一样;</li>
<li>浮点型(float)：与 Java 中的一样;</li>
<li>字符串(string)：以单引号或双引号开始和结束;</li>
<li>Null：null。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-名词解释]]></title>
      <url>/2018/04/15/java-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<h2 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1 名词解释"></a>1 名词解释</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>详细信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>POJOs</td>
<td>Plain Old Java Objects</td>
<td>普通的 Java对象</td>
</tr>
<tr>
<td>DAO</td>
<td>Data Access Objects</td>
<td>数据访问对象</td>
</tr>
<tr>
<td>CGI</td>
<td>Common Gateway Interfa e</td>
<td>公共网关接口</td>
</tr>
<tr>
<td>JSP</td>
<td>Java Server Pages</td>
<td>Java服务页面（动态网页开发技术）</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-MyBatis]]></title>
      <url>/2018/04/15/java-MyBatis/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>MyBatis 是一款<strong>持久层框架</strong>，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-Maven]]></title>
      <url>/2018/04/15/java-Maven/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>Maven 是一个项目构建和管理的自动化工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。</p>
<p>Maven 使用惯例优于配置的原则 。它要求在没有定制之前，所有的项目都有如下的结构：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>${basedir}</td>
<td>存放 pom.xml和所有的子目录</td>
</tr>
<tr>
<td>${basedir}/src/main/java</td>
<td>项目的 java源代码</td>
</tr>
<tr>
<td>${basedir}/src/main/resources</td>
<td>项目的资源，比如说 property文件</td>
</tr>
<tr>
<td>${basedir}/src/test/java</td>
<td>项目的测试类，比如说 JUnit代码</td>
</tr>
<tr>
<td>${basedir}/src/test/resources</td>
<td>测试使用的资源</td>
</tr>
</tbody>
</table>
<p>一个 maven 项目在默认情况下会产生 JAR 文件，另外 ，编译后 的 classes 会放在 ${basedir}/target/classes 下面， JAR 文件会放在 ${basedir}/target 下面。<br><a id="more"></a></p>
<h2 id="2-下载-amp-安装-amp-配置"><a href="#2-下载-amp-安装-amp-配置" class="headerlink" title="2 下载&amp;安装&amp;配置"></a>2 下载&amp;安装&amp;配置</h2><h3 id="2-1-前提"><a href="#2-1-前提" class="headerlink" title="2.1 前提"></a>2.1 前提</h3><p>需安装配置 java 开发环境</p>
<h3 id="2-2-下载地址"><a href="#2-2-下载地址" class="headerlink" title="2.2 下载地址"></a>2.2 下载地址</h3><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="external">Maven下载</a></p>
<h3 id="2-3-安装"><a href="#2-3-安装" class="headerlink" title="2.3 安装"></a>2.3 安装</h3><p>直接解压缩到指定目录</p>
<h3 id="2-4-配置"><a href="#2-4-配置" class="headerlink" title="2.4 配置"></a>2.4 配置</h3><p>配置文件：<code>‪C:\Program Files\apache-maven-3.5.0\conf\settings.xml</code></p>
<ol>
<li><strong>MAVEN_HOME</strong>:C:\Program Files\apache-maven-3.5.0（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%MAVEN_HOME%\bin;</li>
<li><strong>MAVEN_OPTS</strong>: -Xms128m -Xmx512m;(设置Maven可用内存大小)</li>
<li>修改本地仓库路径：setting.xml 中的 localRepository。</li>
</ol>
<h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><ul>
<li><strong>mvn -v</strong>:版本号</li>
</ul>
<h3 id="2-6-集成IDE"><a href="#2-6-集成IDE" class="headerlink" title="2.6 集成IDE"></a>2.6 集成IDE</h3><ul>
<li>Eclipse IDE：<a href="https://www.eclipse.org/m2e/" target="_blank" rel="external">M2Eclipse</a>，直接搜索 Maven 即可。<ul>
<li>Launching Maven builds from within Eclipse</li>
<li>Dependency management for Eclipse build path based on Maven’s pom.xml</li>
<li>Resolving Maven dependencies from the Eclipse workspace without installing to local Maven repository</li>
<li>Automatic downloading of the required dependencies and sources from the remote Maven repositories</li>
<li>Wizards for creating new Maven projects, pom.xml and to enable Maven support on existing projects</li>
<li>Quick search for dependencies in remote Maven repositories</li>
<li>Quick fixes in the Java editor for looking up required dependencies/jars by the class or package name</li>
<li>Integration with other Eclipse tools, such as WTP, AJDT, Mylyn, Subclipse and others.</li>
</ul>
</li>
<li>Intellij IDEA:<a href="https://www.jetbrains.com/help/idea/maven.html" target="_blank" rel="external">Intellij IDEA-Maven</a></li>
</ul>
<h2 id="3-核心概念"><a href="#3-核心概念" class="headerlink" title="3 核心概念"></a>3 核心概念</h2><h3 id="3-1-POM（Project-Object-Model）-ps-个人理解为类似于VS的csproj文件，用于管理项目"><a href="#3-1-POM（Project-Object-Model）-ps-个人理解为类似于VS的csproj文件，用于管理项目" class="headerlink" title="3.1 POM（Project Object Model）[ps:个人理解为类似于VS的csproj文件，用于管理项目]"></a>3.1 POM（Project Object Model）[ps:个人理解为类似于VS的csproj文件，用于管理项目]</h3><p>pom 是一个 xml，是maven工作的基础，在执行 task 或者 goal 时，maven 会去项目根目录下读取 pom.xml 获得需要的配置信息。该文件包括项目的信息和 maven build 项目所需的配置信息，通常有项目信息(如版本、成员)、项目的依赖、插件和 goal 、build 选项等等。<br>pom 是可继承的，大型项目中，子模块的 pom 需指定父模块的 pom。<br>节点定义：</p>
<ul>
<li>project：pom文件的顶级元素</li>
<li>modelVersion：所使用的object model版本，为了确保稳定的使用，这个元素是强制性的。除非maven开发者升级模板，否则不需要修改</li>
<li>groupId：是项目创建团体或组织的唯一标志符，通常是域名倒写，如groupId  org.apache.maven.plugins就是为所有maven插件预留的</li>
<li>artifactId：是项目artifact唯一的基地址名</li>
<li>packaging：artifact打包的方式，如jar、war、ear等等。默认为jar。这个不仅表示项目最终产生何种后缀的文件，也表示build过程使用什么样的lifecycle。</li>
<li>version：artifact的版本，通常能看见为类似0.0.1-SNAPSHOT，其中SNAPSHOT表示项目开发中，为开发版本</li>
<li>name：表示项目的展现名，在maven生成的文档中使用</li>
<li>url：表示项目的地址，在maven生成的文档中使用</li>
<li>description：表示项目的描述，在maven生成的文档中使用</li>
<li>dependencies：表示依赖，在子节点dependencies中添加具体依赖的groupId - artifactId和version</li>
<li>build：表示build配置</li>
<li>parent：表示父pom</li>
</ul>
<h3 id="3-2-Artifact（类似于-nuget-中的包）"><a href="#3-2-Artifact（类似于-nuget-中的包）" class="headerlink" title="3.2 Artifact（类似于 nuget 中的包）"></a>3.2 Artifact（类似于 nuget 中的包）</h3><ul>
<li>需指定项目要产生的文件，如 jar，源文件，二进制，war，pom 等，类似于 VS 中的项目类型。</li>
<li>groupId:artifactId:version 组成的标识符唯一识别，唯一确定了一个 artifact。</li>
<li>需要被使用(依赖)的 artifact 都要放在仓库(见Repository)中。</li>
</ul>
<h3 id="3-3-Repositories（仓储）"><a href="#3-3-Repositories（仓储）" class="headerlink" title="3.3 Repositories（仓储）"></a>3.3 Repositories（仓储）</h3><ul>
<li>主要用来存储 Artifact。</li>
<li>可分为本地和远程。<ul>
<li>本地对 Windows 系统存放于<code>用户/.m2/repository</code>，可修改。</li>
</ul>
</li>
</ul>
<h3 id="3-4-Build-Lifecycle（构建生存周期）"><a href="#3-4-Build-Lifecycle（构建生存周期）" class="headerlink" title="3.4 Build Lifecycle（构建生存周期）"></a>3.4 Build Lifecycle（构建生存周期）</h3><p>指一个项目的构建过程，由 phase（片段） 构成。分三种：</p>
<ul>
<li>default：处理项目的部署，大致流程：<ol>
<li>validate 验证项目是否正确以及必须的信息是否可用</li>
<li>compile 编译源代码</li>
<li>test 测试编译后的代码，即执行单元测试代码</li>
<li>package 打包编译后的代码，在target目录下生成package文件</li>
<li>integration-test 处理package以便需要时可以部署到集成测试环境</li>
<li>verify 检验package是否有效并且达到质量标准</li>
<li>install 安装package到本地仓库，方便本地其它项目使用</li>
<li>deploy 部署，拷贝最终的package到远程仓库和替他开发这或项目共享，在集成或发布环境完成</li>
</ol>
</li>
<li>clean：处理项目的清理</li>
<li>site：处理项目的文档生成</li>
</ul>
<p>注意：phase 是有序的，执行指定的 phase 时，会先执行完之前的 phase。</p>
<h3 id="3-5-Goal（任务）"><a href="#3-5-Goal（任务）" class="headerlink" title="3.5 Goal（任务）"></a>3.5 Goal（任务）</h3><p>表示一个特定的任务，区别于 build。</p>
<ul>
<li>mvn compile：编译</li>
<li>mvn package：打包</li>
<li>mvn deploy：部署</li>
<li>mvn clean install：先执行 clean 之前的 phase，在执行 clean，install。</li>
<li>mvn install：安装到本地</li>
</ul>
<h3 id="3-6-Archetype（原型）"><a href="#3-6-Archetype（原型）" class="headerlink" title="3.6 Archetype（原型）"></a>3.6 Archetype（原型）</h3><p>类似于 .net core 的项目模板</p>
<h2 id="4-常用参数"><a href="#4-常用参数" class="headerlink" title="4 常用参数"></a>4 常用参数</h2><ul>
<li>mvn -e：显示详细错误</li>
<li>mvn -U：强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖）</li>
<li>mvn -o：运行offline模式，不联网更新依赖</li>
<li>mvn -N：仅在当前项目模块执行命令，关闭reactor</li>
<li>mvn -pl：module_name在指定模块上执行命令</li>
<li>mvn -ff：在递归执行命令过程中，一旦发生错误就直接退出</li>
<li>mvn -Dxxx=yyy：指定java全局属性</li>
<li>mvn -Pxxx：引用profile xxx</li>
<li>mvn test-compile：编译测试代码</li>
<li>mvn test：运行程序中的单元测试</li>
<li>mvn compile：编译项目</li>
<li>mvn package：打包，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件</li>
<li>mvn install：打包并安装到本地仓库，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。每个phase都可以作为goal，也可以联合，如之前介绍的mvn clean install</li>
<li>mvn archetype:generate：创建maven项目</li>
<li>mvn package：打包，上面已经介绍过了</li>
<li>mvn package：-Prelease打包，并生成部署用的包，比如deploy/*.tgz</li>
<li>mvn install：打包并安装到本地库</li>
<li>mvn eclipse:eclipse：生成eclipse项目文件</li>
<li>mvn eclipse:clean：清除eclipse项目文件</li>
<li>mvn site：生成项目相关信息的网站</li>
<li>mvn -Dwtpversion=2.0：指定maven版本</li>
<li>mvn -Dmaven.test.skip=true：如果命令包含了test phase，则忽略单元测试</li>
<li>mvn -DuserProp=filePath：指定用户自定义配置文件位置</li>
<li>mvn -DdownloadSources=true -Declipse.addVersionToProjectName=true eclipse:eclipse：生成eclipse项目文件，尝试从仓库下载源代码，并且生成的项目包含模块版本（注意如果使用公用POM，上述的开关缺省已打开）</li>
<li>mvn -Dsurefire.useFile=false：如果执行单元测试出错，用该命令可以在console输出失败的单元测试及相关信息</li>
<li>set MAVEN_OPTS=-Xmx512m -XX:MaxPermSize=256m：调大jvm内存和持久代，maven/jvm out of memory error</li>
<li>mvn -X：maven log level设定为debug在运行</li>
<li>mvn debug：运行jpda允许remote debug</li>
<li>mvn –help 帮助</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://maven.apache.org/index.html" target="_blank" rel="external">Maven官网</a><br>2 <a href="http://blog.csdn.net/column/details/maven-it.html" target="_blank" rel="external">Maven入门</a><br>3 <a href="http://www.trinea.cn/android/maven/" target="_blank" rel="external">Maven介绍，包括作用、核心概念、用法、常用命令、扩展及配置</a><br>4 <a href="http://www.oracle.com/technetwork/cn/community/java/apache-maven-getting-started-1-406235-zhs.html" target="_blank" rel="external">Maven入门介绍</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-反射]]></title>
      <url>/2018/04/09/java-%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<h2 id="1-Class（java-lang-Class）"><a href="#1-Class（java-lang-Class）" class="headerlink" title="1 Class（java.lang.Class）"></a>1 Class（java.lang.Class）</h2><p>该类是反射的核心，获取类的Class对象引用方式：</p>
<ul>
<li>使用类文字，如Test.class、double.class（等价于Doubel.TYPE）和void.class；</li>
<li>使用Object类的getClass()方法</li>
<li>使用Class类的forName()静态方法</li>
</ul>
<a id="more"></a>
<h2 id="2-字段"><a href="#2-字段" class="headerlink" title="2 字段"></a>2 字段</h2><ul>
<li>getFields()方法返回所有可访问的公共字段在类中声明或继承自超类。</li>
<li>getDeclaredFields()方法返回所有字段只出现在类的声明中(不是从继承的字段)。</li>
<li>getField(String name)和 getDeclaredField(String name)通过字段名获取 Field 对象。</li>
</ul>
<h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h2><ul>
<li>java.lang.reflect.Method（继承自抽象类Executable） 类的实例表示一个方法。</li>
<li>java.lang.reflect.Constructor（继承自抽象类Executable） 类的实例表示一个构造函数。</li>
<li>Parameter 类：可执行文件中的参数。默认情况，参数名称不存储在类文件中，而类似于arg0,arg1。</li>
<li>TypeVariable：通用方法或构造函数的类型参数。</li>
<li>Executable类（抽象）：可执行。<ul>
<li>getParameters()：获取参数数组；</li>
<li>getExceptionTypes()：获取异常数组；</li>
<li>getTypeParameters()：获取类型参数数组；</li>
<li>getModifiers()：获取修饰符</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Method[]  getMethods()</div><div class="line">Method[]  getDeclaredMethods()：返回当前类的所有声明的构造函数。</div><div class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name,  Class...  parameterTypes)</span></span></div><div class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name,  Class...  parameterTypes)</span></span></div></pre></td></tr></table></figure>
<h2 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4 构造函数"></a>4 构造函数</h2><ul>
<li>Constructor[] getConstructors()：返回当前和超类的所有公共构造函数。</li>
<li>Constructor[]  getDeclaredConstructors()</li>
<li>Constructor<t> getConstructor(Class…  parameterTypes)</t></li>
<li>Constructor<t> getDeclaredConstructor(Class…  parameterTypes)</t></li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-集合]]></title>
      <url>/2018/04/09/java-%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h2 id="1-集合遍历"><a href="#1-集合遍历" class="headerlink" title="1 集合遍历"></a>1 集合遍历</h2><h3 id="1-1-迭代器（实现-Iterator-接口的实例）"><a href="#1-1-迭代器（实现-Iterator-接口的实例）" class="headerlink" title="1.1 迭代器（实现 Iterator 接口的实例）"></a>1.1 迭代器（实现 Iterator<e> 接口的实例）</e></h3><ul>
<li>检查是否有尚未访问的元素。</li>
<li>访问集合中的下一个元素。</li>
<li>删除集合的最后访问元素。</li>
</ul>
<h3 id="1-2-for-each循环"><a href="#1-2-for-each循环" class="headerlink" title="1.2 for-each循环"></a>1.2 for-each循环</h3><ul>
<li>for-each循环遍历任何实现类实现Iterable接口的集合。</li>
</ul>
<p><code>ps:</code>不能使用for-each循环从集合中删除元素，将抛出ConcurrentModificationException异常。</p>
<h3 id="1-3-forEach-方法"><a href="#1-3-forEach-方法" class="headerlink" title="1.3 forEach()方法"></a>1.3 forEach()方法</h3><ul>
<li>Iterable接口包含一个新的 forEach(Consumer action)方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// Create a list of strings</span></div><div class="line">    List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    names.add(<span class="string">"A"</span>);</div><div class="line">    names.add(<span class="string">"B"</span>);</div><div class="line">    names.add(<span class="string">"C"</span>);</div><div class="line"></div><div class="line">    names.forEach(System.out::println);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-集合（Set接口）（唯一对象的集合）"><a href="#2-集合（Set接口）（唯一对象的集合）" class="headerlink" title="2 集合（Set接口）（唯一对象的集合）"></a>2 集合（Set接口）（唯一对象的集合）</h3><ul>
<li>集合是唯一元素的集合。当向集合添加重复元素时，它们将被忽略。</li>
<li>Java最多允许一个Set中的一个空元素。 </li>
<li>Set 中元素的排序并不重要。Java不保证 Set 中元素的排序。</li>
</ul>
<h3 id="2-1-数学集"><a href="#2-1-数学集" class="headerlink" title="2.1 数学集"></a>2.1 数学集</h3><ul>
<li>HashSet 类：不保证顺序元素</li>
<li>LinkedHashSet 类：保证插入元素顺序</li>
</ul>
<h3 id="2-2-排序集"><a href="#2-2-排序集" class="headerlink" title="2.2 排序集"></a>2.2 排序集</h3><p>SortedSet 接口表示Java集合中的排序集合框架。</p>
<ul>
<li>元素实现Comparable接口，将使用compareTo()方法排序，称之为自然排序；</li>
<li>传递一个比较器自定义排序；</li>
<li>若指定Comparator，则用Comparator排序而忽略Comparable。</li>
<li>TreeSet是SortedSet接口的一个实现。</li>
</ul>
<h3 id="2-3-导航集（有序集）"><a href="#2-3-导航集（有序集）" class="headerlink" title="2.3 导航集（有序集）"></a>2.3 导航集（有序集）</h3><p>NavigableSet 表示Java集合中的可导航集合框架。NavigableSet 接口继承了SortedSet接口和扩展 SortedSet 。</p>
<ul>
<li>TreeSet 类是 NavigableSet 接口的实现类之一。</li>
</ul>
<h2 id="3-列表（List接口）（有序、可重复）"><a href="#3-列表（List接口）（有序、可重复）" class="headerlink" title="3 列表（List接口）（有序、可重复）"></a>3 列表（List接口）（有序、可重复）</h2><ul>
<li>ArrayList：访问快，添加删除慢</li>
<li>LinkedList：访问慢，添加删除快</li>
<li>LinkIterator接口（继承Iterator接口）遍历列表</li>
</ul>
<h2 id="4-队列（Queue接口）（先进先出FIFO）"><a href="#4-队列（Queue接口）（先进先出FIFO）" class="headerlink" title="4 队列（Queue接口）（先进先出FIFO）"></a>4 队列（Queue接口）（先进先出FIFO）</h2><ul>
<li>LinkedList：简单的队列允许在尾部插入和从头部移除。</li>
<li>PriorityQueue：优先级队列为每个元素分配优先级，并允许从队列中删除具有最高优先级的元素。</li>
<li>DelayQueue：延迟队列向每个元素添加延迟，并仅在其延迟已过去时删除该元素。</li>
<li>Deque、ArrayDeque、LinkedList（FIFO或LIFO）：双端队列允许其元件从头部和尾部插入和移除。</li>
<li>BlockingQueue接口（线程安全、适用于生产者/消费者）、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue：阻塞队列阻塞线程，当线程已满时向其添加元素，当线程为空时，它阻止线程从中删除元素。</li>
<li>TransferQueue：传输队列是阻塞队列，其中对象的切换发生在生产者线程和消费者线程之间。</li>
<li>阻塞双端队列是双端队列和阻塞队列的组合。</li>
</ul>
<h2 id="5-映射（Map接口）-（键不能重复）"><a href="#5-映射（Map接口）-（键不能重复）" class="headerlink" title="5 映射（Map接口） （键不能重复）"></a>5 映射（Map<k,v>接口） （键不能重复）</k,v></h2><ul>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>WeakHashMap</li>
</ul>
<h2 id="6-Collection-类"><a href="#6-Collection-类" class="headerlink" title="6 Collection 类"></a>6 Collection 类</h2><p>该类中包含许多静态的辅助方法用于处理集合，如排序、搜索等。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java各版本新特性]]></title>
      <url>/2018/04/01/Java%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h2 id="1-Java8-新特性（2014-3-18）"><a href="#1-Java8-新特性（2014-3-18）" class="headerlink" title="1 Java8 新特性（2014/3/18）"></a>1 Java8 新特性（2014/3/18）</h2><ul>
<li><p><strong>Lambda 表达式</strong> − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 java 7 排序</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortUsingJava7</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;   </div><div class="line">  Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> s1.compareTo(s2);</div><div class="line">      &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用 java 8 排序</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortUsingJava8</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;</div><div class="line">  Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
</li>
<li><p><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">      Vehicle vehicle = <span class="keyword">new</span> Car();</div><div class="line">      vehicle.print();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blowHorn</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"按喇叭!!!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FourWheeler</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"我是一辆四轮车!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span>, <span class="title">FourWheeler</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">      Vehicle.<span class="keyword">super</span>.print();</div><div class="line">      FourWheeler.<span class="keyword">super</span>.print();</div><div class="line">      Vehicle.blowHorn();</div><div class="line">      System.out.println(<span class="string">"我是一辆汽车!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</p>
</li>
<li><p><strong>Stream API（链式编程）</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。  </li>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</div><div class="line">List&lt;String&gt; filtered = strings.stream()</div><div class="line">                                .filter(string -&gt; !string.isEmpty())</div><div class="line">                                .collect(Collectors.toList());</div><div class="line"> </div><div class="line">System.out.println(<span class="string">"筛选列表: "</span> + filtered);</div><div class="line">String mergedString = strings.stream()</div><div class="line">                              .filter(string -&gt; !string.isEmpty())</div><div class="line">                              .collect(Collectors.joining(<span class="string">", "</span>));</div><div class="line">System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Date Time API − 加强对日期与时间的处理。</p>
</li>
<li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
<a id="more"></a>
<h1 id="2-Java9-新特性（）"><a href="#2-Java9-新特性（）" class="headerlink" title="2 Java9 新特性（）"></a>2 Java9 新特性（）</h1><h1 id="3-Java10-新特性（2018-3-20）"><a href="#3-Java10-新特性（2018-3-20）" class="headerlink" title="3 Java10 新特性（2018/3/20）"></a>3 Java10 新特性（2018/3/20）</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识02]]></title>
      <url>/2018/03/29/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8602/</url>
      <content type="html"><![CDATA[<h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-枚举（Enumeration）"><a href="#1-1-枚举（Enumeration）" class="headerlink" title="1.1 枚举（Enumeration）"></a>1.1 枚举（Enumeration）</h3><p>定义了一种从数据结构中取回连续元素的方式，已被迭代器取代。</p>
<h3 id="1-2-位集合（BitSet）"><a href="#1-2-位集合（BitSet）" class="headerlink" title="1.2 位集合（BitSet）"></a>1.2 位集合（BitSet）</h3><p>实现了一组可以单独设置和清除的位或标志。该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</p>
<h3 id="1-3-向量（Vector）"><a href="#1-3-向量（Vector）" class="headerlink" title="1.3 向量（Vector）"></a>1.3 向量（Vector）</h3><ul>
<li>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。</li>
<li>和数组一样，Vector对象的元素也能通过索引访问。</li>
<li>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</li>
</ul>
<h3 id="1-4-栈（Stack）"><a href="#1-4-栈（Stack）" class="headerlink" title="1.4 栈（Stack）"></a>1.4 栈（Stack）</h3><p>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</p>
<h3 id="1-5-字典（Dictionary）（已过时，使用Map接口替代）"><a href="#1-5-字典（Dictionary）（已过时，使用Map接口替代）" class="headerlink" title="1.5 字典（Dictionary）（已过时，使用Map接口替代）"></a>1.5 字典（Dictionary）（已过时，使用Map接口替代）</h3><p>字典（Dictionary） 类是一个<strong>抽象类</strong>，它定义了键映射到值的数据结构。</p>
<h3 id="1-6-哈希表（Hashtable）"><a href="#1-6-哈希表（Hashtable）" class="headerlink" title="1.6 哈希表（Hashtable）"></a>1.6 哈希表（Hashtable）</h3><p>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。</p>
<h3 id="1-7-属性（Properties）"><a href="#1-7-属性（Properties）" class="headerlink" title="1.7 属性（Properties）"></a>1.7 属性（Properties）</h3><p>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</p>
<a id="more"></a>
<h2 id="2-集合框架"><a href="#2-集合框架" class="headerlink" title="2 集合框架"></a>2 <strong>集合框架</strong></h2><p>集合框架是一个用来代表和操纵集合的统一架构。</p>
<h3 id="2-1-设计目标"><a href="#2-1-设计目标" class="headerlink" title="2.1 设计目标"></a>2.1 设计目标</h3><ul>
<li>高性能,基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。</li>
</ul>
<h3 id="2-2-内容"><a href="#2-2-内容" class="headerlink" title="2.2 内容"></a>2.2 内容</h3><ul>
<li>接口：是代表集合的抽象数据类型。接口允许集合独立操纵其代表的细节。在面向对象的语言，接口通常形成一个层次。</li>
<li>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。</li>
<li>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li>
</ul>
<h3 id="2-3-集合接口"><a href="#2-3-集合接口" class="headerlink" title="2.3 集合接口"></a>2.3 集合接口</h3><table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Collection 接口</td>
<td>允许你使用一组对象，是Collection层次结构的根接口。</td>
</tr>
<tr>
<td>List 接口</td>
<td>继承于Collection和一个 List实例存储一个有序集合的元素。</td>
</tr>
<tr>
<td>Set</td>
<td>继承于 Collection，是一个不包含重复元素的集合。</td>
</tr>
<tr>
<td>SortedSet</td>
<td>继承于Set保存有序的集合。</td>
</tr>
<tr>
<td>Map</td>
<td>将唯一的键映射到值。</td>
</tr>
<tr>
<td>Map.Entry</td>
<td>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</td>
</tr>
<tr>
<td>SortedMap</td>
<td>继承于Map，使Key保持在升序排列。</td>
</tr>
<tr>
<td>Enumeration</td>
<td>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</td>
</tr>
</tbody>
</table>
<h3 id="2-4-集合类"><a href="#2-4-集合类" class="headerlink" title="2.4 集合类"></a>2.4 集合类</h3><table>
<thead>
<tr>
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbstractCollection</td>
<td>实现了大部分的集合接口。</td>
</tr>
<tr>
<td>AbstractList</td>
<td>继承于AbstractCollection 并且实现了大部分List接口。</td>
</tr>
<tr>
<td>AbstractSequentialList</td>
<td>继承于AbstractList，提供了对数据元素的链式访问而不是随机访问。</td>
</tr>
<tr>
<td>LinkedList</td>
<td>继承于 AbstractSequentialList，实现了一个链表。</td>
</tr>
<tr>
<td>ArrayList</td>
<td>通过继承AbstractList，实现动态数组。</td>
</tr>
<tr>
<td>AbstractSet</td>
<td>继承于AbstractCollection 并且实现了大部分Set接口。</td>
</tr>
<tr>
<td>HashSet</td>
<td>继承了AbstractSet，并且使用一个哈希表。</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。</td>
</tr>
<tr>
<td>TreeSet</td>
<td>继承于AbstractSet，使用元素的自然顺序对元素进行排序.</td>
</tr>
<tr>
<td>AbstractMap</td>
<td>实现了大部分的Map接口。</td>
</tr>
<tr>
<td>HashMap</td>
<td>继承了HashMap，并且使用一个哈希表。</td>
</tr>
<tr>
<td>TreeMap</td>
<td>继承了AbstractMap，并且使用一颗树。</td>
</tr>
<tr>
<td>WeakHashMap</td>
<td>继承AbstractMap类，使用弱密钥的哈希表。</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>继承于HashMap，使用元素的自然顺序对元素进行排序.</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>继承AbstractMap类，比较文档时使用引用相等。</td>
</tr>
</tbody>
</table>
<h2 id="3-序列化"><a href="#3-序列化" class="headerlink" title="3 序列化"></a>3 序列化</h2><ul>
<li>一个类的对象要想序列化成功，必须满足两个条件：<ul>
<li>该类必须实现 java.io.Serializable 对象。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的（transient ）。</li>
</ul>
</li>
<li><p>ObjectOutputStream（writeObject）—：序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException</span></div></pre></td></tr></table></figure>
</li>
<li><p>ObjectInputStream（readObject）：反序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4 网络编程"></a>4 网络编程</h2><h3 id="4-1-网络协议（java-net）"><a href="#4-1-网络协议（java-net）" class="headerlink" title="4.1 网络协议（java.net）"></a>4.1 网络协议（java.net）</h3><ul>
<li>TCP： TCP是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称TCP / IP。</li>
<li>UDP:UDP是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。</li>
</ul>
<h3 id="4-2-Socket（java-net-Socket）"><a href="#4-2-Socket（java-net-Socket）" class="headerlink" title="4.2 Socket（java.net.Socket）"></a>4.2 Socket（java.net.Socket）</h3><p>主要使用ServerSocket和Socket类</p>
<ul>
<li><ol>
<li>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</li>
</ol>
</li>
<li><ol>
<li>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li>
</ol>
</li>
<li><ol>
<li>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</li>
</ol>
</li>
<li><ol>
<li>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</li>
</ol>
</li>
<li><ol>
<li>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</li>
</ol>
</li>
</ul>
<h2 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5 多线程"></a>5 多线程</h2><h3 id="5-1-线程的生命周期"><a href="#5-1-线程的生命周期" class="headerlink" title="5.1 线程的生命周期"></a>5.1 线程的生命周期</h3><p><img src="/images/posts/Java_Thread.jpg" alt="Thread"></p>
<ul>
<li>新建状态:使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</li>
<li>就绪状态:当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</li>
<li>运行状态:如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</li>
<li>阻塞状态:如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
</li>
<li>死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</li>
</ul>
<h3 id="5-2-线程的优先级"><a href="#5-2-线程的优先级" class="headerlink" title="5.2 线程的优先级"></a>5.2 线程的优先级</h3><ul>
<li>线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</li>
<li>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</li>
</ul>
<h3 id="5-3-创建线程"><a href="#5-3-创建线程" class="headerlink" title="5.3 创建线程"></a>5.3 创建线程</h3><ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<h2 id="6-文档注释"><a href="#6-文档注释" class="headerlink" title="6 文档注释"></a>6 文档注释</h2><h3 id="6-1-javadoc-标签"><a href="#6-1-javadoc-标签" class="headerlink" title="6.1 javadoc 标签"></a>6.1 javadoc 标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>@author</td>
<td>标识一个类的作者</td>
<td>@author description</td>
</tr>
<tr>
<td>@deprecated</td>
<td>指名一个过期的类或成员</td>
<td>@deprecated description</td>
</tr>
<tr>
<td>{@docRoot}</td>
<td>指明当前文档根目录的路径</td>
<td>Directory Path</td>
</tr>
<tr>
<td>@exception</td>
<td>标志一个类抛出的异常</td>
<td>@exception exception-name explanation</td>
</tr>
<tr>
<td>{@inheritDoc}</td>
<td>从直接父类继承的注释</td>
<td>Inherits a comment from the immediate surperclass.</td>
</tr>
<tr>
<td>{@link}</td>
<td>插入一个到另一个主题的链接</td>
<td>{@link name text}</td>
</tr>
<tr>
<td>{@linkplain}</td>
<td>插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td>Inserts an in-line link to another topic.</td>
</tr>
<tr>
<td>@param</td>
<td>说明一个方法的参数</td>
<td>@param parameter-name explanation</td>
</tr>
<tr>
<td>@return</td>
<td>说明返回值类型</td>
<td>@return explanation</td>
</tr>
<tr>
<td>@see</td>
<td>指定一个到另一个主题的链接</td>
<td>@see anchor</td>
</tr>
<tr>
<td>@serial</td>
<td>说明一个序列化属性</td>
<td>@serial description</td>
</tr>
<tr>
<td>@serialData</td>
<td>说明通过writeObject( ) 和 writeExternal( )方法写的数据</td>
<td>@serialData description</td>
</tr>
<tr>
<td>@serialField</td>
<td>说明一个ObjectStreamField组件</td>
<td>@serialField name type description</td>
</tr>
<tr>
<td>@since</td>
<td>标记当引入一个特定的变化时</td>
<td>@since release</td>
</tr>
<tr>
<td>@throws</td>
<td>和 @exception标签一样.</td>
<td>The @throws tag has the same meaning as the @exception tag.</td>
</tr>
<tr>
<td>{@value}</td>
<td>显示常量的值，该常量必须是static属性。</td>
<td>Displays the value of a constant, which must be a static field.</td>
</tr>
<tr>
<td>@version</td>
<td>指定类的版本</td>
<td>@version info</td>
</tr>
</tbody>
</table>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java环境变量配置]]></title>
      <url>/2018/03/25/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="1-Java下载"><a href="#1-Java下载" class="headerlink" title="1 Java下载"></a>1 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">Java下载</a></h2><h2 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2 环境变量配置"></a>2 环境变量配置</h2><ol>
<li><strong>JAVA_HOME</strong>:C:\Program Files\Java\jdk1.8.0_144（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%JAVA_HOME%\bin;</li>
<li><strong>CLASS_PATH</strong>:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</li>
</ol>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h2><ul>
<li><strong>java-version</strong>:版本号</li>
<li><strong>java</strong>:Java环境</li>
<li><strong>javac</strong>:Java编译器</li>
</ul>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识01]]></title>
      <url>/2018/03/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/</url>
      <content type="html"><![CDATA[<h2 id="1-Hello-World-示例"><a href="#1-Hello-World-示例" class="headerlink" title="1 Hello World 示例"></a>1 Hello World 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello World"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ps:</code></p>
<ul>
<li>Java 中类名（CamelCase 风格）要与文件名保持一致；</li>
<li>Java 中方法名 camelCase 风格；</li>
<li>main 主函数参数默认为 String []；</li>
</ul>
<a id="more"></a>
<h2 id="2-Java-标识符"><a href="#2-Java-标识符" class="headerlink" title="2 Java 标识符"></a>2 Java 标识符</h2><ul>
<li>所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始</li>
</ul>
<h2 id="3-Java-变量"><a href="#3-Java-变量" class="headerlink" title="3 Java 变量"></a>3 Java 变量</h2><ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<h2 id="4-Java-关键字"><a href="#4-Java-关键字" class="headerlink" title="4 Java 关键字"></a>4 Java 关键字</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract</td>
<td>抽象方法，抽象类的修饰符</td>
</tr>
<tr>
<td>assert</td>
<td>断言条件是否满足</td>
</tr>
<tr>
<td>boolean</td>
<td>布尔数据类型</td>
</tr>
<tr>
<td>break</td>
<td>跳出循环或者label代码段</td>
</tr>
<tr>
<td>byte</td>
<td>8-bit 有符号数据类型</td>
</tr>
<tr>
<td>case</td>
<td>switch语句的一个条件</td>
</tr>
<tr>
<td>catch</td>
<td>try搭配捕捉异常信息</td>
</tr>
<tr>
<td>char</td>
<td>16-bit Unicode字符数据类型</td>
</tr>
<tr>
<td>class</td>
<td>定义类</td>
</tr>
<tr>
<td>const</td>
<td>未使用</td>
</tr>
<tr>
<td>continue</td>
<td>不执行循环体剩余部分</td>
</tr>
<tr>
<td>default</td>
<td>switch语句中的默认分支</td>
</tr>
<tr>
<td>do</td>
<td>循环语句，循环体至少会执行一次</td>
</tr>
<tr>
<td>double</td>
<td>64-bit双精度浮点数</td>
</tr>
<tr>
<td>else</td>
<td>if条件不成立时执行的分支</td>
</tr>
<tr>
<td>enum</td>
<td>枚举类型</td>
</tr>
<tr>
<td>extends</td>
<td>表示一个类是另一个类的子类</td>
</tr>
<tr>
<td>final</td>
<td>表示一个值在初始化之后就不能再改变了或表示方法不能被重写，或者一个类不能有子类</td>
</tr>
<tr>
<td>finally</td>
<td>为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。</td>
</tr>
<tr>
<td>float</td>
<td>32-bit单精度浮点数</td>
</tr>
<tr>
<td>for</td>
<td>for循环语句</td>
</tr>
<tr>
<td>goto</td>
<td>未使用</td>
</tr>
<tr>
<td>if</td>
<td>条件语句</td>
</tr>
<tr>
<td>implements</td>
<td>表示一个类实现了接口</td>
</tr>
<tr>
<td>import</td>
<td>导入类</td>
</tr>
<tr>
<td><strong>instanceof</strong></td>
<td>测试一个对象是否是某个类的实例</td>
</tr>
<tr>
<td>int</td>
<td>32位整型数</td>
</tr>
<tr>
<td>interface</td>
<td>接口，一种抽象的类型，仅有方法和常量的定义</td>
</tr>
<tr>
<td>long</td>
<td>64位整型数</td>
</tr>
<tr>
<td><strong>native</strong></td>
<td>表示方法用非java代码实现</td>
</tr>
<tr>
<td>new</td>
<td>分配新的类实例</td>
</tr>
<tr>
<td>package</td>
<td>一系列相关类组成一个包</td>
</tr>
<tr>
<td>private</td>
<td>表示私有字段，或者方法等，只能从类内部访问</td>
</tr>
<tr>
<td>protected</td>
<td>表示字段只能通过类或者其子类访问子类或者在同一个包内的其他类</td>
</tr>
<tr>
<td>public</td>
<td>表示共有属性或者方法</td>
</tr>
<tr>
<td>return</td>
<td>方法返回值</td>
</tr>
<tr>
<td>short</td>
<td>16位数字</td>
</tr>
<tr>
<td>static</td>
<td>表示在类级别定义，所有实例共享的</td>
</tr>
<tr>
<td><strong>strictfp</strong></td>
<td>浮点数比较使用严格的规则</td>
</tr>
<tr>
<td>super</td>
<td>表示基类</td>
</tr>
<tr>
<td>switch</td>
<td>选择语句</td>
</tr>
<tr>
<td><strong>synchronized</strong></td>
<td>表示同一时间只能由一个线程访问的代码块</td>
</tr>
<tr>
<td>this</td>
<td>表示调用当前实例或者调用另一个构造函数</td>
</tr>
<tr>
<td>throw</td>
<td>抛出异常</td>
</tr>
<tr>
<td><strong>throws</strong></td>
<td>定义方法可能抛出的异常</td>
</tr>
<tr>
<td><strong>transient</strong></td>
<td>修饰不要序列化的字段</td>
</tr>
<tr>
<td>try</td>
<td>表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码</td>
</tr>
<tr>
<td>void</td>
<td>标记方法不返回任何值</td>
</tr>
<tr>
<td><strong>volatile</strong></td>
<td>标记字段可能会被多个线程同时访问，而不做同步</td>
</tr>
<tr>
<td>while</td>
<td>while循环</td>
</tr>
</tbody>
</table>
<h2 id="5-类-amp-对象"><a href="#5-类-amp-对象" class="headerlink" title="5 类&amp;对象"></a>5 类&amp;对象</h2><ul>
<li>对象：对象是类的一个实例，有状态和行为。</li>
<li>类：类是一个模板，它描述一类对象的行为和状态。</li>
<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li>
</ul>
<h2 id="6-源文件"><a href="#6-源文件" class="headerlink" title="6 源文件"></a>6 源文件</h2><ul>
<li>一个源文件中只能有一个 public 类</li>
<li>一个源文件可以有多个非 public 类</li>
<li>源文件的名称应该和 public 类的类名保持一致</li>
<li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li>
<li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li>
<li>import 语句和 package 语句对源文件中定义的所有类都有效。</li>
</ul>
<h2 id="7-基本数据类型"><a href="#7-基本数据类型" class="headerlink" title="7 基本数据类型"></a>7 基本数据类型</h2><p>八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br><em>PS:</em>字符串不属于基本类型。</p>
<h3 id="7-1-byte（java-lang-Byte）"><a href="#7-1-byte（java-lang-Byte）" class="headerlink" title="7.1 byte（java.lang.Byte）"></a>7.1 byte（java.lang.Byte）</h3><ul>
<li>byte数据类型是8位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是-128（-2^7）；</li>
<li>最大值是127（2^7-1）；</li>
<li>默认值是0；</li>
<li>byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；</li>
</ul>
<h3 id="7-2-short（java-lang-Short）"><a href="#7-2-short（java-lang-Short）" class="headerlink" title="7.2 short（java.lang.Short）"></a>7.2 short（java.lang.Short）</h3><ul>
<li>short数据类型是16位、有符号的以二进制补码表示的整数</li>
<li>最小值是-32768（-2^15）；</li>
<li>最大值是32767（2^15 - 1）；</li>
<li>Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
<li>默认值是0；</li>
</ul>
<h3 id="7-3-int（java-lang-Integer）"><a href="#7-3-int（java-lang-Integer）" class="headerlink" title="7.3 int（java.lang.Integer）"></a>7.3 int（java.lang.Integer）</h3><ul>
<li>int数据类型是32位、有符号的以二进制补码表示的整数；</li>
<li>最小值是-2,147,483,648（-2^31）；</li>
<li>最大值是2,147,483,647（2^31 - 1）；</li>
<li>一般地整型变量默认为int类型；</li>
<li>默认值是0；</li>
</ul>
<h3 id="7-4-long（java-lang-Long）"><a href="#7-4-long（java-lang-Long）" class="headerlink" title="7.4 long（java.lang.Long）"></a>7.4 long（java.lang.Long）</h3><ul>
<li>long数据类型是64位、有符号的以二进制补码表示的整数；</li>
<li>最小值是-9,223,372,036,854,775,808（-2^63）；</li>
<li>最大值是9,223,372,036,854,775,807（2^63 -1）；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是0L；</li>
</ul>
<h3 id="7-5-float（java-lang-Float）"><a href="#7-5-float（java-lang-Float）" class="headerlink" title="7.5 float（java.lang.Float）"></a>7.5 float（java.lang.Float）</h3><ul>
<li>float数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
<li>float在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是0.0f；</li>
<li><strong>浮点数不能用来表示精确的值</strong>，如货币；</li>
</ul>
<h3 id="7-6-double（java-lang-Double）"><a href="#7-6-double（java-lang-Double）" class="headerlink" title="7.6 double（java.lang.Double）"></a>7.6 double（java.lang.Double）</h3><ul>
<li>double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</li>
<li>浮点数的默认类型为double类型；</li>
<li><strong>double类型同样不能表示精确的值</strong>，如货币；</li>
</ul>
<h3 id="7-7-boolean"><a href="#7-7-boolean" class="headerlink" title="7.7 boolean"></a>7.7 boolean</h3><ul>
<li>boolean数据类型表示一位的信息；</li>
<li>只有两个取值：true和false；</li>
<li>这种类型只作为一种标志来记录true/false情况；</li>
<li>默认值是false；</li>
</ul>
<h3 id="7-8-char（java-lang-Character）"><a href="#7-8-char（java-lang-Character）" class="headerlink" title="7.8 char（java.lang.Character）"></a>7.8 char（java.lang.Character）</h3><ul>
<li>char类型是一个单一的16位Unicode字符；</li>
<li>最小值是’\u0000’（即为0）；</li>
<li>最大值是’\uffff’（即为65,535）；</li>
<li>char数据类型可以储存任何字符；</li>
</ul>
<h3 id="7-9-void（java-lang-Void）"><a href="#7-9-void（java-lang-Void）" class="headerlink" title="7.9 void（java.lang.Void）"></a>7.9 void（java.lang.Void）</h3><p>实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<h2 id="8-引用类型"><a href="#8-引用类型" class="headerlink" title="8 引用类型"></a>8 引用类型</h2><ul>
<li>引用类型变量由类的构造函数创建，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。</li>
<li>对象、<strong>数组</strong>、<strong>字符串</strong>都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用与任何与之兼容的类型。</li>
</ul>
<h2 id="9-常量（final）"><a href="#9-常量（final）" class="headerlink" title="9 常量（final）"></a>9 常量（final）</h2><ul>
<li>常量就是一个固定值。</li>
<li>通常使用大写字母表示常量。</li>
<li><strong>字符串</strong>是常量。</li>
</ul>
<h2 id="10-局部变量"><a href="#10-局部变量" class="headerlink" title="10 局部变量"></a>10 局部变量</h2><ul>
<li>局部变量声明在方法、构造方法或者语句块中；</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以<strong>局部变量被声明后，必须经过初始化，才可以使用</strong>。</li>
</ul>
<h2 id="11-实例变量"><a href="#11-实例变量" class="headerlink" title="11 实例变量"></a>11 实例变量</h2><ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
</ul>
<h2 id="12-类变量（静态变量）"><a href="#12-类变量（静态变量）" class="headerlink" title="12 类变量（静态变量）"></a>12 类变量（静态变量）</h2><ul>
<li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法、构造方法和语句块之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。<strong>常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</strong></li>
<li><strong>静态变量储存在静态存储区</strong>。经常被声明为常量，很少单独使用static声明变量。</li>
<li><strong>静态变量在程序开始时创建，在程序结束时销毁</strong>。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li>
<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以- 在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：ClassName.VariableName的方式访问。</li>
<li><strong>类变量被声明为public static final类型时，类变量名称必须使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</strong></li>
</ul>
<h2 id="13-访问控制修饰符"><a href="#13-访问控制修饰符" class="headerlink" title="13 访问控制修饰符"></a>13 访问控制修饰符</h2><ul>
<li>default：默认的，在同一包内可见，不使用任何修饰符。<ul>
<li>接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为public。</li>
</ul>
</li>
<li>private：私有的，在同一类内可见。</li>
<li>public：共有的，对所有类可见。</li>
<li>protected 受保护的，对<strong>同一包内的类和所有子类</strong>可见（<strong>注意</strong>：此处对应C#的protected internal，而C#中protected仅仅对所有程序集的子类可见，而对包内的类不可见）。<ul>
<li>Protected访问修饰符不能修饰类和接口，方法和成员变量能够声明为protected，但是接口的成员变量和成员方法不能声明为protected。</li>
</ul>
</li>
</ul>
<h2 id="14-访问控制和继承"><a href="#14-访问控制和继承" class="headerlink" title="14 访问控制和继承"></a>14 访问控制和继承</h2><ul>
<li>父类中声明为public的方法在子类中也必须为public。</li>
<li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。</li>
<li>父类中声明为private的方法，不能够被继承。</li>
</ul>
<h2 id="15-非访问修饰符"><a href="#15-非访问修饰符" class="headerlink" title="15 非访问修饰符"></a>15 非访问修饰符</h2><ul>
<li>static<ul>
<li>用来创建类方法和类变量。</li>
</ul>
</li>
<li>final<ul>
<li>用来修饰类、方法和变量，<strong>final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的</strong>。</li>
<li>final变量能被显式地初始化并且只能初始化一次。<strong>被声明为final的对象的引用不能指向不同的对象。但是final对象里的数据可以被改变。</strong>也就是说final对象的引用不能改变，但是里面的值可以改变。</li>
<li>final修饰符通常和static修饰符一起使用来创建类常量。</li>
<li>类中的Final方法可以被子类继承，但是不能被子类修改。声明final方法的主要目的是防止该方法的内容被修改。</li>
<li>final类不能被继承，没有类能够继承final类的任何特性。（即C#的sealed）</li>
</ul>
</li>
<li>abstract<ul>
<li>用来创建抽象类和抽象方法。</li>
<li>一个类不能同时被abstract和final修饰。</li>
<li>抽象类可以包含抽象方法和非抽象方法。</li>
<li>抽象方法不能被声明成final和static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li>
</ul>
</li>
<li>synchronized<ul>
<li>synchronized关键字声明的方法同一时间只能被一个线程访问。synchronized修饰符可以应用于四个访问修饰符。</li>
</ul>
</li>
<li>Transient<ul>
<li>序列化的对象包含被transient修饰的实例变量时，java虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</li>
</ul>
</li>
<li>volatile<ul>
<li>volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。</li>
</ul>
</li>
</ul>
<h2 id="16-位运算符"><a href="#16-位运算符" class="headerlink" title="16 位运算符"></a>16 位运算符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>&amp;</strong></td>
<td>按位与操作符，当且仅当两个操作数的某一位都非0时候结果的该位才为1。</td>
</tr>
<tr>
<td><strong>&#124;</strong></td>
<td>按位或操作符，只要两个操作数的某一位有一个非0时候结果的该位就为1。</td>
</tr>
<tr>
<td><strong>^</strong></td>
<td>按位异或操作符，两个操作数的某一位不相同时候结果的该位就为1。    </td>
</tr>
<tr>
<td><strong>〜</strong></td>
<td>按位补运算符翻转操作数的每一位。    </td>
</tr>
<tr>
<td><strong>&lt;&lt;</strong></td>
<td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td>
</tr>
<tr>
<td><strong>&gt;&gt;</strong></td>
<td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td>
</tr>
<tr>
<td><strong>&gt;&gt;&gt;</strong></td>
<td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td>
</tr>
</tbody>
</table>
<h2 id="17-instanceOf"><a href="#17-instanceOf" class="headerlink" title="17 instanceOf"></a>17 instanceOf</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String name = <span class="string">'James'</span>;</div><div class="line"><span class="keyword">boolean</span> result = name instanceOf String; <span class="comment">// 由于name是Strine类型，所以返回true</span></div></pre></td></tr></table></figure></p>
<h2 id="18-for增强（即C-的foreach）"><a href="#18-for增强（即C-的foreach）" class="headerlink" title="18 for增强（即C#的foreach）"></a>18 for增强（即C#的foreach）</h2><p><code>·</code>要用于数组(Java5，之后不清楚是否有扩展，待确认)`</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : numbers )&#123;</div><div class="line">  System.out.print( x );</div><div class="line">  System.out.print(<span class="string">","</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="19-switch"><a href="#19-switch" class="headerlink" title="19 switch"></a>19 switch</h2><ul>
<li>switch语句中的变量类型只能为byte、short、int或者char。<code>(不清楚后续版本是否有扩展，待确认)</code></li>
<li>case语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li>
<li>switch语句可以包含一个default分支，<strong>该分支必须是switch语句的最后一个分支</strong>（C#中不一定是最后一个）。</li>
</ul>
<h2 id="20-Number类（java-lang）"><a href="#20-Number类（java-lang）" class="headerlink" title="20 Number类（java.lang）"></a>20 Number类（java.lang）</h2><p><img src="/images/posts/Java_Number.jpg" alt="图一"></p>
<h2 id="21-String类"><a href="#21-String类" class="headerlink" title="21 String类"></a>21 String类</h2><ul>
<li><strong>字符串属于对象</strong></li>
<li><strong>和C#不同的是，Java中只有String，而没有string！！！</strong></li>
<li><strong>String类是不可改变的，所以你一旦创建了String对象，那它的值就无法改变了。</strong></li>
<li><strong>字符串长度使用length(),即方法而不是C#的属性length。</strong></li>
</ul>
<h2 id="22-StringBuffer和StringBuilder"><a href="#22-StringBuffer和StringBuilder" class="headerlink" title="22 StringBuffer和StringBuilder"></a>22 StringBuffer和StringBuilder</h2><ul>
<li>StringBuilder的方法不是线程安全的（不能同步访问）,而StringBuffer是。</li>
<li>StringBuilder相较于StringBuffer有速度优势，多数情况下建议使用StringBuilder类。</li>
<li>在应用程序要求线程安全的情况下，则必须使用StringBuffer类。</li>
</ul>
<h2 id="23-数组"><a href="#23-数组" class="headerlink" title="23 数组"></a>23 数组</h2><h3 id="23-1-数组"><a href="#23-1-数组" class="headerlink" title="23.1 数组"></a>23.1 数组</h3><p><img src="/images/posts/Java_Array.jpg" alt="图一"></p>
<h3 id="23-2-Arrays-类-java-util-Arrays"><a href="#23-2-Arrays-类-java-util-Arrays" class="headerlink" title="23.2 Arrays 类(java.util.Arrays)"></a>23.2 Arrays 类(java.util.Arrays)</h3><ul>
<li>所有方法都是静态的</li>
<li>给数组赋值：通过fill方法。</li>
<li>对数组排序：通过sort方法,按升序。</li>
<li>比较数组：通过equals方法比较数组中<strong>元素值</strong>是否相等。</li>
<li>查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找法操作</li>
</ul>
<h2 id="24-时间"><a href="#24-时间" class="headerlink" title="24 时间"></a>24 时间</h2><h3 id="24-1-Date-类-java-util-Date"><a href="#24-1-Date-类-java-util-Date" class="headerlink" title="24.1 Date 类(java.util.Date)"></a>24.1 Date 类(java.util.Date)</h3><p>System.currentTimeMillis()计算时间</p>
<h3 id="24-2-SimpleDateFormat：格式化日期"><a href="#24-2-SimpleDateFormat：格式化日期" class="headerlink" title="24.2 SimpleDateFormat：格式化日期"></a>24.2 SimpleDateFormat：格式化日期</h3><table>
<thead>
<tr>
<th>字母</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>纪元标记</td>
<td>AD</td>
</tr>
<tr>
<td>y</td>
<td>四位年份</td>
<td>2001</td>
</tr>
<tr>
<td>M</td>
<td>月份</td>
<td>July or 07</td>
</tr>
<tr>
<td>d</td>
<td>一个月的日期</td>
<td>10</td>
</tr>
<tr>
<td>h</td>
<td>A.M./P.M.(1~12)格式小时</td>
<td>12</td>
</tr>
<tr>
<td>H</td>
<td>一天中的小时(0~23)</td>
<td>22</td>
</tr>
<tr>
<td>m</td>
<td>分钟数</td>
<td>30</td>
</tr>
<tr>
<td>s</td>
<td>秒数</td>
<td>55</td>
</tr>
<tr>
<td>S</td>
<td>微妙数</td>
<td>234</td>
</tr>
<tr>
<td>E</td>
<td>星期几</td>
<td>Tuesday</td>
</tr>
<tr>
<td>D</td>
<td>一年中的日子</td>
<td>360</td>
</tr>
<tr>
<td>F</td>
<td>一个月中第几周的周几</td>
<td>2 (second Wed. in July)</td>
</tr>
<tr>
<td>w</td>
<td>一年中第几周</td>
<td>40</td>
</tr>
<tr>
<td>W</td>
<td>一个月中第几周</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>A.M./P.M. 标记</td>
<td>PM</td>
</tr>
<tr>
<td>k</td>
<td>一天中的小时(1~24)</td>
<td>24</td>
</tr>
<tr>
<td>K</td>
<td>A.M./P.M. (0~11)格式小时</td>
<td>10</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
<td>Eastern Standard Time</td>
</tr>
<tr>
<td>‘</td>
<td>文字定界符</td>
<td>Delimiter</td>
</tr>
<tr>
<td>“</td>
<td>单引号</td>
<td>`</td>
</tr>
</tbody>
</table>
<h3 id="24-3-Calendar"><a href="#24-3-Calendar" class="headerlink" title="24.3 Calendar"></a>24.3 Calendar</h3><ul>
<li>抽象类</li>
<li>getInstance()获取实例</li>
</ul>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Calendar.YEAR</td>
<td>年份</td>
</tr>
<tr>
<td>Calendar.MONTH</td>
<td>月份</td>
</tr>
<tr>
<td>Calendar.DATE</td>
<td>日期</td>
</tr>
<tr>
<td>Calendar.DAY_OF_MONTH</td>
<td>日期，和上面的字段意义完全相同</td>
</tr>
<tr>
<td>Calendar.HOUR</td>
<td>12小时制的小时</td>
</tr>
<tr>
<td>Calendar.HOUR_OF_DAY</td>
<td>24小时制的小时</td>
</tr>
<tr>
<td>Calendar.MINUTE</td>
<td>分钟</td>
</tr>
<tr>
<td>Calendar.SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>Calendar.DAY_OF_WEEK</td>
<td>星期几</td>
</tr>
</tbody>
</table>
<h3 id="24-4-GregorianCalendar"><a href="#24-4-GregorianCalendar" class="headerlink" title="24.4 GregorianCalendar"></a>24.4 GregorianCalendar</h3><h2 id="25-正则（java-util-regex包）"><a href="#25-正则（java-util-regex包）" class="headerlink" title="25 正则（java.util.regex包）"></a>25 正则（java.util.regex包）</h2><ul>
<li>Pattern类：pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。</li>
<li>Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。</li>
<li>PatternSyntaxException：PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td><code>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，&quot;n&quot;匹配字符&quot;n&quot;。&quot;\n&quot;匹配换行符。序列&quot;\\&quot;匹配&quot;\&quot;，&quot;\(&quot;匹配&quot;(&quot;。</code></td>
</tr>
<tr>
<td>^</td>
<td><code>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与&quot;\n&quot;或&quot;\r&quot;之后的位置匹配。</code></td>
</tr>
<tr>
<td>$</td>
<td><code>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与&quot;\n&quot;或&quot;\r&quot;之前的位置匹配。</code></td>
</tr>
<tr>
<td>*</td>
<td><code>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配&quot;z&quot;和&quot;zoo&quot;。* 等效于 {0,}。</code></td>
</tr>
<tr>
<td>+</td>
<td><code>一次或多次匹配前面的字符或子表达式。例如，&quot;zo+&quot;与&quot;zo&quot;和&quot;zoo&quot;匹配，但与&quot;z&quot;不匹配。+ 等效于 {1,}。</code></td>
</tr>
<tr>
<td>?</td>
<td><code>零次或一次匹配前面的字符或子表达式。例如，&quot;do(es)?&quot;匹配&quot;do&quot;或&quot;does&quot;中的&quot;do&quot;。? 等效于 {0,1}。</code></td>
</tr>
<tr>
<td>{n}</td>
<td><code>n 是非负整数。正好匹配 n 次。例如，&quot;o{2}&quot;与&quot;Bob&quot;中的&quot;o&quot;不匹配，但与&quot;food&quot;中的两个&quot;o&quot;匹配。</code></td>
</tr>
<tr>
<td>{n,}</td>
<td><code>n 是非负整数。至少匹配 n 次。例如，&quot;o{2,}&quot;不匹配&quot;Bob&quot;中的&quot;o&quot;，而匹配&quot;foooood&quot;中的所有 o。&quot;o{1,}&quot;等效于&quot;o+&quot;。&quot;o{0,}&quot;等效于&quot;o*&quot;。</code></td>
</tr>
<tr>
<td>{n,m}</td>
<td><code>M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，&quot;o{1,3}&quot;匹配&quot;fooooood&quot;中的头三个 o。&#39;o{0,1}&#39; 等效于 &#39;o?&#39;。注意：您不能将空格插入逗号和数字之间。</code></td>
</tr>
<tr>
<td>?</td>
<td><code>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是&quot;非贪心的&quot;。&quot;非贪心的&quot;模式匹配搜索到的、尽可能短的字符串，而默认的&quot;贪心的&quot;模式匹配搜索到的、尽可能长的字符串。例如，在字符串&quot;oooo&quot;中，&quot;o+?&quot;只匹配单个&quot;o&quot;，而&quot;o+&quot;匹配所有&quot;o&quot;。</code></td>
</tr>
<tr>
<td>.</td>
<td><code>匹配除&quot;\r\n&quot;之外的任何单个字符。若要匹配包括&quot;\r\n&quot;在内的任意字符，请使用诸如&quot;[\s\S]&quot;之类的模式。</code></td>
</tr>
<tr>
<td>(pattern)</td>
<td><code>匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果&quot;匹配&quot;集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用&quot;\(&quot;或者&quot;\)&quot;。</code></td>
</tr>
<tr>
<td>(?:pattern)</td>
<td><code>匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用&quot;or&quot;字符 (&amp;#124;) 组合模式部件的情况很有用。例如，&#39;industr(?:y&amp;#124;ies) 是比 &#39;industry&amp;#124;industries&#39; 更经济的表达式。</code></td>
</tr>
<tr>
<td>(?=pattern)</td>
<td><code>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#39;Windows (?=95&amp;#124;98&amp;#124;NT&amp;#124;2000)&#39; 匹配&quot;Windows 2000&quot;中的&quot;Windows&quot;，但不匹配&quot;Windows 3.1&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</code></td>
</tr>
<tr>
<td>(?!pattern)</td>
<td><code>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#39;Windows (?!95&amp;#124;98&amp;#124;NT&amp;#124;2000)&#39; 匹配&quot;Windows 3.1&quot;中的 &quot;Windows&quot;，但不匹配&quot;Windows 2000&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</code></td>
</tr>
<tr>
<td>x&#124;y</td>
<td><code>匹配 x 或 y。例如，&#39;z&amp;#124;food&#39; 匹配&quot;z&quot;或&quot;food&quot;。&#39;(z&amp;#124;f)ood&#39; 匹配&quot;zood&quot;或&quot;food&quot;。</code></td>
</tr>
<tr>
<td>[xyz]</td>
<td><code>字符集。匹配包含的任一字符。例如，&quot;[abc]&quot;匹配&quot;plain&quot;中的&quot;a&quot;。</code></td>
</tr>
<tr>
<td>[^xyz]</td>
<td><code>反向字符集。匹配未包含的任何字符。例如，&quot;[^abc]&quot;匹配&quot;plain&quot;中&quot;p&quot;，&quot;l&quot;，&quot;i&quot;，&quot;n&quot;。</code></td>
</tr>
<tr>
<td>[a-z]</td>
<td><code>字符范围。匹配指定范围内的任何字符。例如，&quot;[a-z]&quot;匹配&quot;a&quot;到&quot;z&quot;范围内的任何小写字母。</code></td>
</tr>
<tr>
<td>[^a-z]</td>
<td><code>反向范围字符。匹配不在指定的范围内的任何字符。例如，&quot;[^a-z]&quot;匹配任何不在&quot;a&quot;到&quot;z&quot;范围内的任何字符。</code></td>
</tr>
<tr>
<td>\b</td>
<td><code>匹配一个字边界，即字与空格间的位置。例如，&quot;er\b&quot;匹配&quot;never&quot;中的&quot;er&quot;，但不匹配&quot;verb&quot;中的&quot;er&quot;。</code></td>
</tr>
<tr>
<td>\B</td>
<td><code>非字边界匹配。&quot;er\B&quot;匹配&quot;verb&quot;中的&quot;er&quot;，但不匹配&quot;never&quot;中的&quot;er&quot;。</code></td>
</tr>
<tr>
<td>\cx</td>
<td><code>匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是&quot;c&quot;字符本身。</code></td>
</tr>
<tr>
<td>\d</td>
<td><code>数字字符匹配。等效于 [0-9]。</code></td>
</tr>
<tr>
<td>\D</td>
<td><code>非数字字符匹配。等效于 [^0-9]。</code></td>
</tr>
<tr>
<td>\f</td>
<td><code>换页符匹配。等效于 \x0c 和 \cL。</code></td>
</tr>
<tr>
<td>\n</td>
<td><code>换行符匹配。等效于 \x0a 和 \cJ。</code></td>
</tr>
<tr>
<td>\r</td>
<td><code>匹配一个回车符。等效于 \x0d 和 \cM。</code></td>
</tr>
<tr>
<td>\s</td>
<td><code>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</code></td>
</tr>
<tr>
<td>\S</td>
<td><code>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</code></td>
</tr>
<tr>
<td>\t</td>
<td><code>制表符匹配。与 \x09 和 \cI 等效。</code></td>
</tr>
<tr>
<td>\v</td>
<td><code>垂直制表符匹配。与 \x0b 和 \cK 等效。</code></td>
</tr>
<tr>
<td>\w</td>
<td><code>匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效。</code></td>
</tr>
<tr>
<td>\W</td>
<td><code>与任何非单词字符匹配。与&quot;[^A-Za-z0-9_]&quot;等效。</code></td>
</tr>
<tr>
<td>\xn</td>
<td><code>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，&quot;\x41&quot;匹配&quot;A&quot;。&quot;\x041&quot;与&quot;\x04&quot;&amp;&quot;1&quot;等效。允许在正则表达式中使用 ASCII 代码。</code></td>
</tr>
<tr>
<td>\num</td>
<td><code>匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，&quot;(.)\1&quot;匹配两个连续的相同字符。</code></td>
</tr>
<tr>
<td>\n</td>
<td><code>标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</code></td>
</tr>
<tr>
<td>\nm</td>
<td><code>标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</code></td>
</tr>
<tr>
<td>\nml</td>
<td><code>当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</code></td>
</tr>
<tr>
<td>\un</td>
<td><code>匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</code></td>
</tr>
</tbody>
</table>
<h2 id="26-方法"><a href="#26-方法" class="headerlink" title="26 方法"></a>26 方法</h2><ul>
<li><strong>方法是通过值传递参数</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPassByValue</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> num1 = <span class="number">1</span>;</div><div class="line">      <span class="keyword">int</span> num2 = <span class="number">2</span>;</div><div class="line"></div><div class="line">      System.out.println(<span class="string">"Before swap method, num1 is "</span> + num1 + <span class="string">" and num2 is "</span> + num2);</div><div class="line"></div><div class="line">      <span class="comment">// 调用swap方法</span></div><div class="line">      swap(num1, num2);</div><div class="line">      System.out.println(<span class="string">"After swap method, num1 is "</span> + num1 + <span class="string">" and num2 is "</span> + num2);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">/** 交换两个变量的方法 */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"\tInside the swap method"</span>);</div><div class="line">      System.out.println(<span class="string">"\t\tBefore swapping n1 is "</span> + n1 + <span class="string">" n2 is "</span> + n2);</div><div class="line">      <span class="comment">// 交换 n1 与 n2的值</span></div><div class="line">      <span class="keyword">int</span> temp = n1;</div><div class="line">      n1 = n2;</div><div class="line">      n2 = temp;</div><div class="line"></div><div class="line">      System.out.println(<span class="string">"\t\tAfter swapping n1 is "</span> + n1 + <span class="string">" n2 is "</span> + n2);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>结果如下：</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Before swap method, num1 is 1 and num2 is 2</div><div class="line">Inside the swap method</div><div class="line">Before swapping n1 is 1 n2 is 2</div><div class="line">After swapping n1 is 2 n2 is 1</div><div class="line">After swap method, num1 is 1 and num2 is 2</div></pre></td></tr></table></figure></p>
<h2 id="27-可变参数"><a href="#27-可变参数" class="headerlink" title="27 可变参数"></a>27 可变参数</h2><p>typeName… parameterName，必须放置在最后一个（即C#的param int arr）</p>
<h2 id="28-finalize方法（即C-的析构函数）"><a href="#28-finalize方法（即C-的析构函数）" class="headerlink" title="28 finalize方法（即C#的析构函数）"></a>28 finalize方法（即C#的析构函数）</h2><ul>
<li>在对象被垃圾收集器析构(回收)之前调用，它用来清除回收对象。</li>
<li>System.gc(); //调用Java垃圾收集器</li>
</ul>
<h2 id="29-流（java-io包）"><a href="#29-流（java-io包）" class="headerlink" title="29 流（java.io包）"></a>29 流（java.io包）</h2><p><img src="/images/posts/Java_Stream.jpg" alt="Stream"></p>
<h3 id="29-1-读取控制台输入"><a href="#29-1-读取控制台输入" class="headerlink" title="29.1 读取控制台输入"></a>29.1 读取控制台输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div></pre></td></tr></table></figure>
<h3 id="29-2-获取或设置JVM当前工作目录"><a href="#29-2-获取或设置JVM当前工作目录" class="headerlink" title="29.2 获取或设置JVM当前工作目录"></a>29.2 获取或设置JVM当前工作目录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.getProperty(<span class="string">"user.dir"</span>);</div><div class="line">System.setProperty(<span class="string">"user.dir"</span>, <span class="string">"C:\\myDir"</span>);</div></pre></td></tr></table></figure>
<h3 id="29-3-文件分隔符"><a href="#29-3-文件分隔符" class="headerlink" title="29.3 文件分隔符"></a>29.3 文件分隔符</h3><p>常量<strong>File.separator</strong>，用于解决Windows在路径名中使用反斜杠（\）作为名称分隔符，而UNIX使用正斜杠（/）的问题。</p>
<h2 id="30-Scan-java-util-SCanner"><a href="#30-Scan-java-util-SCanner" class="headerlink" title="30 Scan(java.util.SCanner)"></a>30 Scan(java.util.SCanner)</h2><p>主要用于获取用户的输入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</div></pre></td></tr></table></figure></p>
<h2 id="31-异常"><a href="#31-异常" class="headerlink" title="31 异常"></a>31 异常</h2><h3 id="31-1-异常类型"><a href="#31-1-异常类型" class="headerlink" title="31.1 异常类型"></a>31.1 异常类型</h3><ul>
<li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li>错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<h3 id="31-2-异常层次"><a href="#31-2-异常层次" class="headerlink" title="31.2 异常层次"></a>31.2 异常层次</h3><ul>
<li>所有的异常类是从java.lang.Exception类继承的子类。</li>
<li>Exception类是Throwable类的子类。除了Exception类外，Throwable还有一个子类Error 。</li>
</ul>
<p><img src="/images/posts/Java_Exception.jpg" alt="Exception"></p>
<h3 id="31-3-非检查性异常"><a href="#31-3-非检查性异常" class="headerlink" title="31.3 非检查性异常"></a>31.3 非检查性异常</h3><table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArithmeticException</td>
<td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundsException</td>
<td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td>
</tr>
<tr>
<td>ArrayStoreException</td>
<td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td>
</tr>
<tr>
<td>ClassCastException</td>
<td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td>
</tr>
<tr>
<td>IllegalMonitorStateException</td>
<td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td>
</tr>
<tr>
<td>IllegalThreadStateException</td>
<td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td>
</tr>
<tr>
<td>NegativeArraySizeException</td>
<td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</td>
</tr>
<tr>
<td>NumberFormatException</td>
<td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td>
</tr>
<tr>
<td>SecurityException</td>
<td>由安全管理器抛出的异常，指示存在安全侵犯。</td>
</tr>
<tr>
<td>StringIndexOutOfBoundsException</td>
<td>此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>当不支持请求的操作时，抛出该异常。</td>
</tr>
</tbody>
</table>
<h3 id="31-4-检查性异常类"><a href="#31-4-检查性异常类" class="headerlink" title="31.4 检查性异常类"></a>31.4 检查性异常类</h3><table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClassNotFoundException</td>
<td>应用程序试图加载类时，找不到相应的类，抛出该异常。</td>
</tr>
<tr>
<td>CloneNotSupportedException</td>
<td>当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</td>
</tr>
<tr>
<td>IllegalAccessException</td>
<td>拒绝访问一个类的时候，抛出该异常。</td>
</tr>
<tr>
<td>InstantiationException</td>
<td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td>
</tr>
<tr>
<td>InterruptedException</td>
<td>一个线程被另一个线程中断，抛出该异常。</td>
</tr>
<tr>
<td>NoSuchFieldException</td>
<td>请求的变量不存在</td>
</tr>
<tr>
<td>NoSuchMethodException</td>
<td>请求的方法不存在</td>
</tr>
</tbody>
</table>
<h3 id="31-5-throws-throw关键字"><a href="#31-5-throws-throw关键字" class="headerlink" title="31.5 throws/throw关键字"></a>31.5 throws/throw关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></div><div class="line"><span class="function">   </span>&#123;</div><div class="line">      <span class="comment">// Method implementation</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//Remainder of class definition</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="31-6-自定义异常"><a href="#31-6-自定义异常" class="headerlink" title="31.6 自定义异常"></a>31.6 自定义异常</h3><ul>
<li>所有异常都必须是Throwable的子类。</li>
<li>检查性异常：继承Exception类。</li>
<li>运行时异常：继承RuntimeException 类。</li>
</ul>
<h3 id="31-7-异常和错误"><a href="#31-7-异常和错误" class="headerlink" title="31.7 异常和错误"></a>31.7 异常和错误</h3><ul>
<li>JVM(Java虚拟机)异常：由JVM抛出的异常或错误。例如：NullPointerException类，ArrayIndexOutOfBoundsException类，ClassCastException类。</li>
<li>程序级异常：由程序或者API程序抛出的异常。例如IllegalArgumentException类，IllegalStateException类。</li>
</ul>
<h2 id="38-继承-is-a"><a href="#38-继承-is-a" class="headerlink" title="38 继承(is-a)"></a>38 继承(is-a)</h2><p>可用<code>a instanceof b</code>校验。 </p>
<ul>
<li>extends：继承类</li>
<li>implements：继承接口</li>
</ul>
<h2 id="39-重写（override）-amp-重载（overload）"><a href="#39-重写（override）-amp-重载（overload）" class="headerlink" title="39 重写（override）&amp;重载（overload）"></a>39 重写（override）&amp;重载（overload）</h2><table>
<thead>
<tr>
<th>区别点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody>
</table>
<h2 id="40-多态（is-a）"><a href="#40-多态（is-a）" class="headerlink" title="40 多态（is-a）"></a>40 多态（is-a）</h2><ul>
<li>同一个行为具有多个不同表现形式或形态的能力。</li>
<li>多态性是对象多种表现形式的体现。</li>
</ul>
<h2 id="41-接口（interface）"><a href="#41-接口（interface）" class="headerlink" title="41 接口（interface）"></a>41 接口（interface）</h2><ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。</li>
<li>接口中的方法都是公有的。</li>
<li>标识接口：没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</li>
</ul>
<h2 id="42-包"><a href="#42-包" class="headerlink" title="42 包"></a>42 包</h2><h3 id="42-1-package"><a href="#42-1-package" class="headerlink" title="42.1 package"></a>42.1 package</h3><ul>
<li>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。</li>
<li>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</li>
</ul>
<h3 id="42-2-import"><a href="#42-2-import" class="headerlink" title="42.2 import"></a>42.2 import</h3><ul>
<li>文件中可以包含任意数量的import声明。import声明必须在包声明之后，类声明之前。</li>
<li>静态导入<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="42-3-CLASSPATH"><a href="#42-3-CLASSPATH" class="headerlink" title="42.3 CLASSPATH"></a>42.3 CLASSPATH</h3><p>类目录的绝对路径叫做class path。设置在系统变量CLASSPATH中。编译器和java虚拟机通过将package名字加到class path后来构造.class文件的路径。<path- two="">\classes是class path，package名字是com.apple.computers,而编译器和JVM会在 <path-two>\classes\com\apple\compters中找.class文件。<br>一个class path可能会包含好几个路径。多路径应该用分隔符分开。默认情况下，编译器和JVM查找当前目录。JAR文件按包含Java平台相关的类，所以他们的目录默认放在了class path中。</path-two></path-></p>
<h2 id="43-Object"><a href="#43-Object" class="headerlink" title="43 Object"></a>43 Object</h2><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String toString()</td>
<td>它是实现在Object类中，我们可以自定义它。它返回对象的字符串表示形式。通常，它用于调试目的。</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>它在Object类中实现，我们可以自定义它。它用于比较两个对象的相等性。</td>
</tr>
<tr>
<td>public int hashCode()</td>
<td>它在Object类中实现，我们可以自定义它。它返回对象的哈希码（整数）值。</td>
</tr>
<tr>
<td>protected Object clone() throws CloneNotSupportedException</td>
<td>它不在Object类中实现，我们可以通过覆盖克隆方法来自定义它。它用于创建对象的副本。</td>
</tr>
<tr>
<td>protected void finalize() throws Throwable</td>
<td>它不是在Object类中实现，我们可以自定义它。它在对象被销毁之前被垃圾收集器调用。</td>
</tr>
<tr>
<td>public final Class getClass()</td>
<td>它在Object类中实现，我们不能自定义它。它返回对对象的Class对象的引用。</td>
</tr>
<tr>
<td>public final void notify()</td>
<td>它是在Object类中实现的，我们不能自定义它。此方法通知对象的等待队列中的一个线程。</td>
</tr>
<tr>
<td>public final void notifyAll()</td>
<td>它是在Object类中实现的，我们不能自定义它。此方法通知对象的等待队列中的所有线程。</td>
</tr>
<tr>
<td>public final void wait() throws InterruptedException<br>public final void wait(long timeout) throws InterruptedException<br>public final void wait (long timeout, int nanos) throws InterruptedException</td>
<td>它是在Object类中实现的，我们不能自定义它。使对象的等待队列中的线程等待，无论是否超时。</td>
</tr>
</tbody>
</table>
<h3 id="43-1-hashCode"><a href="#43-1-hashCode" class="headerlink" title="43.1 hashCode"></a>43.1 hashCode</h3><ul>
<li>如果两个对象使用equals()方法相等，则它们必须具有相同的哈希码。</li>
<li>如果x.hashCode()等于y.hashCode()，则x.equals(y)不必返回true。</li>
</ul>
<h3 id="43-2-equals"><a href="#43-2-equals" class="headerlink" title="43.2 equals"></a>43.2 equals</h3><p>这里是equals()方法的实现的规范。假设x，y和z是三个对象的非空引用。</p>
<ul>
<li>自反性。表达式x.equals(x)应该返回true。</li>
<li>对称性。如果x.equals(y)返回true，y.equals(x)必须返回true。</li>
<li>传递性。如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)必须返回true。</li>
<li>一致性。如果x.equals(y)返回true，它应该保持返回true，直到x或y的状态被修改。如果x.equals(y)返回false，它应该保持返回false，直到x或y的状态被修改。</li>
<li>与空引用的比较：任何类的对象不应等于空引用。表达式x.equals(null)应始终返回false。</li>
<li>与hashCode()方法的关系：如果x.equals(y)返回true，x.hashCode()必须返回与y.hashCode()相同的值。</li>
</ul>
<h3 id="43-3-toString"><a href="#43-3-toString" class="headerlink" title="43.3 toString"></a>43.3 toString</h3><p>当需要对象的字符串表示时，Java会自动调用toString()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"Hello"</span> + <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</div></pre></td></tr></table></figure></p>
<p>等同于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"Hello"</span> + <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>).toString();</div></pre></td></tr></table></figure></p>
<h3 id="43-4-clone（浅拷贝）"><a href="#43-4-clone（浅拷贝）" class="headerlink" title="43.4 clone（浅拷贝）"></a>43.4 clone（浅拷贝）</h3><p>Java不提供克隆(复制)对象的自动机制。克隆对象意味着逐位复制对象的内容。要支持克隆操作，请在类中实现clone()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">  MyClass copy = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    copy = (MyClass) <span class="keyword">super</span>.clone();</div><div class="line">  &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="43-5-finalize"><a href="#43-5-finalize" class="headerlink" title="43.5 finalize"></a>43.5 finalize</h3><p>finalize()方法将在类的对象销毁之前由垃圾回收器调用。</p>
<h3 id="Immutables-不可变"><a href="#Immutables-不可变" class="headerlink" title="Immutables(不可变)"></a>Immutables(不可变)</h3><p>在创建状态后无法更改其状态的对象称为不可变对象。一个对象不可变的类称为不可变类。不变的对象可以由程序的不同区域共享而不用担心其状态改变。不可变对象本质上是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">IntWrapper</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntWrapper</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="43-7-Objects类-实用程序类"><a href="#43-7-Objects类-实用程序类" class="headerlink" title="43.7 Objects类(实用程序类)"></a>43.7 Objects类(实用程序类)</h3><p>主要用于处理对象。由静态方法组成。 Objects类中的大多数方法都会优雅地处理空值。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int compare(T a, T b, Comparator c)</td>
<td>如果参数相同，则返回0，否则返回c.compare(a，b)。因此，如果两个参数都为null，则返回0。</td>
</tr>
<tr>
<td>boolean deepEquals(Object a, Object b)</td>
<td>检查两个对象是否相等。如果两个参数都相等，则返回true。否则，它返回false。如果两个参数都为null，则返回true。</td>
</tr>
<tr>
<td>boolean equals(Object a, Object b)</td>
<td>比较两个对象是否相等。如果两个参数相等，则返回true。否则，它返回false。如果两个参数都为null，则返回true。</td>
</tr>
<tr>
<td>int hash(Object… values)</td>
<td>为所有指定的对象生成哈希码。它可以用于计算对象的哈希码，该哈希码基于多个实例字段。</td>
</tr>
<tr>
<td>int hashCode(Object o)</td>
<td>返回指定对象的哈希码值。如果参数为null，则返回0。</td>
</tr>
<tr>
<td>boolean isNull(Object obj)</td>
<td>如果指定的对象为null，isNull()方法返回true。否则，它返回false。您还可以使用比较运算符==检查对象是否为null，例如，obj == null返回obj的true为null。</td>
</tr>
<tr>
<td>boolean nonNull(Object obj)</td>
<td>执行与isNull()方法相反的检查。</td>
</tr>
<tr>
<td>T requireNonNull(T obj)</td>
<td>检查参数是否为null。如果参数为null，它会抛出一个NullPointerException异常。此方法设计用于验证方法和构造函数的参数。</td>
</tr>
<tr>
<td>T requireNonNull(T obj, String message)</td>
<td>第二个版本可以指定当参数为null时抛出的NullPointerException的消息。</td>
</tr>
<tr>
<td>T requireNonNull(T obj, Supplier messageSupplier)</td>
<td>第三个版本的方法将一个Supplier作为第二个参数。</td>
</tr>
<tr>
<td>String toString(Object o)<br>String toString(Object o, String nullDefault)</td>
<td>如果参数为null，则toString()方法返回一个“null”字符串。对于非空参数，它返回通过调用参数的toString()方法返回的值。</td>
</tr>
</tbody>
</table>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CLR-21垃圾回收]]></title>
      <url>/2017/12/27/CLR-21%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<h2 id="1-访问资源步骤"><a href="#1-访问资源步骤" class="headerlink" title="1 访问资源步骤"></a>1 访问资源步骤</h2><ol>
<li>调用 IL 指令 newobj，为代表资源的类型分配内存（C# 一般使用 new）；</li>
<li>初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态；</li>
<li>访问类型的成员来使用资源（有必要可重复）；</li>
<li>摧毁资源的状态以便清理；</li>
<li>释放内存（垃圾回收）。<a id="more"></a>
</li>
</ol>
<h2 id="2-无GC存在的问题"><a href="#2-无GC存在的问题" class="headerlink" title="2 无GC存在的问题"></a>2 无GC存在的问题</h2><ul>
<li>忘记释放内存而造成的<strong>内存泄露</strong></li>
<li><strong>访问已释放的内存</strong>引起的 bug</li>
</ul>
<h2 id="3-托管堆分配资源"><a href="#3-托管堆分配资源" class="headerlink" title="3 托管堆分配资源"></a>3 托管堆分配资源</h2><p>CLR 要求所有<strong>对象</strong>都从<strong>托管堆</strong>分配，进程初始化时，CLR 划出一个地址空间区域作为托管堆，并维护一指针（NextOjbPtr），NextObjPtr 最初指向基地址，主要作用指向下一个对象在堆中的分配位置。一个区域被<strong>非垃圾对象</strong>填满后，CLR 会分配更多区域，重复直至整个进程地址空间填满，故应用程序的内存受进程的虚拟空间限制。32 位进程最多分配 1.5 GB，64 位进程为 8 TB。</p>
<h2 id="4-new-操作符"><a href="#4-new-操作符" class="headerlink" title="4 new 操作符"></a>4 new 操作符</h2><ol>
<li>计算类型的字段（及从基类型继承的字段）所需的字节数；</li>
<li>加上对象的开销所需字节数（每个对象 2 个开销字段：<strong>类型对象指针</strong>、<strong>同步块索引</strong>，32 位应用程序一个字段需要 32 位即 4 字节，64 位应用程序一个字段需要 64 位即 8 字节）；</li>
<li>CLR 检查区域中是否有分配对象所需的字节数，有则在 NextOjbPtr 指针指向的地址存放对象，为对象分配的字节会被清零。调用类型的构造器，new 操作符返回对象引用，并在此之前移动 NextOjbPtr 指针指向下一个对象存放的地址。无则先进行垃圾回收（第 0 代已满情况下），若还没空间分配则抛出 OutOfMemoryException。</li>
</ol>
<h2 id="5-垃圾回收算法"><a href="#5-垃圾回收算法" class="headerlink" title="5 垃圾回收算法"></a>5 垃圾回收算法</h2><h3 id="5-1-引用计数算法（未采用）"><a href="#5-1-引用计数算法（未采用）" class="headerlink" title="5.1 引用计数算法（未采用）"></a>5.1 引用计数算法（未采用）</h3><p>堆上每个对象都维护一个内存字段来统计程序中多少“部分”正在使用对象，若“部分”不再需要对象时，则计数递减，直至为零后可删除对象。<br><strong>存在的问题：</strong>循环引用导致对象永远不会删除。</p>
<h3 id="5-2-引用跟踪算法（CLR采用）"><a href="#5-2-引用跟踪算法（CLR采用）" class="headerlink" title="5.2 引用跟踪算法（CLR采用）"></a>5.2 引用跟踪算法（CLR采用）</h3><p>引用跟踪算法只计算引用类型的变量，因为只有这种变量（统称为根：类的静态字段、实例字段、方法参数、局部变量）才能引用堆上的对象，值类型直接包含值类型实例。</p>
<h2 id="6-GC流程"><a href="#6-GC流程" class="headerlink" title="6 GC流程"></a>6 GC流程</h2><ol>
<li>暂停所有线程，防止线程在 GC 检查期间访问对象并更改状态；</li>
<li>CLR 进入 GC 标记阶段：<br>2.1. CLR 遍历堆中的所有对象，并将同步块索引字段中的一位设为 0，表明所有对象都应删除；<br>2.2. CLR 检查所有活动根，查看它们引用了哪些对象，若为 null 则忽略继续检查下一个根；<br>2.3. 任何根若引用堆上对象，则标记那个对象（同步块索引中的一位设为1），若对象被标记，则检查对象的根，标记它们引用的对象，若对象已标记则不检查该对象字段，从而避免循环引用产生的死循环；</li>
<li>标记阶段结束后，堆中的对象要么已标记（可达 reachable），要么未标记（不可达 unreachable），开始进入 GC 的 压缩（compact，实际上应该称为碎片整理）阶段：<br>3.1. CLR 移动堆中已标记对象，使它们占用连续内存空间，恢复引用的“局部化”，减少应用程序工作集，从而提升性能。另外可用空间也是连续的，解决了空间碎片化问题。<strong>注意：</strong>大对象堆中的对象不会压缩，故还是可能发生地址空间碎片化。<br>3.2. CLR 从每个根减去引用对象在内存中便宜的字节数，保证每个根引用的还是之前的对象。</li>
<li>移动 NextObjPtr 指针指向最后一个幸存对象之后的位置，下一个分配的对象将放到这位置。</li>
<li>CLR 恢复应用程序的所有线程。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>静态字段引用的对象一直存在，直至用于加载类型的 AppDomain 卸载为止。</li>
<li>内存泄露一个常见原因就是静态字段引用了一个集合对象，然后不停向集合添加数据项，导致一直存活。</li>
<li><strong>尽量</strong>避免使用静态字段。</li>
</ul>
<h2 id="7-基于代的垃圾回收器（generational-garbage-collector）"><a href="#7-基于代的垃圾回收器（generational-garbage-collector）" class="headerlink" title="7 基于代的垃圾回收器（generational garbage collector）"></a>7 基于代的垃圾回收器（generational garbage collector）</h2><ul>
<li>对象越新，生存期越短。</li>
<li>对象越老，生存期越长。</li>
<li>回收堆的一部分，速度快于回收整个堆。</li>
</ul>
<p>托管堆只支持三代（System.GC.MaxGenerationa() 返回 2）：第 0 代、第 1 代和第 2 代。</p>
<p>详细见P454</p>
<h2 id="8-垃圾回收触发条件"><a href="#8-垃圾回收触发条件" class="headerlink" title="8 垃圾回收触发条件"></a>8 垃圾回收触发条件</h2><ul>
<li>CLR 检测第 0 代超过预算（最常见）；</li>
<li>代码显示调用 System.GC.Collect();</li>
<li>Windows 报告低内存情况；</li>
<li>CLR 正在卸载 AppDomain；</li>
<li>CLR 正在关闭（此时 CLR 不会试图压缩或释放内存，Windows 直接回收进程的全部内存）。</li>
</ul>
<h2 id="9-大对象"><a href="#9-大对象" class="headerlink" title="9 大对象"></a>9 大对象</h2><p>CLR 将对象分为大对象和小对象，目前认为 85000 字节或更大的对象为大对象。</p>
<ul>
<li>大对象不是在小对象的地址空间分配，而是在进程地址空间的其他地方分配；</li>
<li>目前版本的 GC 不压缩大对象，因为在内存中移动它们代价过高，故在进程中大对象之间造成地址空间的碎片化，可能抛出 OutOfMemoryException；</li>
<li>大对象总是第 2 代，绝不可能是第 0 代或第 1 代，所以只能为需要长时间存活的资源创建大对象，否则会频繁回收第 2 代，损害性能。</li>
</ul>
<h2 id="10-GC模式"><a href="#10-GC模式" class="headerlink" title="10 GC模式"></a>10 GC模式</h2><p>CLR 启动时会选择一个 GC 模式，进程终止前该模式不会改变。</p>
<ul>
<li><strong>工作站（默认）：</strong>该模式针对客户端应用程序优化GC。</li>
<li><strong>服务器：</strong>该模式针对服务器端应用程序优化 GC。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>若计算机为单处理器，则总是使用“工作站” GC 模式；</li>
</ul>
<p>除两种主要模式外，还支持两种子模式：并发（默认）或非并发。</p>
<h2 id="11-特殊清理（Finalize）"><a href="#11-特殊清理（Finalize）" class="headerlink" title="11 特殊清理（Finalize）"></a>11 特殊清理（Finalize）</h2><ul>
<li>包含本机资源（文件、网络连接、套接字、互斥体）的类型被 GC 时，GC 会回收对象在托管堆中使用的内存，但会造成本机资源的泄露，故 CLR 提供了终结（finalization）的机制，允许对象在被判定为垃圾之后，但在对象内存被回收之前执行一些代码。任何包装了本机资源（文件、网络连接、套接字、互斥体）的类型都支持终结。CLR 判定一个对象不可达时，对象将终结它自己，释放它包装的本机资源。之后，GC 会从托管堆回收对象。</li>
<li>Object基类定义了受保护的虚方法 Finalize，语法<strong>~ClassName</strong>。</li>
<li>Finalize 是为<strong>释放本机资源</strong>而设计的。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>被视为垃圾的对象在垃圾回收<strong>完毕</strong>后才调用 Finalize 方法，所以这些对象的内存不是马上被回收，造成它被提升为另一代，而这些对象引用的对象也会被提升，导致对象存活时间延长。故<strong>尽量</strong>避免为引用类型的字段定义可终结对象。</li>
<li>Finalize 方法执行时间不可控，且 GC 不保证多个 Finalize 的调用顺序，故在 Finalize 方法中不要访问其他定义了 Finalize 的类型对象。</li>
</ul>
<h2 id="12-dispose"><a href="#12-dispose" class="headerlink" title="12 dispose"></a>12 dispose</h2><ul>
<li>dispose 模式：实现了 IDisposable 接口即实现了 dispose 模式；</li>
<li>若类定义的一个字段的类型实现了 dispose 模式，则类本身也应实现。如果才能在类上调用 Dispose 来释放对象自身使用的资源。</li>
<li><strong>强烈建议</strong>将显式调用 Dispose 方法的代码放到 finally 块中或使用 using 语句块。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>CLR via C# 第21章</li>
</ul>
]]></content>
      
        <categories>
            
            <category> CLR </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C# </tag>
            
            <tag> CLR </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[收藏]]></title>
      <url>/2017/10/18/%E6%94%B6%E8%97%8F/</url>
      <content type="html"><![CDATA[<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><ul>
<li><a href="https://martinfowler.com/articles/injection.html" target="_blank" rel="external">Inversion of Control Containers and the Dependency Injection pattern by Martin Fowler</a></li>
<li><a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/" target="_blank" rel="external">Service Locator is an Anti-Pattern by Mark Seemann</a></li>
</ul>
<h2 id="前端网站"><a href="#前端网站" class="headerlink" title="前端网站"></a>前端网站</h2><ul>
<li><a href="https://modernizr.com/" target="_blank" rel="external">Modernizr</a></li>
<li><a href="https://caniuse.com/" target="_blank" rel="external">Can I Use</a></li>
<li><a href="https://www.w3.org/" target="_blank" rel="external">w3c</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">Mozilla开发者网络</a></li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li><a href="http://www.cnblogs.com/WeiGe/p/5658175.html" target="_blank" rel="external">QPS从0到4000请求每秒，谈达达后台架构演化之路</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 其他 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UML]]></title>
      <url>/2017/10/15/UML%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-UML介绍"><a href="#1-UML介绍" class="headerlink" title="1 UML介绍"></a>1 UML介绍</h2><p>UML(Unified Modeling Language)又称统一建模语言或标准建模语言，一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，包括由需求分析到规格，到构造和配置。 </p>
<a id="more"></a>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h2><ul>
<li>用例图（use case diagrams）：描述用户需求，从用户的角度描述系统的功能</li>
<li>静态图<ul>
<li>类图（class  diagrams）：显示系统的静态结构</li>
<li>对象图（object diagrams）</li>
</ul>
</li>
<li>交互图<ul>
<li>序列图：描述对象之间的交互顺序，着重体现对象间消息传递的时间顺序</li>
<li>协作图（Collaboration diagrams）：描述对象之间的合作关系，侧重对象之间的消息传递 </li>
</ul>
</li>
<li>行为图<ul>
<li>状态图（Statechart diagrams）：描述对象的所有状态以及事件发生而引起的状态之间的转移</li>
<li>活动图（Activity diagrams）：描述满足用例要求所要进行的活动以及活动时间的约束关系</li>
</ul>
</li>
<li>实现图  <ul>
<li>构件图（Component diagrams）：描述代码构件的物理结构以及各构件之间的依赖关系</li>
<li>部署图（Deployment diagrams）：系统中硬件的物理体系结构</li>
</ul>
</li>
</ul>
<h2 id="3-类图"><a href="#3-类图" class="headerlink" title="3 类图"></a>3 类图</h2><h3 id="3-1-类"><a href="#3-1-类" class="headerlink" title="3.1 类"></a>3.1 类</h3><p>1 类(Class)封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。<br>2 在系统中，每个类具有一定的职责，职责指的是类所担任的任务，即类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类一般只有一种职责，在定义类的时候，将类的职责分解成为类的属性和操作（即方法）。<br>3 类的属性即类的数据职责，类的操作即类的行为职责。</p>
<p><img src="/images/posts/UML1.jpg" alt="类的UML图示"></p>
<ul>
<li>类名，斜体表示抽象类</li>
<li>属性，表示方式：<code>可见性 名称:类型 [= 缺省值]</code>，可见性又分为 +（公有）、-（私有）、#（受保护），缺省值可选项。</li>
<li>操作：类的行为，即成员方法。表示方式：<code>可见性 名称(参数列表) [:返回类型]</code>，返回类型可选项。</li>
</ul>
<h3 id="3-2-接口"><a href="#3-2-接口" class="headerlink" title="3.2 接口"></a>3.2 接口</h3><p><img src="http://www.uml.org.cn/oobject/images/20121123113.jpg" alt="接口的UML图示"></p>
<h3 id="3-3-关系"><a href="#3-3-关系" class="headerlink" title="3.3 关系"></a>3.3 关系</h3><ul>
<li><strong>关联关系</strong>：表示一类对象与另一类对象之间有联系（如将一个类的对象作为另一个类的成员变量）<br><img src="http://www.uml.org.cn/oobject/images/2012112314.jpg" alt="关联关系"><ul>
<li><strong>双向关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112315.jpg" alt="双向关联"></li>
<li><strong>单向关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112316.jpg" alt="单项关联"></li>
<li><strong>自关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112317.jpg" alt="自关联"></li>
<li><strong>多重关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112318.jpg" alt="多重关联"><ul>
<li>1..1: 表示另一个类的一个对象只与该类的一个对象有关系</li>
<li>0..*：表示另一个类的一个对象与该类的零个或多个对象有关系</li>
<li>1..*：表示另一个类的一个对象与该类的一个或多个对象有关系</li>
<li>0..1：表示另一个类的一个对象没有或只与该类的一个对象有关系</li>
<li>m..n：表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n)</li>
</ul>
</li>
</ul>
</li>
<li><strong>聚合（Aggregation）关系</strong>：表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。<br><img src="http://www.uml.org.cn/oobject/images/2012112319.jpg" alt="聚合关系"></li>
<li><strong>组合（Composition）关系</strong>：也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123110.jpg" alt="组合关系"></li>
<li><strong>依赖（Dependency）关系</strong>：一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。用带箭头的虚线表示，由依赖的一方指向被依赖的一方。<br><img src="http://www.uml.org.cn/oobject/images/20121123111.jpg" alt="依赖关系"></li>
<li><strong>泛化（Generalization）关系</strong>：用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123112.jpg" alt="泛化关系"></li>
<li><strong>实现（Implementation）关系</strong>：是用来规定接口和实现接口的类或者构建结构的关系，接口是操作的集合，而这些操作就用于规定类或者构建的一种服务。接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系(Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123114.jpg" alt="实现关系"></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/3160571?fr=aladdin&amp;fromid=446747&amp;fromtitle=UML" target="_blank" rel="external">统一建模语音百科</a></li>
<li><a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="external">深入浅出UML类图</a></li>
<li><a href="http://blog.csdn.net/jiuqiyuliang/article/details/8552956/" target="_blank" rel="external">浅谈UML的概念和模型之UML九种图</a></li>
<li><a href="http://blog.csdn.net/fatherican/article/details/44966891" target="_blank" rel="external">UML的9种图例解析</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> UML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[缓存解决方案]]></title>
      <url>/2017/10/15/%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h2 id="1-NoSQL总览"><a href="#1-NoSQL总览" class="headerlink" title="1 NoSQL总览"></a>1 NoSQL总览</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>NoSQL（Not Only SQL）,意即“不仅仅是SQL”，非关系型的数据库</p>
<h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><ul>
<li>键值（key-value）存储数据库</li>
<li>列存储数据库</li>
<li>文档型数据库</li>
<li>图形（Graph)数据库</li>
</ul>
<a id="more"></a>
<h2 id="2-Memcached"><a href="#2-Memcached" class="headerlink" title="2 Memcached"></a>2 Memcached</h2><p>一个自由开源的，高性能，分布式内存对象缓存系统。</p>
<ul>
<li>类型：key-value 存储数据库</li>
<li>优点<ul>
<li>内存</li>
<li>多核，支持多线程操作</li>
</ul>
</li>
<li>缺点<ul>
<li>不支持持久化</li>
<li>本身不支持分布式，只能在客户端通过像一致性哈希类的分布式算法实现</li>
<li>单个 key-value 大小有限，一个value最大只支持 1MB</li>
</ul>
</li>
</ul>
<h2 id="3-Redis"><a href="#3-Redis" class="headerlink" title="3 Redis"></a>3 Redis</h2><p>一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。</p>
<ul>
<li>类型：key-value 存储数据库</li>
<li>优点<ul>
<li>内存</li>
<li>支持持久化（快照，AOF等）</li>
<li>支持服务器端分布式（主从复制方案）</li>
<li>支持多种数据结构</li>
<li>单个 key-value 大小有限，一个 value 最大只支持 512MB</li>
<li>支持pub/sub消息订阅机制</li>
</ul>
</li>
<li>缺点<ul>
<li>单核，不支持多核心多线程操作</li>
</ul>
</li>
</ul>
<h2 id="4-MongoDB"><a href="#4-MongoDB" class="headerlink" title="4 MongoDB"></a>4 MongoDB</h2><p>一个基于分布式文件存储的数据库,文档型的非关系型数据库，与上面两者不同。</p>
<ul>
<li>类型：文档存储数据库</li>
<li>优点<ul>
<li>支持持久化（binlog）</li>
</ul>
</li>
<li>缺点   <ul>
<li>不支持事务</li>
</ul>
</li>
</ul>
<h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5 应用场景"></a>5 应用场景</h2><p>需要根据使用的具体场景分析：</p>
<ul>
<li>需要数据持久化或主从复制，只能采用 Redis。</li>
<li>需要缓存的数据只是 key-value 这样简单的结构，采用 memcache；若涉及不同数据结构，排序等选用 Redis。</li>
</ul>
<h3 id="5-1-推荐"><a href="#5-1-推荐" class="headerlink" title="5.1 推荐"></a>5.1 推荐</h3><ul>
<li>Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息等）。</li>
<li>Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。</li>
<li>MongoDB:主要解决海量数据的访问效率问题。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cnblogs.com/EE-NovRain/p/3268476.html" target="_blank" rel="external">Redis和Memcache对比及选择</a></li>
<li><a href="http://www.cnblogs.com/EE-NovRain/p/3268465.html" target="_blank" rel="external">NoSQL发展简史、粗略分类及选择</a></li>
<li><a href="http://www.cnblogs.com/cac2020/category/906633.html" target="_blank" rel="external">分布式缓存学习之一：Memcached, Redis, MongoDB区别</a></li>
<li><a href="https://yq.aliyun.com/articles/38224" target="_blank" rel="external">Redis、Memcache和MongoDB的区别</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 架构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 解决方案 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[高并发网站解决方案]]></title>
      <url>/2017/10/15/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h2 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1 服务器"></a>1 服务器</h2><ul>
<li>使用高性能CPU主机</li>
<li>数据库使用物理机，避免虚拟机，提升IO性能</li>
<li>使用SSD磁盘，提升IO性能</li>
<li>提升带宽</li>
</ul>
<h2 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2 数据库"></a>2 数据库</h2><h3 id="2-1-读写分离"><a href="#2-1-读写分离" class="headerlink" title="2.1 读写分离"></a>2.1 读写分离</h3><p>主从同步，实时将主库的数据增量复制到从库，而且一个主库可以连接多个从库同步。</p>
<ul>
<li>减轻主库（写）压力</li>
<li>从库（读）可水平扩展（加从库机器）</li>
<li>避免主从同步延迟<ul>
<li>优化MySQL参数，比如增大<code>innodb_buffer_pool-size</code>，让更多操作在内存中完成，减少磁盘操作</li>
<li>硬件推荐的方案</li>
<li>业务代码优化，将实时性要求高的某些操作，使用主库做读操作</li>
</ul>
</li>
</ul>
<h3 id="2-2-垂直分库"><a href="#2-2-垂直分库" class="headerlink" title="2.2 垂直分库"></a>2.2 垂直分库</h3><p>按业务拆分成不同的业务数据库，每个系统仅访问对应业务的数据库，避免或减少跨库访问。</p>
<ul>
<li>禁用或少用<code>join</code>操作，应在程序中组装数据，让SQL更简单，一方面为以后进一步拆分业务做准备，另一方面也避免了 MySQL 中 join 的性能较低问题。</li>
</ul>
<h3 id="2-3-水平分库（sharding）"><a href="#2-3-水平分库（sharding）" class="headerlink" title="2.3 水平分库（sharding）"></a>2.3 水平分库（sharding）</h3><p>单表数据量过大影响读写性能，而又不能进一步垂直拆分时，考虑将数据按字段分类（如 ID，城市）拆分为多个表，即水平分库，拆分时需要考虑数据分布是否均匀、数据聚合度是否较高、冗余表等。</p>
<h2 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3 缓存"></a>3 缓存</h2><p><a href="">参见缓存解决方案</a></p>
<h2 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4 消息队列"></a>4 消息队列</h2><h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5 代码"></a>5 代码</h2><h3 id="5-1-异步编程（async-await）"><a href="#5-1-异步编程（async-await）" class="headerlink" title="5.1 异步编程（async/await）"></a>5.1 异步编程（async/await）</h3><h2 id="6-前端"><a href="#6-前端" class="headerlink" title="6 前端"></a>6 前端</h2><h3 id="6-1-HTML静态化"><a href="#6-1-HTML静态化" class="headerlink" title="6.1 HTML静态化"></a>6.1 HTML静态化</h3><h2 id="7-负载均衡、反向代理（nginx）"><a href="#7-负载均衡、反向代理（nginx）" class="headerlink" title="7 负载均衡、反向代理（nginx）"></a>7 负载均衡、反向代理（nginx）</h2><h2 id="8-内容分发网络（CDN）"><a href="#8-内容分发网络（CDN）" class="headerlink" title="8 内容分发网络（CDN）"></a>8 内容分发网络（CDN）</h2><p>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。</p>
<h2 id="9-分布式集群"><a href="#9-分布式集群" class="headerlink" title="9 分布式集群"></a>9 分布式集群</h2><ul>
<li>服务器按功能划分：Web服务器（集群）、数据库服务器（集群）、缓存服务器（集群）、附件服务器（集群）等。</li>
</ul>
<h2 id="10-镜像"><a href="#10-镜像" class="headerlink" title="10 镜像"></a>10 镜像</h2><p>CDN的实现分为三类：镜像、高速缓存、专线。</p>
<ul>
<li>镜像站点（Mirror Site），是最常见的，它让内容直接发布，适用于静态和准动态的数据同步。但是购买和维护新服务器的费用较高，还必须在各个地区设置镜像服务器，配备专业技术人员进行管理与维护。对于大型网站来说，更新所用的带宽成本也大大提高了。</li>
<li>高速缓存，成本较低，适用于静态内容。Internet的统计表明，超过80%的用户经常访问的是20%的网站的内容，在这个规律下，缓存服务器可以处理大部分客户的静态请求，而原始的服务器只需处理约20%左右的非缓存请求和动态请求，于是大大加快了客户请求的响应时间，并降低了原始服务器的负载。　　CDN服务一般会在全国范围内的关键节点上放置缓存服务器。</li>
<li>专线，让用户直接访问数据源，可以实现数据的动态同步。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>二八定律：80%的业务访问集中在20%的数据上。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/WeiGe/p/5658175.html" target="_blank" rel="external">QPS从0到4000请求每秒，谈达达后台架构演化之路</a></li>
<li><a href="http://blog.csdn.net/y_h_t/article/details/6322823" target="_blank" rel="external">高并发量网站解决方案</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 架构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线程笔记]]></title>
      <url>/2017/10/13/%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h2><h3 id="1-1-进程-amp-线程"><a href="#1-1-进程-amp-线程" class="headerlink" title="1.1 进程&amp;线程"></a>1.1 进程&amp;线程</h3><ul>
<li><strong>进程</strong>：应用程序的实例要使用的资源的集合。<ul>
<li>每个进程都被赋予一个虚拟地址空间，确保进程中的数据和代码无法由另一个进程访问，确保了应用程序实例的健壮性；</li>
<li>进程无法访问OS内核代码，保证系统稳定性和安全性。</li>
</ul>
</li>
<li>线程<a id="more"></a>
</li>
</ul>
<h3 id="1-2-垃圾回收背后的线程情况"><a href="#1-2-垃圾回收背后的线程情况" class="headerlink" title="1.2 垃圾回收背后的线程情况"></a>1.2 垃圾回收背后的线程情况</h3><p>执行垃圾回收时，CLR 必须挂起（暂停）所有线程，遍历它们的栈来查找根以便对堆中的对象进行标记，再次遍历它们的栈（有的对象在压缩期间发生了移动，所以要更新它们的根），再恢复所有的线程。所以，较少线程的数量会显著提升垃圾回收的性能。</p>
<h3 id="1-3-调试背后的线程情况"><a href="#1-3-调试背后的线程情况" class="headerlink" title="1.3 调试背后的线程情况"></a>1.3 调试背后的线程情况</h3><p>每次使用调试器并遇到断电，Windows 都会挂起正在调试的应用程序中的所有线程，并在单步执行或者运行应用程序后恢复所有线程。所以，线程越多，调试体验越差。</p>
<h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><h2 id="2-深入"><a href="#2-深入" class="headerlink" title="2 深入"></a>2 深入</h2><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="2-1-要构建高性能应用程序和组件，就应该尽量避免上下文切换；"><a href="#2-1-要构建高性能应用程序和组件，就应该尽量避免上下文切换；" class="headerlink" title="2.1 要构建高性能应用程序和组件，就应该尽量避免上下文切换；"></a>2.1 要构建高性能应用程序和组件，就应该尽量避免上下文切换；</h3><h3 id="2-2-应尽量使用线程池来执行异步操作；"><a href="#2-2-应尽量使用线程池来执行异步操作；" class="headerlink" title="2.2 应尽量使用线程池来执行异步操作；"></a>2.2 应尽量使用线程池来执行异步操作；</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
        <categories>
            
            <category> ASP.NET </category>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C# </tag>
            
            <tag> APS.NET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试]]></title>
      <url>/2017/10/10/%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="1-C-和-NET"><a href="#1-C-和-NET" class="headerlink" title="1. C#和.NET"></a>1. C#和.NET</h2><h3 id="1-1-C-基础知识"><a href="#1-1-C-基础知识" class="headerlink" title="1.1 C#基础知识"></a>1.1 C#基础知识</h3><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><ul>
<li>private【Private】 私有（定义类型、嵌套类型）</li>
<li>protected【Family】 保护（定义类型、嵌套类型、不同程序集中的派生类型）</li>
<li>C#不支持【Family and Assembly】（定义类型、嵌套类型、同一程序集中的派生类型）</li>
<li>internal【Assembly】 内部（同一程序集中的所有类型）</li>
<li>protected internal【Family or Assembly】（定义类型、嵌套类型、同一程序集中的所有类型，不同程序集中的派生类型）</li>
<li>public【Public】 公有</li>
</ul>
<p><em>PS：</em></p>
<ul>
<li>【】中为CLR术语。</li>
<li><code>C#</code>派生类型重写基类型定义的成员，<code>C#编译器</code>要求两者具有相同可访问性，<code>CLR</code>允许放宽但不允许收紧成员的可访问性。</li>
</ul>
<a id="more"></a>
<h4 id="值类型、引用类型"><a href="#值类型、引用类型" class="headerlink" title="值类型、引用类型"></a>值类型、引用类型</h4><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>1 总是从<code>托管堆</code>分配，new 操作符返回指向对象的内存地址；<br>2 堆上分配的每个对象都有一些额外成员（类型对象指针、同步块索引），这些成员必须初始化；<br>3 对象中的其他字节（为字段而设）总是设为零；<br>4 从托管堆分配对象时，可能强制执行一次垃圾回收。</p>
<h5 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h5><p>1 <code>一般</code>在<code>线程栈</code>上分配；<br>2 优点：缓解托管堆的压力，减少应用程序生存期内的垃圾回收次数；<br>3 所有值类型必须从 System.ValueType 派生；<br>4 值类型可以实现一个或多个接口；<br>5 所有值类型隐式密封；</p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li>值类型对象两种表示形式：未装箱和已装箱，引用类型总是已装箱</li>
<li>值类型从 System.ValueType 派生，该类型重写了 Equals 方法，能在两对象的字段值完全匹配返回 true，也重写了 GetHashCode 方法，算法会将实例字段的值计算进去。<em>由于默认实现存在性能问题，故定义值类型需重写。</em></li>
<li>值类型隐式密封，故不应引入任何虚方法，且所有方法不能时抽象方法，所有方法都隐式密封。</li>
<li>引用类型包含堆中对象的地址，默认初始化为 null，值类型总是包含基础类型的一个值，默认初始化为 0。</li>
<li>值类型赋给另一个值类型变量，会执行逐字段复制，引用类型则只复制内存地址，故对值类型变量执行操作不会影响另一个值类型，引用类型则不同。</li>
<li>由于未装箱的值类型不在堆上分配，一旦定义了该类型的实例的方法不再活动，分配的存储就会释放，而不等垃圾回收。</li>
</ul>
<h5 id="值类型设计前提："><a href="#值类型设计前提：" class="headerlink" title="值类型设计前提："></a>值类型设计前提：</h5><ul>
<li>类型具有基元类型的行为，没有成员会改变类型的任何实例字段。即不可变（immutable），建议将全部字段标记为 readonly。</li>
<li>类型不需要从其他类型继承。</li>
<li>类型也不派生其他任何类型。</li>
<li>类型的实例较小（16字节或更小）。</li>
<li>类型的实例较大（大于16字节），但不作为方法实参传递，也不作为返回参数。</li>
</ul>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul>
<li><a href="http://www.cnblogs.com/venux/p/6307561.html" target="_blank" rel="external">个人笔记</a></li>
</ul>
<h4 id="委托、事件"><a href="#委托、事件" class="headerlink" title="委托、事件"></a>委托、事件</h4><h4 id="重载、重写"><a href="#重载、重写" class="headerlink" title="重载、重写"></a>重载、重写</h4><h4 id="接口、抽象类"><a href="#接口、抽象类" class="headerlink" title="接口、抽象类"></a>接口、抽象类</h4><h4 id="out和ref"><a href="#out和ref" class="headerlink" title="out和ref"></a>out和ref</h4><h4 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h4><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><ul>
<li>Equals:如果两个<code>对象</code>具有相同值，就返回true。<ul>
<li>对象相等性和同一性</li>
</ul>
</li>
<li>GetHashCode:若对象要在哈希表集合（如Dictionary）中作为键，则应重写该方法。<ul>
<li>良好分布：指针对所有输入，GetHashCode生成的哈希值应该在所有整数中产生一个随机的分布。</li>
</ul>
</li>
<li>ToString:默认返回类型的完整名称（this.GetType().FullName）。</li>
<li>GetType:返回类型的一个实例。<ul>
<li>非虚方法，防止类重写，隐瞒类型，从而破坏类型安全性。</li>
</ul>
</li>
<li><a href="https://msdn.microsoft.com/en-us/library/system.object.memberwiseclone(v=vs.110" target="_blank" rel="external">MemberwiseClone</a>.aspx):浅拷贝。<ul>
<li>protected</li>
<li>非虚方法</li>
<li>The MemberwiseClone method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object. If a field is a <code>value</code> type, <code>a bit-by-bit copy of the field is performed</code>. If a field is a <code>reference</code> type, <code>the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object</code>.（意即：obj和cloneObj对应的值类型不会同时改变；引用类型同时改变）。    </li>
</ul>
</li>
<li>Finalize:垃圾回收之前调用该<code>虚</code>方法，可重写进行对象清理工作。</li>
</ul>
<h4 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h4><p>1 计算类型及其所有基类型（直到Object）中定义的所有<code>实例字段</code>需要的字节数，堆上每个对象都需要一些额外的成员（overhead成员、开销成员），包括<code>类型对象指针type object pointer</code>和<code>同步块索引sync block index</code>，CLR利用这些成员管理对象，额外成员的字节数需要计入对象大小。</p>
<p>2 从<code>托管堆</code>分配类型要求的字节数，从而分配对象的内存，所有字节设为零。</p>
<p>3 初始化对象的类型对象指针和同步块索引。</p>
<p>4 调用类型的实例构造器，传递实参，编译器自动生成代码调用基类构造器，并负责初始化定义的实例字段，最终调用Object的构造器，返回。</p>
<p>5 返回指向新建对象的一个引用（指针）。</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol>
<li>C#运行类型定义转换操作符方法，但只有使用转型表达式才调用，使用<code>as</code>或<code>is</code>永不调用它们。</li>
</ol>
<h4 id="类型、对象、线程栈、托管堆在运行时的相互关系"><a href="#类型、对象、线程栈、托管堆在运行时的相互关系" class="headerlink" title="类型、对象、线程栈、托管堆在运行时的相互关系"></a>类型、对象、线程栈、托管堆在运行时的相互关系</h4><p>CLR via C# 4.4 P90</p>
<h4 id="字段和属性有什么区别"><a href="#字段和属性有什么区别" class="headerlink" title="字段和属性有什么区别"></a>字段和属性有什么区别</h4><ul>
<li><p>答一：两者都是类的成员。不同的是：<br>  1 字段是数据成员，属性是方法成员;<br>  2 访问上对于属性访问需要使用访问元get,set，字段没有访问元直接赋值或者取值;<br>  3 属性能override，visual字段不能。</p>
</li>
<li><p>答二：如果你编写一些控件给别的开发者用，而需要给他们提供“数据绑定”这种傻瓜化的机制，那么使用属性才可以做到。<br>属性是方法而字段不是，当你用反射去掉用的时候，它们有各自的API。因为属性是方法，所以它可以和方法那样定义在接口中，或者被继承和重写，重写属性被ORM/AOP等框架用来注入代码。</p>
</li>
</ul>
<h4 id="抽象方法，和虚方法的区别"><a href="#抽象方法，和虚方法的区别" class="headerlink" title="抽象方法，和虚方法的区别"></a>抽象方法，和虚方法的区别</h4><ul>
<li>抽象方法一定是虚方法，虚方法未必是抽象方法。</li>
<li>虚方法是指可以被继承类重写的方法，而抽象方法是指，基类是抽象类，没有实现它，因此必须被继承类重写的方法。</li>
</ul>
<h4 id="new的几种用法"><a href="#new的几种用法" class="headerlink" title="new的几种用法"></a>new的几种用法</h4><ul>
<li>创建对象或者结构（只是用于调用结构构造函数）；</li>
<li>隐藏基类成员；</li>
<li>泛型里用于约束</li>
</ul>
<h4 id="什么叫做泛型"><a href="#什么叫做泛型" class="headerlink" title="什么叫做泛型"></a>什么叫做泛型</h4><ul>
<li>从编程的角度说是在定义类或者方法的时候省去具体的类型，由调用者来指定，类型+泛型类型合成得到真正的类型。</li>
<li>从实现机制上说，泛型是CLR在运行时动态根据泛型类型创建的匿名类型。</li>
<li>从OO设计的角度说，泛型体现了多态性。</li>
<li>泛型使得程序员可以复用数据结构和算法，并且适应不同的类型，享有编译期间的强类型检查和语法提示。<br>  一些经典的FCL提供的泛型类型和接口,List<t>、Dictionary<t1, t2="">这个属于复用数据结构,IComparer<t>、IEnumerable<t>这个属于复用算法</t></t></t1,></t></li>
</ul>
<h4 id="什么叫做类"><a href="#什么叫做类" class="headerlink" title="什么叫做类"></a>什么叫做类</h4><p>就C#而言，类是对象的模板，对象是类的实例。C#是强类型语言，一切皆需要类型，除了内置的简单类型，那些其实例为引用对象的都叫做类。C#也允许定义抽象类和密封类，以及两者的叠加——静态类，它们都无法实例化，其实这是编译器的限制，本质上它们和一般的类没有区别，是特殊情况。</p>
<h4 id="EF的理解"><a href="#EF的理解" class="headerlink" title="EF的理解"></a>EF的理解</h4><ul>
<li>对象关系映射（ORM）机制和LINQ To EF Provider，在此基础上的缓存机制、延迟加载、对象状态跟踪、事务等等。</li>
<li>EF是微软官方的ORM框架，结束了之前各种第三方ORM混战的局面，统一了API，这无疑是开发者的福音。EF拥有非常优雅的，基于C#/VB语言优化的API，比如原生的LINQ查询，自然的Code First的对数据结构的定义，Fluent API方式的数据库和关系的定义等等。VS完美支持EF并且提供了多种数据库的适配。</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>开发调试时打开编译器的/checked+开关，虽然会慢点，但能轻松进行溢出检查，及时修正BUG。正式发布时使用/checked-开关。</li>
<li>System.Decimal是<code>非常特殊</code>的类型，虽然C#视其为基元类型，但CLR不然。内部提供各种计算方法和操作符重载，故处理速度慢于CLR基元类型。</li>
</ul>
<h3 id="1-2-ASP-NET"><a href="#1-2-ASP-NET" class="headerlink" title="1.2 ASP.NET"></a>1.2 ASP.NET</h3><h4 id="页面传值"><a href="#页面传值" class="headerlink" title="页面传值"></a>页面传值</h4><ul>
<li><a href="http://www.cnblogs.com/zhangkai2237/archive/2012/05/06/2486462.html" target="_blank" rel="external">参考1</a></li>
</ul>
<h4 id="ASP-NET服务器控件的生命周期"><a href="#ASP-NET服务器控件的生命周期" class="headerlink" title="ASP.NET服务器控件的生命周期"></a>ASP.NET服务器控件的生命周期</h4><ul>
<li><a href="http://www.cnblogs.com/waters/articles/3373013.html" target="_blank" rel="external">参考1</a></li>
<li><a href="http://www.cnblogs.com/peterYong/p/6556597.html" target="_blank" rel="external">参考2</a></li>
</ul>
<h4 id="ASP-NET七个内置对象"><a href="#ASP-NET七个内置对象" class="headerlink" title="ASP.NET七个内置对象"></a>ASP.NET七个内置对象</h4><h3 id="1-3-名词解释"><a href="#1-3-名词解释" class="headerlink" title="1.3 名词解释"></a>1.3 名词解释</h3><ul>
<li>FCL(Framework Class Library)框架类库</li>
<li>CLS(Common Language Stander)</li>
<li>CLR(Common Language Runtime)公共语言运行时</li>
<li>IDL(Interface Definition Language)接口定义语言</li>
<li>IL(Intermediate Language)中间语言</li>
</ul>
<h3 id="1-4-IL"><a href="#1-4-IL" class="headerlink" title="1.4 IL"></a>1.4 IL</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li>add：两值相加，不执行溢出检查</li>
<li>add.ovf：两值相加，执行溢出检查，抛出System.OverflowException</li>
<li>sub：减</li>
<li>sub.ovf</li>
<li>mul：乘</li>
<li>mul.ovf</li>
<li>conv：转换</li>
<li>conv.ovf</li>
</ul>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li>CLR via C#(第4版)</li>
<li><a href="http://bbs.csdn.net/topics/390919248" target="_blank" rel="external">文章一</a></li>
</ul>
<h2 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2.数据库"></a>2.数据库</h2><h3 id="2-1-基础"><a href="#2-1-基础" class="headerlink" title="2.1 基础"></a>2.1 基础</h3><ul>
<li>Table1含有字段Col1，Col2，Col3，请用一条标准SQL选出Col2重复条数&gt;=2的所有记录。<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">    <span class="keyword">COUNT</span>(<span class="number">1</span>)</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    Table1</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></div><div class="line">    Col2</div><div class="line"><span class="keyword">HAVING</span></div><div class="line">    <span class="keyword">COUNT</span>(COL2) &gt;= <span class="number">2</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-SQL性能优化"><a href="#2-2-SQL性能优化" class="headerlink" title="2.2 SQL性能优化"></a>2.2 SQL性能优化</h3><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><h2 id="3-数据结构和算法"><a href="#3-数据结构和算法" class="headerlink" title="3. 数据结构和算法"></a>3. 数据结构和算法</h2><h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><h3 id="3-2-算法"><a href="#3-2-算法" class="headerlink" title="3.2 算法"></a>3.2 算法</h3><h4 id="3-2-1-冒泡排序"><a href="#3-2-1-冒泡排序" class="headerlink" title="3.2.1 冒泡排序"></a>3.2.1 冒泡排序</h4><h4 id="3-2-2-快速排序"><a href="#3-2-2-快速排序" class="headerlink" title="3.2.2 快速排序"></a>3.2.2 快速排序</h4><h4 id="3-2-3-冒泡排序"><a href="#3-2-3-冒泡排序" class="headerlink" title="3.2.3 冒泡排序"></a>3.2.3 冒泡排序</h4><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://github.com/aalhour/C-Sharp-Algorithms" target="_blank" rel="external">https://github.com/aalhour/C-Sharp-Algorithms</a></p>
<h2 id="4-编程思想"><a href="#4-编程思想" class="headerlink" title="4. 编程思想"></a>4. 编程思想</h2><h3 id="4-1-原则"><a href="#4-1-原则" class="headerlink" title="4.1 原则"></a>4.1 原则</h3><ul>
<li>SOLID</li>
</ul>
<h3 id="4-2-设计模式"><a href="#4-2-设计模式" class="headerlink" title="4.2 设计模式"></a>4.2 设计模式</h3><h3 id="4-3-MVC"><a href="#4-3-MVC" class="headerlink" title="4.3 MVC"></a>4.3 MVC</h3><h3 id="4-4-DDD"><a href="#4-4-DDD" class="headerlink" title="4.4 DDD"></a>4.4 DDD</h3><h2 id="5-前端"><a href="#5-前端" class="headerlink" title="5. 前端"></a>5. 前端</h2><h3 id="5-1-JavaScript"><a href="#5-1-JavaScript" class="headerlink" title="5.1 JavaScript"></a>5.1 JavaScript</h3><h3 id="5-2-JQuery"><a href="#5-2-JQuery" class="headerlink" title="5.2 JQuery"></a>5.2 JQuery</h3><h3 id="5-3-性能优化"><a href="#5-3-性能优化" class="headerlink" title="5.3 性能优化"></a>5.3 性能优化</h3><h3 id="5-4-其他"><a href="#5-4-其他" class="headerlink" title="5.4 其他"></a>5.4 其他</h3><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><h3 id="6-1-新技术"><a href="#6-1-新技术" class="headerlink" title="6.1 新技术"></a>6.1 新技术</h3><h3 id="6-2-职业规划"><a href="#6-2-职业规划" class="headerlink" title="6.2 职业规划"></a>6.2 职业规划</h3>]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaEEE开发环境搭建]]></title>
      <url>/2017/09/18/JavaEE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="1-Java环境"><a href="#1-Java环境" class="headerlink" title="1.Java环境"></a>1.Java环境</h2><h3 id="1-1-Java下载"><a href="#1-1-Java下载" class="headerlink" title="1.1 Java下载"></a>1.1 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">Java下载</a></h3><h3 id="1-2-环境变量配置"><a href="#1-2-环境变量配置" class="headerlink" title="1.2 环境变量配置"></a>1.2 环境变量配置</h3><ol>
<li><strong>JAVA_HOME</strong>:C:\Program Files\Java\jdk1.8.0_144（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%JAVA_HOME%\bin;</li>
<li><strong>CLASS_PATH</strong>:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</li>
</ol>
<h3 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h3><ul>
<li><strong>java-version</strong>:版本号</li>
<li><strong>java</strong>:Java环境</li>
<li><strong>javac</strong>:Java编译器</li>
</ul>
<h3 id="1-4-Eclipse集成"><a href="#1-4-Eclipse集成" class="headerlink" title="1.4 Eclipse集成"></a>1.4 Eclipse集成</h3><ul>
<li><strong>默认</strong>：Eclipse 会自动关联环境变量中配置的 JDK。</li>
<li><strong>手动</strong>：“Window”–“Preferences”–“Java”–“Installed JREs”–“Add”–“Standard VM”–选择jdk安装目录。 （多个版本的JDK手工进行配置）</li>
</ul>
<a id="more"></a>
<h2 id="2-Tomcat服务器"><a href="#2-Tomcat服务器" class="headerlink" title="2.Tomcat服务器"></a>2.Tomcat服务器</h2><h3 id="2-1-Tomcat下载"><a href="#2-1-Tomcat下载" class="headerlink" title="2.1 Tomcat下载"></a>2.1 <a href="http://tomcat.apache.org/download-90.cgi" target="_blank" rel="external">Tomcat下载</a></h3><h3 id="2-2-环境变量配置"><a href="#2-2-环境变量配置" class="headerlink" title="2.2 环境变量配置"></a>2.2 环境变量配置</h3><ol>
<li><strong>CATALINA_HOME</strong>：C:\Program Files\Tomcat 8.5（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%CATALINA_HOME%\bin;</li>
</ol>
<h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h3><ul>
<li><strong>localhost:8080</strong>:Tomcat默认主页</li>
</ul>
<h3 id="2-4-Eclipse集成"><a href="#2-4-Eclipse集成" class="headerlink" title="2.4 Eclipse集成"></a>2.4 Eclipse集成</h3><ul>
<li>“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。</li>
</ul>
<h2 id="3-Eclipse-IDE"><a href="#3-Eclipse-IDE" class="headerlink" title="3.Eclipse IDE"></a>3.Eclipse IDE</h2><h3 id="3-1-Eclipse下载"><a href="#3-1-Eclipse下载" class="headerlink" title="3.1 Eclipse下载"></a>3.1 <a href="https://www.eclipse.org/downloads/" target="_blank" rel="external">Eclipse下载</a></h3><h2 id="4-Maven"><a href="#4-Maven" class="headerlink" title="4.Maven"></a>4.Maven</h2><p>基于项目对象模型POM（Project Object Model），用来管理项目的构建、报告和文档的软件项目管理工具。主要提供：</p>
<ul>
<li>统一开发规范和工具</li>
<li>统一管理 jar 包</li>
</ul>
<h3 id="4-1-Maven下载"><a href="#4-1-Maven下载" class="headerlink" title="4.1 Maven下载"></a>4.1 <a href="http://maven.apache.org/download.cgi" target="_blank" rel="external">Maven下载</a></h3><h3 id="4-2-环境变量配置"><a href="#4-2-环境变量配置" class="headerlink" title="4.2 环境变量配置"></a>4.2 环境变量配置</h3><ol>
<li><strong>MAVEN_HOME</strong>:C:\Program Files\apache-maven-3.5.0（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%MAVEN_HOME%\lib;</li>
<li><strong>MAVEN_OPTS</strong>: -Xms128m -Xmx512m;(设置Maven可用内存大小)</li>
</ol>
<h3 id="4-3-测试"><a href="#4-3-测试" class="headerlink" title="4.3 测试"></a>4.3 测试</h3><ul>
<li><strong>maven -v</strong>:版本号</li>
</ul>
<h3 id="4-4-配置文件"><a href="#4-4-配置文件" class="headerlink" title="4.4 配置文件"></a>4.4 配置文件</h3><p><code>‪C:\Program Files\apache-maven-3.5.0\conf\settings.xml</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1 <a href="http://maven.apache.org/index.html" target="_blank" rel="external">Maven官网</a><br>2 <a href="http://blog.csdn.net/column/details/maven-it.html" target="_blank" rel="external">Maven入门</a><br>3 <a href="http://blog.csdn.net/lfsfxy9/article/details/9397937" target="_blank" rel="external">Eclipse Maven插件安装</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
            <tag> Eclipse </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-09.DECORATOR（装饰）— 对象结构型模式]]></title>
      <url>/2017/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-09%E8%A3%85%E9%A5%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>动态地给一个对象添加一些额外的职责。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>包装器 Wrapper</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>希望给某个对象而不是整个类添加一些功能。如图形界面添加一些特性（边框，滚动等）。</p>
<ul>
<li>使用继承机制是以一种有效途径，然而不够灵活；</li>
<li>将组件嵌入另一个对象，有这个对象添加特性，该嵌入的对象称为装饰。该装饰与所装饰的组件接口一致，故对其透明。</li>
</ul>
<p><img src="/images/posts/装饰1.png" alt="图一"><br><img src="/images/posts/装饰2.png" alt="图二"><br><a id="more"></a></p>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>处理那些可以撤消的职责。</li>
<li>当不能采用生成子类的方法进行扩充时。<ul>
<li>一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。</li>
<li>另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li>
</ul>
</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/装饰3.png" alt="图三"></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul>
<li>Component(VisualComponent)<ul>
<li>定义一个对象接口，可以给这些对象动态地添加职责。</li>
</ul>
</li>
<li>ConcreteComponent(TextView)<ul>
<li>定义一个对象，可以给这个对象添加一些职责。</li>
</ul>
</li>
<li>Decorator<ul>
<li>维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。</li>
</ul>
</li>
<li>ConcreteDecorator(BorderDecorator,ScrollDecorator)<ul>
<li>向组件添加职责。</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>Decorator 将请求转发给它的 Component 对象，并有可能在转发请求前后执行一些附加的<br>动作。</p>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul>
<li>优点：<ul>
<li>比静态继承更灵活</li>
<li>避免在层次结构高层的类有太多的特征</li>
</ul>
</li>
<li>缺点：<ul>
<li>Decorator 与 Component 不同，故使用 Decorator 不应该依赖 Component</li>
<li>有许多小对象</li>
</ul>
</li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul>
<li>接口的一致性；</li>
<li>省略抽象的 Decorator 类，仅需要一个职责时；</li>
<li>保存 Component 类的简单性；</li>
<li>改变对象外壳（Strategy 策略模式可改变对象内核）</li>
</ul>
<p><code>注：</code>当 Component 类原本很庞大时，使用 Decorator 模式代价太大，可考虑使用 Strategy 模式。<br><img src="/images/posts/装饰5.png" alt="图五"></p>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul>
<li><p>Component</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Component</div><div class="line">&#123;</div><div class="line">    public abstract void Operation();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ConcreteComponent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class ConcreteComponent:Component</div><div class="line">&#123;</div><div class="line">    public override void Operation()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;ConcreteComponent&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>BaseDecorator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class BaseDecorator:Component</div><div class="line">&#123;</div><div class="line">    private Component component;</div><div class="line"></div><div class="line">    public BaseDecorator(Component component)</div><div class="line">    &#123;</div><div class="line">        this.component = component;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Operation()</div><div class="line">    &#123;       </div><div class="line">        if(component!=null)</div><div class="line">        &#123;</div><div class="line">            component.Operation();</div><div class="line">        &#125;       </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ConcreteDecorator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class ConcreteDecorator:BaseDecorator</div><div class="line">&#123;</div><div class="line">    public ConcreteDecorator(Component component)</div><div class="line">        ：base(component)</div><div class="line">    &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Operation()</div><div class="line">    &#123;       </div><div class="line">        base.Operation();</div><div class="line">        this.Draw();</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    private void Draw()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;ConcreteDecorator&quot;);        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Client</div><div class="line">&#123;</div><div class="line">    public static void Main(string[] args)</div><div class="line">    &#123;</div><div class="line">        Component component=new ConcreteComponent();</div><div class="line">        component.Operation();</div><div class="line"></div><div class="line">        BaseDecorator decorator=new ConcreteDecorator(component);</div><div class="line">        decorator.Operation();</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>用户界面工具，Stream。<br><img src="/images/posts/装饰4.png" alt="图四"></p>
<h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul>
<li><strong>Adapter 模式：</strong>Decorator 模式不同于 Adapter 模式，因为装饰仅改变对象的职责而不改<br>变它的接口；而适配器将给对象一个全新的接口。</li>
<li><strong>Composite 模式：</strong>可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅<br>给对象添加一些额外的职责—它的目的不在于对象聚集。</li>
<li><strong>Strategy 模式：</strong>用一个装饰你可以改变对象的外表；而Strategy模式使得你可以改变<br>对象的内核。这是改变对象的两种途径。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-08.COMPOSITE（组合）— 对象结构型模式]]></title>
      <url>/2017/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08%E7%BB%84%E5%90%88/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>无</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>在绘图编辑器和图形捕捉系统这样的图形应用程序中，用户可以使用简单的组件创建复杂的图表。用户可以组合多个简单组件以形成一些较大的组件，这些组件又可以组合成更大的组件。一个简单的实现方法是为 Text 和 Line 这样的图元定义一些类，另外定义一些类作为这些图元的容器类（Container）。问题：使用这些类的代码必须区别对待图元对象与容器对象，而实际上大多数情况下用户认为它们是一样的。<br><img src="/images/posts/组合1.jpg" alt="图一"><br><a id="more"></a></p>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul>
<li>你想表示对象的部分 -整体层次结构。</li>
<li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/组合2.jpg" alt="图二"></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul>
<li>Component(Graphic)<ul>
<li>为组合中的对象声明接口。</li>
<li>在适当的情况下，实现所有类共有接口的缺省行为。</li>
<li>声明一个接口用于访问和管理 Component 的子组件。</li>
<li>(可选)在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它。</li>
</ul>
</li>
<li>Leaf(Rectangle、Line、Text 等)<ul>
<li>在组合中表示叶节点对象，叶节点没有子节点。</li>
<li>在组合中定义图元对象的行为。</li>
</ul>
</li>
<li>Composite(Picture)<ul>
<li>定义有子部件的那些部件的行为。</li>
<li>存储子部件。</li>
<li>在 Component 接口中实现与子部件有关的操作。</li>
</ul>
</li>
<li>Client<ul>
<li>通过 Component 接口操纵组合部件的对象。</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>用户使用  Component 类接口与组合结构中的对象进行交互。如果接收者是一个叶节点 ,则直接处理请求。如果接收者是  Composite , 它通常将请求发送给它的子部件，在转发请求之前与/或之后可能执行一些辅助操作。</p>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul>
<li>定义了包含基本对象和组合对象的类层次结构 </li>
<li>简化客户代码</li>
<li>使得更容易增加新类型的组件</li>
<li>使你的设计变得更加一般化</li>
<li>子部件排序</li>
<li></li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul>
<li>显式的父部件引用</li>
<li>共享组件</li>
<li>最大化 Component 接口</li>
<li>声明管理子部件的操作（透明性 or 安全性）</li>
<li>Component 是否应该实现一个 Component 列表</li>
<li>应该由谁删除 Component</li>
<li>存贮组件最好用哪一种数据结构（列表、树、数组和 hash 表，效率）</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul>
<li><p>Component</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Component</div><div class="line">&#123;</div><div class="line">    public abstract void Operation();</div><div class="line"></div><div class="line">    public virtual void Add(Component component)</div><div class="line">    &#123;</div><div class="line">        //默认实现，Leaf不需要复写，Composite需要复写</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public virtual void Remove(Component component)</div><div class="line">    &#123;</div><div class="line">        //默认实现，Leaf不需要复写，Composite需要复写</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public virtual Component GetChild(int index)</div><div class="line">    &#123;</div><div class="line">        //默认实现，Leaf不需要复写，Composite需要复写</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Leaf(Rectangle、Line、Text 等)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Leaf:Component</div><div class="line">&#123;</div><div class="line">    public override void Operation()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;Leaf&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Composite(Picture)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Composite:Component</div><div class="line">&#123;</div><div class="line">    private List&lt;Component&gt; children=new List&lt;Component&gt;();</div><div class="line"></div><div class="line">    public override void Operation()</div><div class="line">    &#123;</div><div class="line">        foreach(var component in children)</div><div class="line">        &#123;</div><div class="line">            component.Operation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public new void Add(Component component)</div><div class="line">    &#123;</div><div class="line">        children.Add(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public new void Remove(Component component)</div><div class="line">    &#123;</div><div class="line">       children.Add(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public new Component GetChild(int index)</div><div class="line">    &#123;</div><div class="line">        return children[index];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Client</div><div class="line">&#123;</div><div class="line">    public static void Main(string[] args)</div><div class="line">    &#123;</div><div class="line">        Component leaf=new Leaf();</div><div class="line">        leaf.Operation();</div><div class="line"></div><div class="line">        Component composite=new Composite();</div><div class="line">        composite.Add(leaf);</div><div class="line">        composite.Operation();</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>MVC 中的 View。</p>
<h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul>
<li>通常部件 - 父部件连接用于 Responsibility of Chain 模式。</li>
<li>Decorator 模式经常与 Composite 模式一起使用。当装饰和组合一起使用时，它们通常有一个公共的父类。因此装饰必须支持具有 Add、Remove 和 GetChild 操作的 Component。</li>
<li>Flyweight 让你共享组件，但不再能引用他们的父部件。</li>
<li>Itertor 可用来遍历 Composite。</li>
<li>Visitor 将本来应该分布在 Composite 和 Leaf 类中的操作和行为局部化。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-07.BRIDGE（桥接）— 对象结构型模式]]></title>
      <url>/2017/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-07%E6%A1%A5%E6%8E%A5/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>Handle/Body</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>当一个抽象可能有多个实现时，通常用继承来协调它们。抽象类定义对该抽象的接口，而具体的子类则用不同方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。继承机制有两个不足之处：<br>1) 扩展抽象使之适用于不同种类的窗口或新的系统平台很不方便。<br>2) 继承机制使得客户代码与平台相关。<br><a id="more"></a></p>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul>
<li>你不希望在抽象和它的实现部分之间有一个固定的绑定关系。 例如在程序运行时刻实现部分应可以被选择或者切换。</li>
<li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时 Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</li>
<li>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。</li>
<li>（C++）你想对客户完全隐藏抽象的实现部分。在 C++ 中，类的表示在类接口中是可见的。</li>
<li>正如在意图一节的第一个类图中所示的那样，有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。 </li>
<li>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/桥接1.jpg" alt="图一"></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul>
<li>Abstraction(Window)<ul>
<li>定义抽象类的接口。</li>
<li>维护一个指向 Implementor 类型对象的指针。</li>
</ul>
</li>
<li>RefinedAbstraction(IconWindow)<ul>
<li>扩充由 Abstraction 定义的接口。</li>
</ul>
</li>
<li>Implementor(WindowImp)<ul>
<li>定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致；事实上这两个接口可以完全不同。一般来讲，Implementor 接口仅提供基本操作，而 Abstraction 则定义了基于这些基本操作的较高层次的操作。</li>
</ul>
</li>
<li>ConcreteImplementor(XwindowImp,PMWindowImp)<ul>
<li>实现 Implementor 接口并定义它的具体实现。</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>Abstraction 将 client 的请求转发给它的 Implementor 对象。</p>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul>
<li>分离接口及其实现部分</li>
<li>提高可扩充性</li>
<li>实现细节对客户透明 </li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul>
<li><strong>仅有一个 Implementor</strong>在仅有一个实现的时候，没有必要创建一个抽象的 Implementor 类。这是 Bridge 模式的退化情况；在 Abstraction 与 Implementor 之间有一种一对一的关系。尽管如此，当你希望改变一个类的实现不会影响已有的客户程序时，模式的分离机制还是非常有用的—也就是说，不必重新编译它们，仅需重新连接即可。</li>
<li><strong>创建正确的 Implementor 对象</strong><ul>
<li>如果 Abstraction 知道所有的 ConcreteImplementor 类，它就可以在它的构造器中对其中的一个类进行实例化，它可以通过传递给构造器的参数确定实例化哪一个类。</li>
<li>首先选择一个缺省的实现，然后根据需要改变这个实现。</li>
<li>代理给另一个对象，由它一次决定。</li>
</ul>
</li>
<li><strong>共享 Implementor 对象</strong>多个对象间共享一些实现，有一个对象引用计数器，并对它进行增减操作。</li>
<li><strong>采用多重继承机制</strong>C#不支持，不考虑</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul>
<li><p>Abstraction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Abstraction</div><div class="line">&#123;</div><div class="line">    Implementor implementor=null;</div><div class="line"></div><div class="line">    public Abstraction(Implementor implementor)</div><div class="line">    &#123;</div><div class="line">        this.implementor=implementor;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    public void Operation()</div><div class="line">    &#123;</div><div class="line">        implementor.OperationImp();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>RefinedAbstraction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class RefinedAbstraction:Abstraction</div><div class="line">&#123;</div><div class="line">    public RefinedAbstraction(Implementor implementor)</div><div class="line">        :base(implementor)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Implementor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface Implementor</div><div class="line">&#123;</div><div class="line">    void OperationImp();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ConcreteImplementor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class ConcreteImplementorA</div><div class="line">&#123;</div><div class="line">    public void OperationImp()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;ConcreteImplementorA&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class ConcreteImplementorB</div><div class="line">&#123;</div><div class="line">    public void OperationImp()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;ConcreteImplementorB&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>三层架构的BLL和DAL层</p>
<h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul>
<li>Abstract Factory 模式可以用来创建和配置一个特定的 Bridge 模式。</li>
<li>Adapter 模式用来帮助无关的类协同工作，它通常在系统设计完成后才会被使用。然而，Bridge 模式则是在系统开始时就被使用，它使得抽象接口和实现部分可以独立进行改变。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-06.ADAPTER（适配器）— 类对象结构型模式]]></title>
      <url>/2017/09/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-06%E9%80%82%E9%85%8D%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>包装器 Wrapper</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>一个应用可能会有一些类具有不同的接口并且这些接口互不兼容，在这样的应用中象 TextView 这样已经存在并且不相关的类如何协同工作呢？我们可以改变 TextView 类使它兼容 Shape 类的接口，但前提是必须有这个工具箱的源代码。然而即使我们得到了这些源代码，修改 TextView 也是没有什么意义的；因为不应该仅仅为了实现一个应用，工具箱就不得不采用一些与特定领域相关的接口。<br><img src="/images/posts/适配器1.jpg" alt="图一"></p>
<a id="more"></a>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul>
<li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li>
<li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li>
<li>（仅适用于对象 Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><ul>
<li>类适配器使用多重继承对一个接口与另一个接口进行匹配<br><img src="/images/posts/适配器2.jpg" alt="图二"></li>
<li>对象匹配器依赖于对象组合<br><img src="/images/posts/适配器3.jpg" alt="图三"></li>
</ul>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul>
<li>Target(Shape)<ul>
<li>定义 Client 使用的与特定领域相关的接口。</li>
</ul>
</li>
<li>Client(DrawingEditor)<ul>
<li>与符合 Target 接口的对象协同。</li>
</ul>
</li>
<li>Adaptee(TextView)<ul>
<li>定义一个已经存在的接口，这个接口需要适配。</li>
</ul>
</li>
<li>Adapter(TextShape)<ul>
<li>对 Adaptee 的接口与 Target 接口进行适配。</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>Client 在 Adapter 实例上调用一些操作。接着适配器调用 Adaptee 的操作实现这个请求。</p>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul>
<li>类适配器<ul>
<li>用一个具体的 Adapter 类对 Adaptee 和 Target 进行匹配。结果是当我们想要匹配一个类以及所有它的子类时，类 Adapter 将不能胜任工作。</li>
<li>使得 Adapter 可以重定义 Adaptee 的部分行为，因为 Adapter 是 Adaptee 的一个子类。</li>
<li>仅仅引入了一个对象，并不需要额外的指针以间接得到 Adaptee。</li>
</ul>
</li>
<li>对象适配器<ul>
<li>允许一个 Adapter 与多个 Adaptee 即Adaptee本身以及它的所有子类（如果有子类的话）。</li>
<li>同时工作 Adapter 也可以一次给所有的 Adaptee 添加功能。</li>
<li>使得重定义 Adaptee 的行为比较困难。这就需要生成 Adaptee 的子类并且使得 Adapter 引用这个子类而不是引用 Adaptee 本身。</li>
</ul>
</li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul>
<li>使用 C++ 实现适配器类</li>
<li>可插入的适配器<ul>
<li>使用抽象操作<br><img src="/images/posts/适配器4.jpg" alt="图四"></li>
<li>使用代理对象<br><img src="/images/posts/适配器5.jpg" alt="图五"></li>
<li>参数化的适配器</li>
</ul>
</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul>
<li><p>Target</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface ITarget</div><div class="line">&#123;</div><div class="line">    void Request();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Adaptee</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Adaptee</div><div class="line">&#123;</div><div class="line">    public void SpecificRequest()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;适配的对象&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Adapter<br>类适配器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class ClassAdapter : Adaptee, ITarget</div><div class="line">&#123;</div><div class="line">    public void Request()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;目标对象&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对象适配器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class ObjectAdapter : ITarget</div><div class="line">&#123;</div><div class="line">    private Adaptee adaptee = null;</div><div class="line"></div><div class="line">    public ObjectAdapter(Adaptee adaptee)</div><div class="line">    &#123;</div><div class="line">        this.adaptee = adaptee;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Request()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;目标对象&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void SpecificRequest()</div><div class="line">    &#123;</div><div class="line">        adaptee.SpecificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Client</div><div class="line">&#123;</div><div class="line">    public static void Main(string[] args)</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;========类适配器=========&quot;);</div><div class="line">        ClassAdapter classAdapter = new ClassAdapter();</div><div class="line">        classAdapter.Request();</div><div class="line">        classAdapter.SpecificRequest();</div><div class="line"></div><div class="line">        Console.WriteLine(&quot;========对象适配器=========&quot;);</div><div class="line">        Adaptee adaptee=new Adaptee();</div><div class="line">        ObjectAdapter objectAdapter=new ObjectAdapter(adaptee);</div><div class="line"></div><div class="line">        objectAdapter.Request();</div><div class="line">        objectAdapter.SpecificRequest();</div><div class="line"></div><div class="line">        Console.ReadLine();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>各类第三方接口</p>
<h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul>
<li>Bridge 模式的结构与对象适配器类似，但是 Bridge 模式的出发点不同：Bridge 目的是将接口部分和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。而 Adapter 则意味着改变一个已有对象的接口。</li>
<li>Decorator 模式增强了其他对象的功能而同时又不改变它的接口。因此 decorator 对应用程序的透明性比适配器要好。结果是 decorator 支持递归组合，而纯粹使用适配器是不可能实现这一点的。</li>
<li>Proxy 模式不改变它的接口的条件下，为另一个对象定义了一个代理。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue笔记]]></title>
      <url>/2017/09/08/Vue%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><ul>
<li>vue</li>
<li>vue-cli</li>
<li>vue-devtools</li>
</ul>
<h2 id="2-Vue实例生命周期"><a href="#2-Vue实例生命周期" class="headerlink" title="2.Vue实例生命周期"></a>2.Vue实例生命周期</h2><p><img src="/images/posts/vue-lifecycle.png" alt="Vue实例声明周期"></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-05.SINGLETON（单件）— 对象创建型模式]]></title>
      <url>/2017/09/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-05%E5%8D%95%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>无</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。这就是 Singleton 模式。<br><a id="more"></a></p>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul>
<li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li>
<li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/单例1.jpg" alt="图一"></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul>
<li>Singleton<ul>
<li>定义一个 Instance 操作，允许客户访问它的唯一实例。 Instance 是一个类操作。</li>
<li>可能负责创建它自己的唯一实例。</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>客户只能通过 Singleton 的 Instance 操作访问一个 Singleton 的实例。</p>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul>
<li>对唯一实例的受控访问</li>
<li>缩小名空间</li>
<li>允许对操作和表示的精化</li>
<li>允许可变数目的实例</li>
<li>比类操作更灵活</li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul>
<li>保证一个唯一的实例</li>
<li>创建 Singleton 类的子类</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul>
<li><strong>第一种</strong>：线程不安全，不建议使用</li>
</ul>
<p><em>建议</em>：使用sealed关键字标识类不可继承，单例模式的类不应该继承，否则每个子类都可创建实例，违反唯一实例原则。<br><em>备注</em>：只适用于单线程，多线程由于未加锁，导致各个线程都会创建一个实例，违反单例模式的基本原则。<br>As hinted at before, the above is not thread-safe. Two different threads could both have evaluated the test if (instance==null) and found it to be true, then both create instances, which violates the singleton pattern.<br>Note that in fact the instance may already have been created before the expression is evaluated, but the memory model doesn’t guarantee that the new value of instance will be seen by other threads unless suitable memory barriers have been passed.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public sealed class Sington1</div><div class="line">&#123;</div><div class="line">    private static Sington1 instance = null;</div><div class="line"></div><div class="line">    private Sington1()</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Sington1 Instance</div><div class="line">    &#123;</div><div class="line">        get</div><div class="line">        &#123;</div><div class="line">            if (instance == null)</div><div class="line">                instance = new Sington1();</div><div class="line"></div><div class="line">            return instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>第二种</strong>：简单版线程安全</li>
</ul>
<p><em>备注</em>：该版本代码对于每个线程都会对线程辅助对象locker加锁之后再判断实例是否存在，对于这个操作完全没有必要的，因为当第一个线程创建了该类的实例之后，后面的线程此时只需要直接判断（uniqueInstance==null）为假，此时完全没必要对线程辅助对象加锁之后再去判断，所以上面的实现方式增加了额外的开销，损失了性能。<br>This implementation is thread-safe. The thread takes out a lock on a shared object, and then checks whether or not the instance has been created before creating the instance. This takes care of the memory barrier issue (as locking makes sure that all reads occur logically after the lock acquire, and unlocking makes sure that all writes occur logically before the lock release) and ensures that only one thread will create an instance (as only one thread can be in that part of the code at a time - by the time the second thread enters it,the first thread will have created the instance, so the expression will evaluate to false). Unfortunately, performance suffers as a lock is acquired every<br>time the instance is requested.<br>Note that instead of locking on typeof(Singleton) as some versions of this implementation do, I lock on the value of a static variable which is private to the class. Locking on objects which other classes can access and lock on(such as the type) risks performance issues and even deadlocks.This is a general style preference of mine - wherever possible,only lock on objects specifically created for the purpose of locking, or which document that they are to be locked on for specific purposes (e.g. for waiting/pulsing a queue). Usually such objects should be private to the class they are used in. This helps to make writing thread-safe applications significantly easier.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public sealed class Sington2</div><div class="line">&#123;</div><div class="line">    private static Sington2 instance = null;</div><div class="line">    // 定义一个标识确保线程同步</div><div class="line">    private static readonly object lockObj = null;</div><div class="line"></div><div class="line">    private Sington2()</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Sington2 Instance</div><div class="line">    &#123;</div><div class="line">        get</div><div class="line">        &#123;</div><div class="line">            // 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</div><div class="line">            // 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</div><div class="line">            // lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</div><div class="line">            lock (lockObj)</div><div class="line">            &#123;</div><div class="line">                if (instance == null)</div><div class="line">                    instance = new Sington2();</div><div class="line"></div><div class="line">                return instance;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>第三种：线程安全、双重锁定</strong></li>
</ul>
<p><em>备注</em>：该版本代码为了改进上面实现方式的缺陷，我们只需要在lock语句前面加一句判断就可以避免锁所增加的额外开销，这种实现方式我们就叫它 “双重锁定”。<br>This implementation attempts to be thread-safe without the necessity of taking out a lock every time. Unfortunately, there are four downsides to the pattern:<br>1.It doesn’t work in Java. This may seem an odd thing to comment on, but it’s worth knowing if you ever need the singleton pattern in Java, and c# programmers may well also be Java programmers. The Java memory model doesn’t ensure that the constructor completes before the reference to the new object is assigned to instance. The Java memory model underwent a reworking for version 1.5, but double-check locking is still broken after this without a volatile variable (as in c#).<br>2.Without any memory barriers, it’s broken in the ECMA CLI specification too. It’s possible that under the.NET 2.0 memory model(which is stronger than the ECMA spec) it’s safe, but I’d rather not rely on those stronger semantics, especially if there’s any doubt as to the safety. Making the instance variable volatile can make it work, as would explicit memory barrier calls, although in the latter case even experts can’t agree exactly which barriers are required.I tend to try to avoid situations where experts don’t agree what’s right and what’s wrong!<br>3.It’s easy to get wrong. The pattern needs to be pretty much exactly as above - any significant changes are likely to impact either performance or correctness.<br>4.It still doesn’t perform as well as the later implementations.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public sealed class Sington3</div><div class="line">&#123;</div><div class="line">    private static Sington3 instance = null;</div><div class="line">    // 定义一个标识确保线程同步</div><div class="line">    private static readonly object lockObj = null;</div><div class="line"></div><div class="line">    private Sington3()</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Sington3 Instance</div><div class="line">    &#123;</div><div class="line">        get</div><div class="line">        &#123;</div><div class="line">            // 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</div><div class="line">            // 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</div><div class="line">            // lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</div><div class="line">            // 双重锁定只需要一句判断就可以了</div><div class="line">            if (instance == null)</div><div class="line">            &#123;</div><div class="line">                lock (lockObj)</div><div class="line">                &#123;</div><div class="line">                    if (instance == null)</div><div class="line">                        instance = new Sington3();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>第四种：线程安全、不使用锁、静态初始化</strong></li>
</ul>
<p><em>备注</em>：静态初始化的方式是在自己的字段被引用时才会实例化,添加了静态构造函数当静态字段被引用时才进行初始化，因此即便很多线程试图引用_instance，<br>也需要等静态构造函数执行完并把静态成员_instance实例化之后可以使用。<br>As you can see, this is really is extremely simple - but why is it thread-safe and how lazy is it? Well, static constructors in c# are specified to execute only when an instance of the class is created or a static member is referenced, and to execute only once per AppDomain. Given that this check for the type being newly constructed needs to be executed whatever else happens, it will be faster than adding extra checking as in the previous examples. There are a couple of wrinkles, however:<br>1.It’s not as lazy as the other implementations. In particular, if you have static members other than Instance, the first reference to those members will involve creating the instance. This is corrected in the next implementation.<br>2.There are complications if one static constructor invokes another which invokes the first again.Look in the.NET specifications (currently section 9.5.3 of partition II) for more details about the exact nature of type initializers - they’re unlikely to bite you, but it’s worth being aware of the consequences of static constructors which refer to each other in a cycle.<br>3.The laziness of type initializers is only guaranteed by.NET when the type isn’t marked with a special flag called beforefieldinit. Unfortunately, the c# compiler (as provided in the .NET 1.1 runtime, at least) marks all types which don’t have a static constructor(i.e.a block which looks like a constructor but is marked static) as beforefieldinit.I now have an article with more details about this issue.Also note that it affects performance, as discussed near the bottom of the page.<br>One shortcut you can take with this implementation (and only this one) is to just make instance a public static readonly variable, and get rid of the property entirely.This makes the basic skeleton code absolutely tiny!Many people, however, prefer to have a property in case further action is needed in future, and JIT inlining is likely to make the performance identical. (Note that the static constructor itself is still required if you require laziness.)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public sealed class Sington4</div><div class="line">&#123;</div><div class="line">    private static Sington4 instance = null;</div><div class="line"></div><div class="line">    /// &lt;summary&gt;</div><div class="line">    /// 添加一个静态构造函数，用于屏蔽IL将变量属性自动标记beforefieldinit。</div><div class="line">    /// Explicit static constructor to tell c# compiler not to mark type as beforefieldinit</div><div class="line">    /// &lt;/summary&gt;</div><div class="line">    static Sington4()</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Sington4()</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Sington4 Instance</div><div class="line">    &#123;</div><div class="line">        get</div><div class="line">        &#123;</div><div class="line">            if (instance == null)</div><div class="line">                instance = new Sington4();</div><div class="line"></div><div class="line">            return instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>第五种：线程安全、延迟初始化</strong></li>
</ul>
<p><em>备注</em>：把初始化工作放到Nested类中的一个静态成员来完成，这样就实现了延迟初始化。<br>Here, instantiation is triggered by the first reference to the static member of the nested class, which only occurs in Instance. This means the implementation is fully lazy, but has all the performance benefits of the previous ones. Note that although nested classes have access to the enclosing class’s private members, the reverse is not true, hence the need for instance to be internal here. That doesn’t raise any other problems, though, as the class itself is private. The code is a bit more complicated in order to make the instantiation lazy, however.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public sealed class Sington5</div><div class="line">&#123;</div><div class="line">    private Sington5()</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Sington5 Instance</div><div class="line">    &#123;</div><div class="line">        get</div><div class="line">        &#123;</div><div class="line">            return SingtonNested.instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    internal class SingtonNested</div><div class="line">    &#123;</div><div class="line">        internal static Sington5 instance = new Sington5();</div><div class="line"></div><div class="line">        // Explicit static constructor to tell c# compiler not to mark type as beforefieldinit</div><div class="line">        static SingtonNested()</div><div class="line">        &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>第六种：using .NET 4’s Lazy<t> type</t></strong></li>
</ul>
<p>备注：简单和性能良好，而且还提供检查是否已经创建实例的属性IsValueCreated。<br>If you’re using .NET 4 (or higher), you can use the System.Lazy<t> type to make the laziness really simple. All you need to do is pass a delegate to the constructor which calls the Singleton constructor - which is done most easily with a lambda expression.It’s simple and performs well. It also allows you to check whether or not the instance has been created yet with the IsValueCreated property, if you need that.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public sealed class Sington6</div><div class="line">&#123;</div><div class="line">    private static readonly Lazy&lt;Sington6&gt; lazy = new Lazy&lt;Sington6&gt;(() =&gt; new Sington6(), true);</div><div class="line"></div><div class="line">    private Sington6()</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Sington6 Instance</div><div class="line">    &#123;</div><div class="line">        get</div><div class="line">        &#123;</div><div class="line">            return lazy.Value;</div><div class="line">        &#125;</div><div class="line">    &#125;       </div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p>
<ul>
<li><strong>总结</strong><blockquote><p>There are various different ways of implementing the singleton pattern in C#. A reader has written to me detailing a way he has encapsulated the synchronization aspect, which while I acknowledge may be useful in a few very particular situations (specifically where you want very high performance, and the ability to determine whether or not the singleton has been created, and full laziness regardless of other static members being called). I don’t personally see that situation coming up often enough to merit going further with on this page, but please mail me if you’re in that situation.</p>
<p><strong>My personal preference is for solution 4</strong>: the only time I would normally go away from it is if I needed to be able to call other static methods without triggering initialization, or if I needed to know whether or not the singleton has already been instantiated. I don’t remember the last time I was in that situation, assuming I even have. In that case, I’d probably go for solution 2, which is still nice and easy to get right.</p>
<p>Solution 5 is elegant, but trickier than 2 or 4, and as I said above, the benefits it provides seem to only be rarely useful. <strong>Solution 6 is a simpler way to achieve laziness, if you’re using .NET 4.</strong> It also has the advantage that it’s obviously lazy. I currently tend to still use solution 4, simply through habit - but if I were working with inexperienced developers I’d quite possibly go for solution 6 to start with as an easy and universally applicable pattern.</p>
<p><strong>(I wouldn’t use solution 1 because it’s broken, and I wouldn’t use solution 3 because it has no benefits over 5.)</strong></p>
<footer><strong>Jon Skeet,C# In Depth</strong><cite><a href="http://csharpindepth.com/Articles/General/Singleton.aspx" target="_blank" rel="external">Implementing the Singleton Pattern in C#</a></cite></footer></blockquote>
</li>
</ul>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><ul>
<li>日志</li>
</ul>
<h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><p>很多模式可以使用 Singleton 模式实现。参见 AbstractFactory、Builder，和Prototype。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-04.PROTOTYPE（原型）— 对象创建型模式]]></title>
      <url>/2017/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-04%E5%8E%9F%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>无</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p><img src="/images/posts/原型1.jpg" alt="图一"><br><a id="more"></a></p>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul>
<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载；</li>
<li>为了避免创建一个与产品类层次平行的工厂类层次时；</li>
<li>当一个类的实例只能有几个不同状态组合中的一种时，建立相应数目的原型并克隆它们<br>可能比每次用合适的状态手工实例化该类更方便一些。</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/原型2.jpg" alt="图二"></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul>
<li>Prototype（Graphic）<ul>
<li>声明一个克隆自身的接口。</li>
</ul>
</li>
<li>ConcretePrototype（Staff、WholeNote、HalfNote）<ul>
<li>实现一个克隆自身的操作。</li>
</ul>
</li>
<li>Client（GraphicTool）<ul>
<li>让一个原型克隆自身从而创建一个新的对象。</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>客户请求一个原型克隆自身。</p>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><p>Prototype有许多和AbstractFactory和Builder一样的效果：它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。此外，这些模式使客户无需改变即可使用与特定应用相关的类。</p>
<ul>
<li>运行时刻增加和删除产品</li>
<li>改变值以指定新对象</li>
<li>改变结构以指定新对象</li>
<li>减少子类的构造</li>
<li>用类动态配置应用</li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul>
<li>使用一个原型管理器</li>
<li>实现克隆操作</li>
<li>初始化克隆对象</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul>
<li><p>Prototype</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface IPrototype</div><div class="line">&#123;</div><div class="line">    IPrototype Clone();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ConcretePrototype（Staff、WholeNote、HalfNote）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class ConcretePrototype : IPrototype</div><div class="line">&#123;</div><div class="line">    public IPrototype Clone()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;ConcretePrototype&quot;);</div><div class="line"></div><div class="line">        return this.MemberwiseClone() as IPrototype;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Client（GraphicTool）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Client</div><div class="line">&#123;</div><div class="line">    IPrototype prototype=new ConcretePrototype();</div><div class="line">    IPrototype clonePrototype=prototype.Clone();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>ICloneable.Clone</p>
<h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul>
<li>Prototype 和 AbstractFactory 模式在某种方面是相互竞争的。但是它们也可以一起使用。AbstractFactory 可以存储一个被克隆的原型的集合，并且返回产品对象。</li>
<li>大量使用 Composite 和 Decorator 模式的设计通常也可从 Prototype 模式处获益。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-03.FACTORY METHOD（工厂方法）— 对象创建型模式]]></title>
      <url>/2017/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-03%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method 使一个类的实例化延迟到其子类。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>虚构造器（Virtual Constructor）</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>框架使用抽象类定义和维护对象之间的关系。这些对象的创建通常也由框架负责。<br><img src="/images/posts/工厂方法1.jpg" alt="图一"></p>
<a id="more"></a>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul>
<li>当一个类不知道它所必须创建的对象的类的时候。</li>
<li>当一个类希望由它的子类来指定它所创建的对象的时候。</li>
<li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/工厂方法2.jpg" alt="图二"></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul>
<li>Product(Document)：<ul>
<li>定义工厂方法所创建的对象的接口。</li>
</ul>
</li>
<li>ConcreteProduct（MyDocument）<ul>
<li>实现 Product 接口。</li>
</ul>
</li>
<li>Creator（Application）<ul>
<li>声明工厂方法，该方法返回一个 Product 类型的对象。Creator 也可以定义一个工厂方法的缺省实现，它返回一个缺省的 ConcreteProduct 对象。</li>
<li>可以调用工厂方法以创建一个 Product 对象。</li>
</ul>
</li>
<li>ConcreteCreator（MyApplication）<ul>
<li>重定义工厂方法以返回一个 ConcreteProduct 实例。</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>Creator依赖于它的子类来定义工厂方法，所以它返回一个适当的ConcreteProduct实例。</p>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><p>工厂方法不再将与特定应用有关的类绑定到你的代码中。代码仅处理 Product 接口；因此它可以与用户定义的任何 ConcreteProduct 类一起使用。<br>工厂方法的一个潜在缺点在于客户可能仅仅为了创建一个特定的 ConcreteProduct 对象，就不得不创建 Creator 的子类。当 Creator 子类不必需时，客户现在必然要处理类演化的其他方面；但是当客户无论如何必须创建 Creator 的子类时，创建子类也是可行的。</p>
<ul>
<li>为子类提供挂钩（hook）：用工厂方法在一个类的内部创建对象通常比直接创建对象更灵活。Factory Method 给子类一个挂钩以提供对象的扩展版本。</li>
<li>连接平行的类层次：当一个类将它的一些职责委托给一个独立的类的时候，就产生了平行类层次。<br><img src="/images/posts/工厂方法3.jpg" alt="图三"></li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul>
<li>主要有两种不同的情况<ul>
<li>1 第一种情况：Creator类是一个抽象类并且不提供它所声明的工厂方法的实现。需要子类来定义实现，因为没有合理的缺省实现。它避免了不得不实例化不<br>可预见类的问题。</li>
<li>2 第二种情况：Creator是一个具体的类而且为工厂方法提供一个缺省的实现。也有可能有一个定义了缺省实现的抽象类，但这不太常见。具体的Creator主要因为灵活性才使用工厂方法。它所遵循的准则是，“用一个独立的操作创建对象，这样子类才能重定义它们的创建方式。”这条准则保证了子类的设计者能够在必要的时候改变父类所实例化的对象的类。</li>
</ul>
</li>
<li>参数化工厂方法<ul>
<li>该模式的另一种情况使得工厂方法可以创建多种产品。工厂方法采用一个标识要被创建的对象种类的参数。工厂方法创建的所有对象将共享Product接口。在Document的例子中，Application可能支持不同种类的Document。你给CreateDocument传递一个外部参数来指定将要创建的文档的种类。</li>
</ul>
</li>
<li>特定语言的变化和问题</li>
<li>使用模板以避免创建子类</li>
<li>命名约定</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul>
<li><p>Product</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class IProduct</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ConcreteProduct</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class ConcreteProduct : IProduct</div><div class="line">&#123;</div><div class="line">   public ConcreteProduct()</div><div class="line">   &#123;</div><div class="line">      Console.WriteLine(&quot;具体产品&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Creator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">abstract class Creator</div><div class="line">&#123;</div><div class="line">    public abstract IProduct FactoryMethod();</div><div class="line"></div><div class="line">    /// &lt;summary&gt;</div><div class="line">    /// 工厂方法的缺省实现</div><div class="line">    /// &lt;/summary&gt;</div><div class="line">    /// &lt;returns&gt;&lt;/returns&gt;</div><div class="line">    public IProduct Create()</div><div class="line">    &#123;</div><div class="line">        return this.FactoryMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ConcreteCreator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class ConcreteCreator : Creator</div><div class="line">&#123;</div><div class="line">    public override IProduct FactoryMethod()</div><div class="line">    &#123;</div><div class="line">        IProduct product = new ConcreteProduct();</div><div class="line">        return product;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Main</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Program</div><div class="line">&#123;</div><div class="line">    static void Main(string[] args)</div><div class="line">    &#123;</div><div class="line">        Creator creator = new ConcreteCreator();</div><div class="line">        creator.Create();</div><div class="line"></div><div class="line">        Console.ReadLine();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>工厂方法主要用于工具包和框架中。</p>
<h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul>
<li>AbstractFactory：经常用工厂方法来实现。AbstractFactory 模式中动机一节的例子也对FactoryMethod进行了说明。工厂方法通常在TemplateMethods（5.10）中被调用。在上面的文档例子中，NewDocument就是一个模板方法。</li>
<li>Prototypes：不需要创建Creator的子类。但是，它们通常要求一个针对Product类的Initialize操作。Creator使用Initialize来初始化对象。而FactoryMethod不需要这样的操作。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP笔记]]></title>
      <url>/2017/09/05/HTTP%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><img src="/images/posts/HTTP1.png" alt="图一"></p>
<h2 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1.应用层"></a>1.应用层</h2><p>决定向用户提供应用服务时通信的活动。<br>TCP/IP协议簇内预存了各类通用的应用服务，如FTP文件传输协议，DNS域名系统服务。HTTP协议也在该层。</p>
<h2 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2.传输层"></a>2.传输层</h2><p>对上层应用层提供处于网络连接中两台计算机间的数据传输。<br>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。</p>
<h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h2><p>处理在网络上流动的数据包（网络传输的最小数据单位），该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。</p>
<a id="more"></a>
<h2 id="4-链路层"><a href="#4-链路层" class="headerlink" title="4.链路层"></a>4.链路层</h2><p>用来处理连接网络的硬件部分，包括控制操作系统，硬件设备驱动,网络适配器（网卡）及光纤等物理可见部分。</p>
<h2 id="5-IP协议"><a href="#5-IP协议" class="headerlink" title="5.IP协议"></a>5.IP协议</h2><p>IP（Internet Protocol）网际协议位于网络层。TCP/IP协议簇中的IP指的就是网际协议。<br>作用是把各种数据包发送给对方，而要确保发送正确需满足各类条件，其中两个重要的就是IP地址和MAC（Media Access Control Address）地址。<br>IP地址指明节点被分配的地址，MAC地址指网卡的固定地址，可配对。IP地址可变换而MAC地址基本不变。</p>
<h2 id="6-ARP协议"><a href="#6-ARP协议" class="headerlink" title="6.ARP协议"></a>6.ARP协议</h2><p>ARP（Address Resolution Protocol）协议是一种用以解析地址的协议，根据通信方的IP地址反查出对应的MAC地址。</p>
<h2 id="7-TCP协议"><a href="#7-TCP协议" class="headerlink" title="7.TCP协议"></a>7.TCP协议</h2><p>TCP协议位于传输层，提供可靠的字节流服务。采用三次握手（three-way handshaking）策略：发送端先发送带SYN（synchronize）标志的数据包给对方，接收端接受到后回传一个带SYN/ACK（acknowledgement）标志的数据包确认，最后，发送端回传ACK标志的数据包，表示握手结束。</p>
<h2 id="8-DNS服务"><a href="#8-DNS服务" class="headerlink" title="8.DNS服务"></a>8.DNS服务</h2><p>DNS（Domain Name System）服务用于域名到IP地址之间解析，位于应用层。<br><img src="/images/posts/HTTP2.png" alt="图二"></p>
<h2 id="9-URI（Uniform-Resource-Identifier）统一资源标识符"><a href="#9-URI（Uniform-Resource-Identifier）统一资源标识符" class="headerlink" title="9.URI（Uniform Resource Identifier）统一资源标识符"></a>9.URI（Uniform Resource Identifier）统一资源标识符</h2><p>由某个协议方案表示的资源的定位标识符。</p>
<h3 id="9-1Uniform"><a href="#9-1Uniform" class="headerlink" title="9.1Uniform"></a>9.1Uniform</h3><p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。</p>
<h3 id="9-2Resource"><a href="#9-2Resource" class="headerlink" title="9.2Resource"></a>9.2Resource</h3><p> 资源的定义是可标识的任何东西。</p>
<h3 id="9-3Identifier"><a href="#9-3Identifier" class="headerlink" title="9.3Identifier"></a>9.3Identifier</h3><p>表示可标识的对象，即标识符。</p>
<h2 id="10-URL（Uniform-Resource-Locator）统一资源定位符"><a href="#10-URL（Uniform-Resource-Locator）统一资源定位符" class="headerlink" title="10.URL（Uniform Resource Locator）统一资源定位符"></a>10.URL（Uniform Resource Locator）统一资源定位符</h2><p>资源的地点，是URI的子集。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 图解HTTP（第1章：基础知识）</p>
]]></content>
      
        <categories>
            
            <category> HTTP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VS设置类库程序集自动更新版本号]]></title>
      <url>/2017/09/05/VS%E8%AE%BE%E7%BD%AE%E7%B1%BB%E5%BA%93%E7%A8%8B%E5%BA%8F%E9%9B%86%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h2 id="1-修改AssemblyInfo文件"><a href="#1-修改AssemblyInfo文件" class="headerlink" title="1.修改AssemblyInfo文件"></a>1.修改AssemblyInfo文件</h2><ul>
<li>更改[assembly: AssemblyVersion(“1.0.*”)]</li>
<li>注释[assembly: AssemblyFileVersion(“1.0.0”)]</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C# </tag>
            
            <tag> VS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis笔记]]></title>
      <url>/2017/09/05/Redis%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-键值对"><a href="#1-键值对" class="headerlink" title="1 键值对"></a>1 键值对</h2><ul>
<li>SET TESTKEY “TESTVALUE”,设置键值对TESTKEY-“TESTVALUE”，返回OK；</li>
<li>GET TESTKEY,获取键TESTKEY的值（获取不存在的键的值返回nil，即空）；</li>
<li>DEL TESTKEY,删除键为TESTKEY的键值对，成功返回1；</li>
<li>EXISTS TESTKEY,键是否存在，0否1是</li>
<li>TYPE TESTKEY,返回键的类型，如string、list等，若键不存在返回None;</li>
<li>INCR TESTKEY,自动加一，成功返回结果（若TESTKEY不是int值，则报错）<br>  <code>注意：INCR命令是原子操作（即不会被线程调度机制打断的操作）</code>;</li>
<li>SETNX TEST1 ‘TESTVALUE’，若键不存在则设置，若键存在则不设置，成功返回1，失败返回0；</li>
<li>EXPIRE TESTKEY 120,设置键TESTKEY有效期120秒（等同于 SET TESTKEY ‘TESTVALUE’ EX 120）；</li>
<li>PERSIST TESTKEY,取消TESTKEY的有效期，1成功0失败</li>
<li>TTL TESTKEY,查看键TESTKEY剩余有效期,-2表示键已过期不存在，-1表示永不过期，若重下SET TESTKEY，则状态重置为-1;</li>
</ul>
<a id="more"></a>
<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h2><h3 id="2-1-列表（list）有序、可重复"><a href="#2-1-列表（list）有序、可重复" class="headerlink" title="2.1 列表（list）有序、可重复"></a>2.1 列表（list）有序、可重复</h3><ul>
<li>RPUSH TESTLIST “ITEM1” “ITEM2” “ITEM3” … “ITEMN”,插入多项到列表尾部，返回列表子项个数；</li>
<li>LPUSH TESTLIST “ITEM2”,插入一项到列表头部，返回列表子项个数；</li>
<li>LRANGE TESTLIST 0 -1,列出列表子项，参数1表示从第0个开始，参数2表示到第N个（-1表示最后）；</li>
<li>LLEN TESTLIST,获取列表子项个数；</li>
<li>LPOP TESTLIST,移除列表头部项，返回项的值；</li>
<li>RPOP TESTLIST,移除列表尾部项，返回项的值；</li>
<li>工具命令BRPOP TESTLIST 0、BLPOP，阻塞版本的取元素，若LIST为空，仅在规定时间（0代表永久）内有新元素加入时候取出，而不是返回NULL；<ul>
<li>客户端按顺序执行，第一个取得先等其他客户端加入元素，以此类推；</li>
<li>与RPOP相比，返回值是不同的：它是一个两元素数组，因为它也包括键的名称，因为BRPOP和BLPOP能够阻止等待来自多个列表的元素。</li>
<li>如果超时，则返回NULL。</li>
<li>RPOPLPUSH更适合命令创建安全的队列，BRPOPLPUSH阻塞版本</li>
</ul>
</li>
<li>LTRIM TESTLIST 0 2，只保留前3项，丢弃之后的元素；</li>
</ul>
<h3 id="2-2-集合（set）无序、不可重复"><a href="#2-2-集合（set）无序、不可重复" class="headerlink" title="2.2 集合（set）无序、不可重复"></a>2.2 集合（set）无序、不可重复</h3><ul>
<li>SADD TESTSET “ITEM1” “ITEM2” “ITEM3” … “ITEMN”,插入一项到集合中，返回1表示成功，若已有该项则返回0；</li>
<li>SREM TESTSET “ITEM1”,从集合中移除指定项，返回1表示成功，若无该项则返回0；</li>
<li>SISMEMBER TESTSET “ITEM1”，验证指定项是否在集合中，0否1是；</li>
<li>SMEMBERS TESTSET，列出集合项</li>
<li>SUNION TESTSET1 TEST2 … TESTN,取多个集合并集（无序无重复项）；</li>
<li>SINTER TESTSET1 TEST2 … TESTN,取多个集合交集</li>
<li>SUNIONSTORE TESTSETALL TESTSET1 TESTSET2 …TESTSETN,将多个集合并集保存至TESTSETALL</li>
<li>SCARD TESETSET1，获取集合元素个数</li>
<li>SPOP TESTSET1，随机取一个集合元素，移除集合</li>
<li>SRANDMEMBER TESTSET1，随机取一个集合元素，不移除集合</li>
</ul>
<h3 id="2-3-有序集合（sorted-set）有序、不可重复"><a href="#2-3-有序集合（sorted-set）有序、不可重复" class="headerlink" title="2.3 有序集合（sorted set）有序、不可重复"></a>2.3 有序集合（sorted set）有序、不可重复</h3><ul>
<li>ZADD TESTSORTSET 3 “C”,3为关联值，用于排序，float；</li>
<li>ZRANGE TESTSORTLIST 0 -1 [withscores],列出有序集合子项，参数1表示从第0个开始，参数2表示到第N个（-1表示最后）,[withscores]可选，是否列出score项；</li>
<li>ZREVRANGE TESTSORTLIST 0，-1,反向列出有序集合元素；</li>
<li>ZRANK TESTSORTLIST ‘C’,查找指定元素的位置；</li>
<li>ZREVRANK TESTSORTLIST ‘C’,反向查找指定元素的位置；</li>
</ul>
<h3 id="2-4-哈希（Hashes）用于保存对象"><a href="#2-4-哈希（Hashes）用于保存对象" class="headerlink" title="2.4 哈希（Hashes）用于保存对象"></a>2.4 哈希（Hashes）用于保存对象</h3><ul>
<li>HSET obj name ‘venux’;HSET obj age ‘27’;HSET obj email ‘337225164@qq.com’,保存一个obj对象，单个属性存放用户名、年龄、email。</li>
<li>HMSET obj name ‘venux’ age ‘27’ email ‘337225164@qq.com’,保存一个obj对象，多个属性存放用户名、年龄、email。</li>
<li>HGETALL obj,获取obj对象</li>
<li>HGET obj name,获取obj对象的name属性</li>
<li>HINCRBY obj age 10,给obj对象的age属性加10，Hash字段中数值类型使用同等的字符串表示，并能通过<code>HINCRBY</code>（原子操作）累加</li>
</ul>
<h2 id="3-Redis支持的数据结构"><a href="#3-Redis支持的数据结构" class="headerlink" title="3 Redis支持的数据结构"></a>3 Redis支持的数据结构</h2><ol>
<li>Binary-safe strings；</li>
<li>Lists:按插入顺序排序的列表，基于链表；</li>
<li>Sets:无序、唯一的集合；</li>
<li>Sorted sets:有序、唯一的有序集合，用一个称为scroe的float字段存放排序值；</li>
<li>Hashes:一系列属性合集，即对象，字段名和值都为strings；</li>
<li>Bit arrays (or simply bitmaps):二进制数组；</li>
<li>HyperLogLogs:this is a probabilistic data structure which is used in order to estimate the cardinality of a set（概率性数据结构，用于评估集合的基数）.</li>
</ol>
<h2 id="4-Redis-keys"><a href="#4-Redis-keys" class="headerlink" title="4 Redis keys"></a>4 Redis keys</h2><ul>
<li>空字符串也是有效的key值；</li>
<li>太长的key不好，若key代表的对象本身过长，使用hash（如SHA1）后的值作为key值；</li>
<li>太短的key值也不好，如使用user:1000:followers替代u1000flw，这样可读性更良好；</li>
<li>尽量（坚持）使用模式，一个良好的模式<code>object-type:id</code>，通常使用<code>:</code>、<code>-</code>、<code>.</code>分割。例如<code>user:1000</code>、<code>comment:1234:reply.to</code>、<code>comment:1234:reply-to</code>；</li>
<li>键最大容量为512MB。</li>
</ul>
<h2 id="5-Redis-Strings"><a href="#5-Redis-Strings" class="headerlink" title="5 Redis Strings"></a>5 Redis Strings</h2><ul>
<li>键值都为string类型，和<code>Memcached</code>一样，string作为唯一的数据类型；</li>
<li>值也可用于保存图片资源，只要格式本质是string（如二进制），且大小不能超出512M；</li>
<li>SET命令选项：SET TESTKEY “TESTVALUE” nx/xx,nx代表如果键已存在，则SET失败；反之xx表示，如果键已存在则成功；</li>
<li>INCR TESTKEY：将string作为int值累加一并保存新值，DECR减； INCRBY TESTKEY 10：加10，DECRBY减； （其实是同一个底层命令不同表示方式）；</li>
<li>GETSET：先获取旧值后设置新值（有点儿像<code>i++</code>）；</li>
<li>MSET A 10 B 20 C 30;MGET A B C;MSET或MGET（返回一个Array）同时操作多个键值对ABC；</li>
</ul>
<h2 id="6-Redis-expires（有效期）"><a href="#6-Redis-expires（有效期）" class="headerlink" title="6 Redis expires（有效期）"></a>6 Redis expires（有效期）</h2><ol>
<li>精度可以说秒或毫秒；</li>
<li>本质上精度都是毫秒；</li>
<li>当Redis server停止时，过期的数据也会保存到磁盘中，Redis只是给key加了个有效期的属性；</li>
</ol>
<h2 id="7-Redis-Lists"><a href="#7-Redis-Lists" class="headerlink" title="7 Redis Lists"></a>7 Redis Lists</h2><h3 id="7-1-注意区分链表（Linked-Lists）和数组（Array）。"><a href="#7-1-注意区分链表（Linked-Lists）和数组（Array）。" class="headerlink" title="7.1 注意区分链表（Linked Lists）和数组（Array）。"></a>7.1 注意区分链表（Linked Lists）和数组（Array）。</h3><ul>
<li>Redis Lists本质是链表，在存储上不连续，优点插入时间复杂度为常量即O(1)，缺点索引查找O(n)。</li>
<li>数组指一系列元素的集合，在存储上是连续的，优点索引查找时间复杂度为常量即O(1)，缺点插入O(n)。</li>
</ul>
<h3 id="7-2-适用场景"><a href="#7-2-适用场景" class="headerlink" title="7.2 适用场景"></a>7.2 适用场景</h3><ol>
<li>记录社交网络最后一个提交更新；</li>
<li>消息队列等；</li>
</ol>
<h2 id="8-Bitmaps（位图不是一个确切的数据类型）"><a href="#8-Bitmaps（位图不是一个确切的数据类型）" class="headerlink" title="8 Bitmaps（位图不是一个确切的数据类型）"></a>8 Bitmaps（位图不是一个确切的数据类型）</h2><ol>
<li>SETBIT BITKEY 10 1，设置BITKEY键的值的第10位为1；</li>
<li>GETBIT BITKEY 10，获取BITKEY键的值的第10位；</li>
</ol>
<h3 id="8-1-适用场景"><a href="#8-1-适用场景" class="headerlink" title="8.1 适用场景"></a>8.1 适用场景</h3><ol>
<li>任何实时分析情况；</li>
<li>高效高性能存储boolean信息，通过各位0或1直接判断各种状态；</li>
</ol>
<h2 id="9-HyperLogLogs-估算各类分布概率"><a href="#9-HyperLogLogs-估算各类分布概率" class="headerlink" title="9 HyperLogLogs(估算各类分布概率)"></a>9 HyperLogLogs(估算各类分布概率)</h2><ol>
<li>PFADD HLLTEST a b c d；插入元素；</li>
<li>PFCOUNT HLLTEST；查询个数</li>
</ol>
<h3 id="9-1-适用场景"><a href="#9-1-适用场景" class="headerlink" title="9.1 适用场景"></a>9.1 适用场景</h3><ol>
<li>例如统计每天用户查询不同关键词的数目</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://try.redis.io/" target="_blank" rel="external">redis入门</a><br>2 <a href="https://redis.io/topics/data-types-intro" target="_blank" rel="external">介绍Redis数据结构和抽象</a></p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-02.BUILDER（生成器）— 对象创建型模式]]></title>
      <url>/2017/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-02%E5%BB%BA%E9%80%A0%E8%80%85/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>无</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>一个RTF（Rich Text Format）文档交换格式的阅读器应能将 RTF 转换为多种正文格式。该阅读器可以将 RTF 文档转换成普通 ASCII 文本或转换成一个能以交互方式编辑的正文窗口组件。但问题在于可能转换的数目是无限的。因此要能够很容易实现新的转换的增加，同时却不改变 RTF 阅读器。<br><img src="/images/posts/建造者1.jpg" alt="图一"></p>
<a id="more"></a>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
<li>当构造过程必须允许被构造的对象有不同的表示时。</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/建造者2.jpg" alt="图二"></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul>
<li>Builder（TextConverter）<ul>
<li>为创建一个 Product 对象的各个部件指定抽象接口。</li>
</ul>
</li>
<li>ConcreteBuilder（ASCIIConverter、TeXConverter、TextWidgetConverter）<ul>
<li>实现Builder的接口以构造和装配该产品的各个部件；</li>
<li>定义并明确它所创建的表示；</li>
<li>提供一个检索产品的接口（例如，GetASCIIText和GetTextWidget）。</li>
</ul>
</li>
<li>Director（RTFReader）<ul>
<li>构造一个使用Builder接口的对象。</li>
</ul>
</li>
<li>Product（ASCIIText、TeXText、TextWidget）<ul>
<li>表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程；</li>
<li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><ul>
<li>客户创建 Director 对象，并用它所想要的 Builder 对象进行配置。</li>
<li>一旦产品部件被生成，导向器就会通知生成器。</li>
<li>生成器处理导向器的请求，并将部件添加到该产品中。</li>
<li>客户从生成器中检索产品。</li>
</ul>
<p>下面的交互图说明了Builder和Director是如何与一个客户协作的。<br><img src="/images/posts/建造者3.jpg" alt="图二"></p>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul>
<li>它使你可以改变一个产品的内部表示</li>
<li>它将构造代码和表示代码分开</li>
<li>它使你可对构造过程进行更精细的控制 </li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul>
<li>装配和构造接口</li>
<li>为什么产品没有抽象类</li>
<li>在 Builder 中缺省的方法为空</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul>
<li><p>Builder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">interface IBuilder</div><div class="line">&#123;</div><div class="line">    void BuildPart1();</div><div class="line">    void BuildPart2();</div><div class="line">    void BuildPart3();</div><div class="line"></div><div class="line">    Product GetProduct();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ConcreteBuilder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Product1Builder:IBuilder</div><div class="line">&#123;</div><div class="line">    public void BuildPart1()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;Product1 Part1 Build Success!&quot;);</div><div class="line">    &#125;</div><div class="line">    public void BuildPart2()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;Product1 Part2 Build Success!&quot;);</div><div class="line">    &#125;</div><div class="line">    public void BuildPart3()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;Product1 Part3 Build Success!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Product GetProduct()</div><div class="line">    &#123;</div><div class="line">        return new Product(&quot;Product1&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Product2Builder:IBuilder</div><div class="line">&#123;</div><div class="line">    public void BuildPart1()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;Product2 Part1 Build Success!&quot;);</div><div class="line">    &#125;</div><div class="line">    public void BuildPart2()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;Product2 Part2 Build Success!&quot;);</div><div class="line">    &#125;</div><div class="line">    public void BuildPart3()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;Product2 Part3 Build Success!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Product GetProduct()</div><div class="line">    &#123;</div><div class="line">        return new Product(&quot;Product2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Director</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Director</div><div class="line">&#123;</div><div class="line">   Product CreateProduct(IBuilder builder)</div><div class="line">   &#123;</div><div class="line">        builder.BuildPart1();</div><div class="line">        builder.BuildPart2();</div><div class="line">        builder.BuildPart3();</div><div class="line"></div><div class="line">        return builder.GetProduct();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Product</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Product</div><div class="line">&#123;</div><div class="line">    public Product(string name)</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;产品名称：&#123;name&#125;&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Main</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Program</div><div class="line">&#123;</div><div class="line">    public static void Main(string[] args)</div><div class="line">    &#123;</div><div class="line">        IBuilder builder=new Product1Builder();</div><div class="line"></div><div class="line">        Director director=new Director();</div><div class="line">        Product product=director.CreateProduct(builder);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><ul>
<li>RTF转换器</li>
<li>ASP.NET CORE的MvcWebApplicationBuilder</li>
</ul>
<h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul>
<li>AbstractFactory 与 Builder 相似，因为它也可以创建复杂对象。主要的区别是 Builder 模式着重于一步步构造一个复杂对象。而AbstractFactory着重于多个系列的产品对象（简单的或是复杂的）。Builder 在最后的一步返回产品，而对于 AbstractFactory 来说，产品是立即返回的。</li>
<li>Composite 通常是用 Builder 生成的。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-01.ABSTRACT FACTORY（抽象工厂）— 对象创建型模式]]></title>
      <url>/2017/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>Kit</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>考虑一个支持多种视感（look - and - feel）标准的用户界面工具包，例如 Motif 和 Presentation Manager。不同的视感风格为诸如滚动条、窗口和按钮等用户界面“窗口组件”定义不同的外观和行为。为保证视感风格标准间的可移植性，一个应用不应该为一个特定的视感外观硬编码它的窗口组件。在整个应用中实例化特定视感风格的窗口组件类将使得以后很难改变视感风格。<br><img src="/images/posts/抽象工厂1.jpg" alt="图一"></p>
<a id="more"></a>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul>
<li>一个系统要独立于它的产品的创建、组合和表示时。</li>
<li>一个系统要由多个产品系列中的一个来配置时。</li>
<li>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</li>
<li>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/抽象工厂2.jpg" alt="图二"></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul>
<li>AbstractFactory（WidgetFactory）：声明一个创建抽象产品对象的操作接口。</li>
<li>ConcreteFactory（MotifWidgetFactory，PMWidgetFactory）：实现创建具体产品对象的操作。</li>
<li>AbstractProduct（Windows，ScrollBar）：—为一类产品对象声明一个接口。</li>
<li>ConcreteProduct（MotifWindow，MotifScrollBar）：定义一个将被相应的具体工厂创建的产品对象，实现AbstractProduct接口。</li>
<li>Client：仅使用由AbstractFactory和AbstractProduct类声明的接口</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><ul>
<li>通常在运行时刻创建一个 ConcreteFactroy 类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。</li>
<li>AbstractFactory 将产品对象的创建延迟到它的 ConcreteFactory 子类。</li>
</ul>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul>
<li><strong>它分离了具体的类（利）</strong>AbstractFactory 模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，它将客户与类的实现分离。客户通过它们的抽象接口操纵实例。产品的类名也在具体工厂的实现中被分离；它们不出现在客户代码中。</li>
<li><strong>它使得易于交换产品系列（利）</strong>一个具体工厂类在一个应用中仅出现一次 — 即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。</li>
<li><strong>它有利于产品的一致性（利）</strong>当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而 AbstractFactory 很容易实现这一点。</li>
<li><strong>难以支持新种类的产品（弊）</strong>难以扩展抽象工厂以生产新种类的产品。这是因为AbstractFactory 接口确定了可以被创建的产品集合。支持新种类的产品就需要扩展该工厂接口，这将涉及 AbstractFactory 类及其所有子类的改变。</li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul>
<li><strong>将工厂作为单件</strong>一个应用中一般每个产品系列只需一个 ConcreteFactory 的实例。因此工厂通常最好实现为一个 Singleton。</li>
<li><strong>创建产品</strong>AbstractFactory 仅声明一个创建产品的接口，真正创建产品是由 ConcreteProduct 子类实现的。最通常的一个办法是为每一个产品定义一个工厂方法（FactoryMethod）。一个具体的工厂将为每个产品重定义该工厂方法以指定产品。虽然这样的实现很简单，但它却要求每个产品系列都要有一个新的具体工厂子类，即使这些产品系列的差别很小。如果有多个可能的产品系列，具体工厂也可以使用 Prototype 模式来实现。具体工厂使用产品系列中每一个产品的原型实例来初始化，且它通过复制它的原型来创建新的产品。在基于原型的方法中，使得不是每个新的产品系列都需要一个新的具体工厂类。<br>-<strong>定义可扩展的工厂</strong>AbstractFactory 通常为每一种它可以生产的产品定义一个操作。产品的种类被编码在操作型构中。增加一种新的产品要求改变 AbstractFactory 的接口以及所有与它相关的类。一个更灵活但不太安全的设计是给创建对象的操作增加一个参数。该参数指定了将被创建的对象的种类。它可以是一个类标识符、一个整数、一个字符串，或其他任何可以标识这种产品的东西。实际上使用这种方法，AbstractFactory 只需要一个 “Make” 操作和一个指示要创建对象的种类的参数。</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul>
<li><p>AbstractFactory（WidgetFactory）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">interface WidgetFactory</div><div class="line">&#123;</div><div class="line">    void CreateWindow();</div><div class="line">    void CreateScrollBar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ConcreteFactory（MotifWidgetFactory，PMWidgetFactory）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class MotifWidgetFactory:WidgetFactory</div><div class="line">&#123;</div><div class="line">    void CreateWindow()</div><div class="line">    &#123;</div><div class="line">        Window w=new MotifWindow();        </div><div class="line">    &#125;</div><div class="line">    void CreateScrollBar()</div><div class="line">    &#123;</div><div class="line">        ScrollBar sb=new MotifScrollBar();        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class PMWidgetFactory:WidgetFactory</div><div class="line">&#123;</div><div class="line">    void CreateWindow()</div><div class="line">    &#123;</div><div class="line">        Window w=new PMWindow();        </div><div class="line">    &#125;</div><div class="line">    void CreateScrollBar()</div><div class="line">    &#123;</div><div class="line">        ScrollBar sb=new PMScrollBar();        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>AbstractProduct（Windows，ScrollBar）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">interface Windows&#123;&#125;</div><div class="line">interface ScrollBar&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ConcreteProduct（MotifWindow，PMWindow，MotifScrollBar，PMScrollBar）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class MotifWindow:Windows</div><div class="line">&#123;</div><div class="line">    public MotifWindow()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;MotifWindow&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class PMWindow:Windows</div><div class="line">&#123;</div><div class="line">    public PMWindow()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;PMWindow&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class MotifScrollBar:ScrollBar</div><div class="line">&#123;</div><div class="line">    public MotifScrollBar()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;MotifScrollBar&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class PMScrollBar:ScrollBar</div><div class="line">&#123;</div><div class="line">    public PMScrollBar()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;PMScrollBar&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Client：仅使用由AbstractFactory和AbstractProduct类声明的接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Client</div><div class="line">&#123;</div><div class="line">    WidgetFactory factory=new MotifWidgetFactory();</div><div class="line">    factory.CreateWindow();</div><div class="line">    factory.CreateScrollBar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>InterView 使用 “Kit” 后缀 [Lin92] 来表示 AbstractFactory 类。它定义 WidgetKit 和 DialogKit 抽象工厂来生成与特定视感风格相关的用户界面对象。InterView 还包括一个 LayoutKit，它根据所需要的布局生成不同的组成（composition）对象。</p>
<h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul>
<li>AbstractFactory 类通常用工厂方法（FactoryMethod）实现，但它们也可以用 Prototype 实现。</li>
<li>一个具体的工厂通常是一个单件（Singleton）。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面向对象设计原则]]></title>
      <url>/2017/09/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h2 id="1-针对接口编程，而不是针对实现编程。"><a href="#1-针对接口编程，而不是针对实现编程。" class="headerlink" title="1.针对接口编程，而不是针对实现编程。"></a>1.针对接口编程，而不是针对实现编程。</h2><h2 id="2-优先使用对象组合，而不是类继承。"><a href="#2-优先使用对象组合，而不是类继承。" class="headerlink" title="2.优先使用对象组合，而不是类继承。"></a>2.优先使用对象组合，而不是类继承。</h2><h2 id="3-SOLID原则"><a href="#3-SOLID原则" class="headerlink" title="3.SOLID原则"></a>3.SOLID原则</h2><ul>
<li><strong>S（SRP，The Single Responsibility Principle，单一责任原则）</strong>：就一个类而言，应该只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，也会影响复用性。</li>
<li><strong>O（OCP，Open-Closed Principle，开闭原则）</strong>：一个软件实体（指的类、函数、模块等）应该对扩展开放，对修改关闭。即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。　　符合开闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。</li>
<li><strong>L（LSP，Liskov Substitution Principle，里氏代替原则）</strong>：指的是子类必须替换掉它们的父类型。也就是说，在软件开发过程中，子类替换父类后，程序的行为是一样的。只有当子类替换掉父类后，此时软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。</li>
<li><strong>I（ISP，Interface Segregation Principle，接口隔离原则）</strong>：使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。</li>
<li><strong>D（DIP，Dependence Inversion Principle，依赖倒置原则）</strong>： 高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象，也就是提出的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。</li>
</ul>
<h2 id="4-合成复用原则（Composite-Reuse-Principle-CRP）"><a href="#4-合成复用原则（Composite-Reuse-Principle-CRP）" class="headerlink" title="4.合成复用原则（Composite Reuse Principle, CRP）"></a>4.合成复用原则（Composite Reuse Principle, CRP）</h2><p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。</p>
<h2 id="5-迪米特法则（Law-of-Demeter，LoD）又名最少知识原则（Least-Knowledge-Principle，LKP）"><a href="#5-迪米特法则（Law-of-Demeter，LoD）又名最少知识原则（Least-Knowledge-Principle，LKP）" class="headerlink" title="5.迪米特法则（Law of Demeter，LoD）又名最少知识原则（Least Knowledge Principle，LKP）"></a>5.迪米特法则（Law of Demeter，LoD）又名最少知识原则（Least Knowledge Principle，LKP）</h2><p>一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。关于迪米特法则其他的一些表述有：只与你直接的朋友们通信；不要跟“陌生人”说话。外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-总体介绍]]></title>
      <url>/2017/08/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1 总体介绍"></a>1 总体介绍</h2><h3 id="1-1-什么是设计模式"><a href="#1-1-什么是设计模式" class="headerlink" title="1.1 什么是设计模式"></a>1.1 什么是设计模式</h3><div class="note info"><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。- Christopher Alexander </p></div>
<div class="note info"><p>对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。- GoF</p></div>
<p>四个基本要素：</p>
<ol>
<li><strong>模式名称（pattern name）</strong> 一个助记名，它用一两个词来描述模式的问题、解决方案和效果。命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。基于一个模式词汇表，我们自己以及同事之间就可以讨论模式并在编写文档时使用它们。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果。找到恰当的模式名也是我们设计模式编目工作的难点之一。</li>
<li><strong>问题(problem)</strong> 描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等。也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。</li>
<li><strong>解决方案(solution)</strong> 描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</li>
<li><strong>效果(consequences)</strong> 描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</li>
</ol>
<a id="more"></a>
<h3 id="1-2-描述设计模式"><a href="#1-2-描述设计模式" class="headerlink" title="1.2 描述设计模式"></a>1.2 描述设计模式</h3><ul>
<li><strong>模式名和分类</strong>模式名简洁地描述了模式的本质。</li>
<li><strong>意图</strong>是回答下列问题的简单陈述：设计模式是做什么的？它的基本原理和意图是什么？它解决的是什么样的特定设计问题？</li>
<li><strong>别名</strong>模式的其他名称。</li>
<li><strong>动机</strong>用以说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景。</li>
<li><strong>适用性</strong>什么情况下可以使用该设计模式？该模式可用来改进哪些不良设计？你怎样识别这些情况？</li>
<li><strong>结构</strong>采用基于对象建模技术的表示法对模式中的类进行图形描述。</li>
<li><strong>参与者</strong>指设计模式中的类和/或对象以及它们各自的职责。</li>
<li><strong>协作</strong>模式的参与者怎样协作以实现它们的职责。</li>
<li><strong>效果</strong>模式怎样支持它的目标？使用模式的效果和所需做的权衡取舍？系统结构的哪些方面可以独立改变？</li>
<li><strong>实现</strong>实现模式时需要知道的一些提示、技术要点及应避免的缺陷，以及是否存在某些特定于实现语言的问题。</li>
<li><strong>代码示例</strong>实现该模式的代码片段。</li>
<li><strong>已知应用</strong>实际系统中发现的模式的例子。</li>
<li><strong>相关模式</strong>与这个模式紧密相关的模式有哪些？其间重要的不同之处是什么？这个模式应与哪些其他模式一起使用？</li>
</ul>
<h3 id="1-3-设计模式怎样解决设计问题"><a href="#1-3-设计模式怎样解决设计问题" class="headerlink" title="1.3 设计模式怎样解决设计问题"></a>1.3 设计模式怎样解决设计问题</h3><ol>
<li><strong>寻找合适的对象</strong></li>
<li><strong>决定对象的粒度</strong></li>
<li><strong>指定对象接口</strong></li>
<li><strong>描述对象的实现</strong></li>
<li><strong>运用复用机制</strong></li>
<li><strong>关联运行时刻和编译时刻</strong></li>
<li><strong>设计应支持变化</strong></li>
</ol>
<h3 id="1-4-导致重新设计的一般原因，以及解决这些问题的设计模式"><a href="#1-4-导致重新设计的一般原因，以及解决这些问题的设计模式" class="headerlink" title="1.4 导致重新设计的一般原因，以及解决这些问题的设计模式"></a>1.4 导致重新设计的一般原因，以及解决这些问题的设计模式</h3><ol>
<li><strong>通过显式地指定一个类来创建对象</strong>在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象。<br>设计模式：Abstract Factory， Factory Method，Prototype。</li>
<li><strong>对特殊操作的依赖</strong> 当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方法。<br>设计模式：Chain of Resposibility，Command。</li>
<li><strong>对硬件和软件平台的依赖</strong> 外部的操作系统接口和应用编程接口(API)在不同的软硬件平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。<br>设计模式：Abstract Factory， Bridge。</li>
<li><strong>对对象表示或实现的依赖</strong>知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。<br>设计模式：Abstract Factory，Bridge，Memento，Proxy</li>
<li><strong>算法依赖</strong> 算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。<br>设计模式：Builder，Iterator，Strategy，Template Method，Visitor</li>
<li><strong>紧耦合</strong> 紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。<br>设计模式：Abstract Factory，Command，Facade，Mediator，Observer，Chain of Responsibility。</li>
<li><strong>通过生成子类来扩充功能</strong> 通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销(初始化、终止处理等 )。定义子类还需要对父类有深入的了解。如，重定义一个操作可能需要重定义其他操作。一个被重定义的操作可能需要调用继承下来的操作。并且子类方法会导致类爆炸，因为即使对于一个简单的扩充，你也不得不引入许多新的子类。一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。另一方面，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能。<br>设计模式：Bridge，Chain of Responsibility，Composite，Decorator，Observer，Strategy。</li>
<li><strong>不能方便地对类进行修改</strong> 有时你不得不改变一个难以修改的类。也许你需要源代码而又没有(对于商业类库就有这种情况 )，或者可能对类的任何改变会要求修改许多已存在的其他子类。设计模式提供在这些情况下对类进行修改的方法。<br>设计模式：Adapter，Decorator，Visitor。</li>
</ol>
<h3 id="1-5-怎样选择设计模式"><a href="#1-5-怎样选择设计模式" class="headerlink" title="1.5 怎样选择设计模式"></a>1.5 怎样选择设计模式</h3><ul>
<li>考虑设计模式是怎样解决设计问题的</li>
<li>浏览模式的意图部分 </li>
<li>研究模式怎样互相关联 </li>
<li>研究目的相似的模式 </li>
<li>检查重新设计的原因</li>
<li>考虑你的设计中哪些是可变的 </li>
</ul>
<h3 id="1-6-怎样使用设计模式"><a href="#1-6-怎样使用设计模式" class="headerlink" title="1.6 怎样使用设计模式"></a>1.6 怎样使用设计模式</h3><ol>
<li><strong>大致浏览一遍模式</strong>特别注意其适用性部分和效果部分，确定它适合你的问题。</li>
<li><strong>回头研究结构部分、参与者部分和协作部分</strong>确保你理解这个模式的类和对象以及它们是怎样关联的。</li>
<li><strong>看代码示例部分，看看这个模式代码形式的具体例子</strong>研究代码将有助于你实现模式。</li>
<li><strong>选择模式参与者的名字，使它们在应用上下文中有意义</strong>设计模式参与者的名字通常过于抽象而不会直接出现在应用中。然而，将参与者的名字和应用中出现的名字合并起来是很有用的。这会帮助你在实现中更显式的体现出模式来。例如，如果你在文本组合算法中使用了 Strategy 模式，那么你可能有名为 SimpleLayout Strategy 或 TeX Layout Strategy 这样的类。</li>
<li><strong>定义类</strong>声明它们的接口，建立它们的继承关系，定义代表数据和对象引用的实例变量。识别模式会影响到的你的应用中存在的类，做出相应的修改。</li>
<li><strong>定义模式中专用于应用的操作名称</strong>这里再一次体现出，名字一般依赖于应用。使用与每一个操作相关联的责任和协作作为指导。还有，你的名字约定要一致。例如，可以使用“Create-”前缀统一标记 Factory 方法。</li>
<li><strong>实现执行模式中责任和协作的操作</strong>实现部分提供线索指导你进行实现。代码示例部分的例子也能提供帮助。</li>
</ol>
<h2 id="2-目录"><a href="#2-目录" class="headerlink" title="2 目录"></a>2 目录</h2><p>按目的准则（即模式是用来完成什么工作）分类：<br><em>注</em>：第二个（）表示范围准则，指定模式主要是用于类还是用于对象。类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。从某种意义上来说，几乎所有模式都使用继承机制，所以“类模式”只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。</p>
<h3 id="2-1-创建型"><a href="#2-1-创建型" class="headerlink" title="2.1 创建型"></a>2.1 创建型</h3><p>创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。</p>
<h4 id="2-1-1-抽象工厂（Abstract-Factory）（对象）"><a href="#2-1-1-抽象工厂（Abstract-Factory）（对象）" class="headerlink" title="2.1.1 抽象工厂（Abstract Factory）（对象）"></a>2.1.1 <a href="http://www.venux.cn/2017/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/#more">抽象工厂（Abstract Factory）（对象）</a></h4><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<h4 id="2-1-2-建造者（Builder）（对象）"><a href="#2-1-2-建造者（Builder）（对象）" class="headerlink" title="2.1.2 建造者（Builder）（对象）"></a>2.1.2 <a href="">建造者（Builder）（对象）</a></h4><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h4 id="2-1-3-工厂方法（Factory-Method）（类）"><a href="#2-1-3-工厂方法（Factory-Method）（类）" class="headerlink" title="2.1.3 工厂方法（Factory Method）（类）"></a>2.1.3 <a href="">工厂方法（Factory Method）（类）</a></h4><p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。</p>
<h4 id="2-1-4-原型（Prototype）（对象）"><a href="#2-1-4-原型（Prototype）（对象）" class="headerlink" title="2.1.4 原型（Prototype）（对象）"></a>2.1.4 <a href="">原型（Prototype）（对象）</a></h4><p>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</p>
<h4 id="2-1-5-单例（Singleton）（对象）"><a href="#2-1-5-单例（Singleton）（对象）" class="headerlink" title="2.1.5 单例（Singleton）（对象）"></a>2.1.5 <a href="">单例（Singleton）（对象）</a></h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h3 id="2-2-结构型"><a href="#2-2-结构型" class="headerlink" title="2.2 结构型"></a>2.2 结构型</h3><p>结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。</p>
<h4 id="2-2-1-适配器（Adapter）（类、对象）"><a href="#2-2-1-适配器（Adapter）（类、对象）" class="headerlink" title="2.2.1 适配器（Adapter）（类、对象）"></a>2.2.1 <a href="">适配器（Adapter）（类、对象）</a></h4><p>将一个类的接口转换成客户希望的另外一个接口。 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h4 id="2-2-2-桥接（Bridge）（对象）"><a href="#2-2-2-桥接（Bridge）（对象）" class="headerlink" title="2.2.2 桥接（Bridge）（对象）"></a>2.2.2 <a href="">桥接（Bridge）（对象）</a></h4><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<h4 id="2-2-3-组合（Composite）（对象）"><a href="#2-2-3-组合（Composite）（对象）" class="headerlink" title="2.2.3 组合（Composite）（对象）"></a>2.2.3 <a href="">组合（Composite）（对象）</a></h4><p>将对象组合成树形结构以表示“部分 -整体”的层次结构。 Composite 使得客户对单个对象和复合对象的使用具有一致性。</p>
<h4 id="2-2-4-装饰者（Decorator）（对象）"><a href="#2-2-4-装饰者（Decorator）（对象）" class="headerlink" title="2.2.4 装饰者（Decorator）（对象）"></a>2.2.4 <a href="">装饰者（Decorator）（对象）</a></h4><p>动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator 模式比生成子类方式更为灵活。</p>
<h4 id="2-2-5-外观（Facade）（对象）"><a href="#2-2-5-外观（Facade）（对象）" class="headerlink" title="2.2.5 外观（Facade）（对象）"></a>2.2.5 <a href="">外观（Facade）（对象）</a></h4><p>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<h4 id="2-2-6-享元（Flyweight）（对象）"><a href="#2-2-6-享元（Flyweight）（对象）" class="headerlink" title="2.2.6 享元（Flyweight）（对象）"></a>2.2.6 <a href="">享元（Flyweight）（对象）</a></h4><p>运用共享技术有效地支持大量细粒度的对象</p>
<h4 id="2-2-7-代理（Proxy）（对象）"><a href="#2-2-7-代理（Proxy）（对象）" class="headerlink" title="2.2.7 代理（Proxy）（对象）"></a>2.2.7 <a href="">代理（Proxy）（对象）</a></h4><p>为其他对象提供一个代理以控制对这个对象的访问。</p>
<h3 id="2-3-行为型"><a href="#2-3-行为型" class="headerlink" title="2.3 行为型"></a>2.3 行为型</h3><p>行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的任务。</p>
<h4 id="2-3-1-责任链（Chain-of-Responsibility）（对象）"><a href="#2-3-1-责任链（Chain-of-Responsibility）（对象）" class="headerlink" title="2.3.1 责任链（Chain of Responsibility）（对象）"></a>2.3.1 <a href="">责任链（Chain of Responsibility）（对象）</a></h4><p>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</p>
<h4 id="2-3-2-命令（Command）（对象）"><a href="#2-3-2-命令（Command）（对象）" class="headerlink" title="2.3.2 命令（Command）（对象）"></a>2.3.2 <a href="">命令（Command）（对象）</a></h4><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</p>
<h4 id="2-3-3-解释器（Interpreter）（类）"><a href="#2-3-3-解释器（Interpreter）（类）" class="headerlink" title="2.3.3 解释器（Interpreter）（类）"></a>2.3.3 <a href="">解释器（Interpreter）（类）</a></h4><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p>
<h4 id="2-3-4-迭代器（Iterator）（对象）"><a href="#2-3-4-迭代器（Iterator）（对象）" class="headerlink" title="2.3.4 迭代器（Iterator）（对象）"></a>2.3.4 <a href="">迭代器（Iterator）（对象）</a></h4><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</p>
<h4 id="2-3-5-中介者（Mediator）（对象）"><a href="#2-3-5-中介者（Mediator）（对象）" class="headerlink" title="2.3.5 中介者（Mediator）（对象）"></a>2.3.5 <a href="">中介者（Mediator）（对象）</a></h4><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<h4 id="2-3-6-备忘录（Memento）（对象）"><a href="#2-3-6-备忘录（Memento）（对象）" class="headerlink" title="2.3.6 备忘录（Memento）（对象）"></a>2.3.6 <a href="">备忘录（Memento）（对象）</a></h4><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态</p>
<h4 id="2-3-7-观察者（Observer）（对象）"><a href="#2-3-7-观察者（Observer）（对象）" class="headerlink" title="2.3.7 观察者（Observer）（对象）"></a>2.3.7 <a href="">观察者（Observer）（对象）</a></h4><p>定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</p>
<h4 id="2-3-8-状态（State）（对象）"><a href="#2-3-8-状态（State）（对象）" class="headerlink" title="2.3.8 状态（State）（对象）"></a>2.3.8 <a href="">状态（State）（对象）</a></h4><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</p>
<h4 id="2-3-9-策略（Strategy）（对象）"><a href="#2-3-9-策略（Strategy）（对象）" class="headerlink" title="2.3.9 策略（Strategy）（对象）"></a>2.3.9 <a href="">策略（Strategy）（对象）</a></h4><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</p>
<h4 id="2-3-10-模板方法（Template-Method）（类）"><a href="#2-3-10-模板方法（Template-Method）（类）" class="headerlink" title="2.3.10 模板方法（Template Method）（类）"></a>2.3.10 <a href="">模板方法（Template Method）（类）</a></h4><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<h4 id="2-3-11-访问者（Visitor）（对象）"><a href="#2-3-11-访问者（Visitor）（对象）" class="headerlink" title="2.3.11 访问者（Visitor）（对象）"></a>2.3.11 <a href="">访问者（Visitor）（对象）</a></h4><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<h2 id="3-设计模式相关图表"><a href="#3-设计模式相关图表" class="headerlink" title="3 设计模式相关图表"></a>3 设计模式相关图表</h2><p><img src="/images/posts/设计模式关系图.jpg" alt="设计模式关系图"><br><img src="/images/posts/设计模式可变性.jpg" alt="设计模式可变性"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1 设计模式 - 可复用面向对象软件的基础（第一章：引言）</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多环境工作]]></title>
      <url>/2017/08/31/Environment/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>ASP.NET Core 通过多环境控制 APP 的行为，例如 development，staging 和 production。环境变量决定了运行环境，从而根据不同环境采用不同配置。</p>
<a id="more"></a>
<h2 id="2-ASPNETCORE-ENVIRONMENT-环境变量"><a href="#2-ASPNETCORE-ENVIRONMENT-环境变量" class="headerlink" title="2.ASPNETCORE_ENVIRONMENT 环境变量"></a>2.ASPNETCORE_ENVIRONMENT 环境变量</h2><ul>
<li>Development 开发环境</li>
<li>Staging 预发布、部署上线前的最终测试环境、生产环境的物理镜像</li>
<li>Production 生产环境（安全性、高性能、稳健性）<ul>
<li>开启缓存</li>
<li>客户端资源 <code>bundled</code>，<code>minified</code> 或 <code>CDN</code></li>
<li>关闭 <code>diagnostic ErrorPages</code></li>
<li>开启 <code>friendly error pages</code></li>
<li>开启 <code>production logging</code> 和 <code>monitoring</code></li>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h2><ul>
<li>Windows 不区分大小写，Linux 默认区分大小写。</li>
<li>设置：右键项目属性-调试-环境变量，另在 <code>~\Properties\launchSettings.json</code> 可看到具体配置。<ul>
<li>launchSettings.json 存储的变量可访问到，不安全，禁止存放加密信息，使用 <code>Secret Manager</code> 存放加密信息。 </li>
</ul>
</li>
<li>本机设置<ul>
<li>临时：<code>set ASPNETCORE_ENVIRONMENT=Development</code></li>
<li>永久：环境变量-ASPNETCORE_ENVIRONMENT=Development</li>
</ul>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1 <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/environments" target="_blank" rel="external">多环境工作</a></p>
]]></content>
      
        <categories>
            
            <category> ASP.NET Core </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown笔记]]></title>
      <url>/2017/08/31/Markdown%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-什么是Markdown"><a href="#1-什么是Markdown" class="headerlink" title="1.什么是Markdown"></a>1.什么是Markdown</h2><p>Markdown是一种在web显示带样式风格文本的方式。你能通过它控制文本的字体样式、插入图片、插入列表等。通常，Markdown使用一些特殊的非字母符号来作为语法规则，如<code>#</code>等。你能在Github上大部分地方使用Markdown。比如：</p>
<ul>
<li><a href="https://gist.github.com/" target="_blank" rel="external">Gists</a></li>
<li>Issues的评论、Pull Requests</li>
<li>.md或.markdown后缀名的文件</li>
</ul>
<a id="more"></a>
<h2 id="2-规范"><a href="#2-规范" class="headerlink" title="2.规范"></a>2.规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;span id=&quot;anchorTest&quot;&gt;锚点测试&lt;/span&gt;</div><div class="line"></div><div class="line">1. 这是一个文本；</div><div class="line">2. **粗体**；</div><div class="line">3. *斜体*；</div><div class="line">4. [我的Github](https://github.com/venux)</div><div class="line">5. 列表</div><div class="line">    * 无序列表1</div><div class="line">    - 无序列表2</div><div class="line">        - 无序列表21</div><div class="line">        - 无序列表22</div><div class="line">6. 图片![Image](https://avatars2.githubusercontent.com/u/7089227?v=3&amp;s=460)</div><div class="line">7. 引用</div><div class="line"></div><div class="line">&gt;Hello,World!-Coder</div><div class="line"></div><div class="line"># H1</div><div class="line">## H2</div><div class="line">### H3</div><div class="line">#### H4</div><div class="line">##### H5</div><div class="line">###### H6</div><div class="line"></div><div class="line">I think you should use an `&lt;addr&gt;` element here instead.</div></pre></td></tr></table></figure>
<h2 id="3-Github特殊风格"><a href="#3-Github特殊风格" class="headerlink" title="3.Github特殊风格"></a>3.Github特殊风格</h2><h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">args</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(args)&#123;</div><div class="line">        <span class="built_in">console</span>.log(args);</div><div class="line">    &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Test</div><div class="line">&#123;</div><div class="line">    static void Main()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;Hello,World!&quot;);		</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><ul>
<li style="list-style: none"><input type="checkbox" checked> 1. 已完成任务，支持列表，@mentions, #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported</li>
<li style="list-style: none"><input type="checkbox"> 2. 未完成任务</li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th>表头一</th>
<th>表头2</th>
</tr>
</thead>
<tbody>
<tr>
<td>11</td>
<td>12</td>
</tr>
<tr>
<td>21</td>
<td>22</td>
</tr>
</tbody>
</table>
<h3 id="SHA引用"><a href="#SHA引用" class="headerlink" title="SHA引用"></a>SHA引用</h3><p>5e0b770018f87bd7fafecb7b3920cda8a30d4740</p>
<h3 id="Issue引用"><a href="#Issue引用" class="headerlink" title="Issue引用"></a>Issue引用</h3><p>#1</p>
<h3 id="圈人"><a href="#圈人" class="headerlink" title="圈人"></a>圈人</h3><p>@venux @CDLL</p>
<h3 id="自动识别网址"><a href="#自动识别网址" class="headerlink" title="自动识别网址"></a>自动识别网址</h3><p><a href="http://www.cnblogs.com" target="_blank" rel="external">http://www.cnblogs.com</a></p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><del>删除</del></p>
<h3 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h3><p>:+1:</p>
<h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p><a href="#anchorTest">锚点测试</a></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git笔记]]></title>
      <url>/2017/08/30/Git%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><p>git init</p>
<h2 id="2-添加到仓库"><a href="#2-添加到仓库" class="headerlink" title="2.添加到仓库"></a>2.添加到仓库</h2><p>git add $filename</p>
<h2 id="3-提交到仓库"><a href="#3-提交到仓库" class="headerlink" title="3.提交到仓库"></a>3.提交到仓库</h2><p>git commit -m “$comment”</p>
<h2 id="4-查看状态"><a href="#4-查看状态" class="headerlink" title="4.查看状态"></a>4.查看状态</h2><p>git status</p>
<a id="more"></a>
<h2 id="5-对比修改记录"><a href="#5-对比修改记录" class="headerlink" title="5.对比修改记录"></a>5.对比修改记录</h2><p>git diff</p>
<h2 id="6-查看提交日志"><a href="#6-查看提交日志" class="headerlink" title="6.查看提交日志"></a>6.查看提交日志</h2><p>git log </p>
<ul>
<li><code>--pretty=oneline</code>:单行显示</li>
<li><code>--graph</code>：图像显示</li>
<li><code>--abbrev-commit</code>：缩写CommitID</li>
</ul>
<h2 id="7-版本回退"><a href="#7-版本回退" class="headerlink" title="7.版本回退"></a>7.版本回退</h2><p>git reset –hard</p>
<ul>
<li><code>HEAD</code>表示当前版本</li>
<li><code>HEAD^</code>表示上个版本，<code>HEAD^^</code>上上个版本<ul>
<li>git reset –hard HEAD^</li>
<li><strong>注意：^在CMD中需要用双引号括起来</strong></li>
</ul>
</li>
<li><code>HEAD~100</code>上100个版本</li>
<li><code>versionId</code>版本号（可只写前几位）：<ul>
<li>git reset –hard cfab68213adec8795db301414287dfccadb30499</li>
</ul>
</li>
</ul>
<h2 id="8-查看命令历史"><a href="#8-查看命令历史" class="headerlink" title="8.查看命令历史"></a>8.查看命令历史</h2><p>git reflog</p>
<h2 id="9-撤销修改"><a href="#9-撤销修改" class="headerlink" title="9.撤销修改"></a>9.撤销修改</h2><ul>
<li>未添加到暂存区：git checkout – $filename</li>
<li>已添加到暂存区：git reset HEAD $filename</li>
</ul>
<h2 id="10-删除文件"><a href="#10-删除文件" class="headerlink" title="10.删除文件"></a>10.删除文件</h2><p>git rm $filename</p>
<h2 id="11-添加远程库"><a href="#11-添加远程库" class="headerlink" title="11.添加远程库"></a>11.添加远程库</h2><p>git remote add origin $giturl</p>
<ul>
<li>远程库默认名为<code>origin</code></li>
</ul>
<h2 id="12-推送当前分支master到远程库origin"><a href="#12-推送当前分支master到远程库origin" class="headerlink" title="12.推送当前分支master到远程库origin"></a>12.推送当前分支master到远程库origin</h2><p>git push -u origin master</p>
<ul>
<li><code>-u</code>：由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</li>
<li>第二次后就可去掉<code>-u</code>参数直接推送。</li>
</ul>
<h2 id="13-克隆"><a href="#13-克隆" class="headerlink" title="13.克隆"></a>13.克隆</h2><p>git clone $giturl</p>
<h2 id="14-创建分支"><a href="#14-创建分支" class="headerlink" title="14.创建分支"></a>14.创建分支</h2><p>git branch $branchname</p>
<h2 id="15-切换分支"><a href="#15-切换分支" class="headerlink" title="15.切换分支"></a>15.切换分支</h2><p>git checkout $branchname</p>
<h2 id="16-创建并切换分支"><a href="#16-创建并切换分支" class="headerlink" title="16.创建并切换分支"></a>16.创建并切换分支</h2><p>git checkout -b $branchname</p>
<ul>
<li><code>-b</code>：表示创建并切换，相当于创建<code>git branch $branchname</code>和切换<code>git checkout $branchname</code>两个命令。</li>
</ul>
<h2 id="17-查看分支"><a href="#17-查看分支" class="headerlink" title="17.查看分支"></a>17.查看分支</h2><p>git branch</p>
<h2 id="18-合并分支"><a href="#18-合并分支" class="headerlink" title="18.合并分支"></a>18.合并分支</h2><p>git merge $branchname</p>
<ul>
<li>合并指定分支到当前分支</li>
<li>合并结果中的<code>Fast-forward</code>表示快进模式，即直接将当前分支的指针指向指定分支的最新提交位置，故非常快。</li>
<li><code>--no-ff</code>：禁用<code>Fast-forward</code>模式，这样会在merge时生成新的commit信息。合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</li>
</ul>
<h2 id="19-删除分支"><a href="#19-删除分支" class="headerlink" title="19.删除分支"></a>19.删除分支</h2><p>git branch -d $branchname</p>
<ul>
<li><code>-d</code>：删除已合并的分支；</li>
<li><code>-D</code>：强制删除未合并的分支（<strong>注意：分支代码无法找回</strong>）。</li>
</ul>
<h2 id="20-解决冲突"><a href="#20-解决冲突" class="headerlink" title="20.解决冲突"></a>20.解决冲突</h2><p>1 多分支同时修改同一个文件后add并commit；<br>2 merge分支时提示冲突；<br>3 修改冲突文件后再次add并commit即可。</p>
<h2 id="21-分支策略"><a href="#21-分支策略" class="headerlink" title="21.分支策略"></a>21.分支策略</h2><p>1 master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>2 dev分支干活，不稳定的.每个人都有自己的分支，时不时地往dev分支上合并就可以了。到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；<br>3 所以，团队合作的分支看起来就像这样：<br><img src="https://www.liaoxuefeng.com/files/attachments/001384909239390d355eb07d9d64305b6322aaf4edac1e3000/0" alt="图1"></p>
<h2 id="22-储藏"><a href="#22-储藏" class="headerlink" title="22.储藏"></a>22.储藏</h2><ul>
<li>git stash：可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</li>
<li>git stash list：查看储藏列表</li>
<li>git stash apply [stash@{n}]：恢复储藏，可选指定储藏</li>
<li>git stash drop [stash@{n}]：删除储藏，可选指定储藏</li>
<li>git stash pop [stash@{n}]：恢复并删除储藏，可选指定储藏</li>
</ul>
<h2 id="23-查看远程分支"><a href="#23-查看远程分支" class="headerlink" title="23.查看远程分支"></a>23.查看远程分支</h2><p>git remote</p>
<ul>
<li><code>-v</code>：显示详细信息</li>
</ul>
<h2 id="24-推送分支"><a href="#24-推送分支" class="headerlink" title="24.推送分支"></a>24.推送分支</h2><p>git push origin $branchname</p>
<ul>
<li>master分支是主分支，因此要时刻与远程同步；</li>
<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<h2 id="25-标签"><a href="#25-标签" class="headerlink" title="25.标签"></a>25.标签</h2><ul>
<li>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</li>
<li>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</li>
<li>增强版本识别，不用通过版本ID判断版本。</li>
</ul>
<h2 id="26-创建标签"><a href="#26-创建标签" class="headerlink" title="26.创建标签"></a>26.创建标签</h2><p>git tag $tagname [$commitid]</p>
<ul>
<li>$commitid：指定给对应的提交记录打上标签，如无则给最新提交的记录加标签。</li>
</ul>
<h2 id="27-查看标签"><a href="#27-查看标签" class="headerlink" title="27.查看标签"></a>27.查看标签</h2><p>git tag [$tagname]</p>
<ul>
<li>$tagname：查看指定标签，如无则查看所有标签。</li>
<li><code>-a</code>：指定标签名，如<code>git tag -a v1.0</code>。</li>
<li><code>-m</code>：指定说明，如<code>git tag -a v1.0 -m &quot;这是第一个发布版本&quot;</code>。</li>
</ul>
<h2 id="28-推送标签"><a href="#28-推送标签" class="headerlink" title="28.推送标签"></a>28.推送标签</h2><p>git push origin $tagname</p>
<h2 id="29-推送所有标签"><a href="#29-推送所有标签" class="headerlink" title="29.推送所有标签"></a>29.推送所有标签</h2><p>git push origin –tags</p>
<h2 id="30-删除标签"><a href="#30-删除标签" class="headerlink" title="30.删除标签"></a>30.删除标签</h2><p>git tag -d $tagname</p>
<h2 id="31-删除远程标签"><a href="#31-删除远程标签" class="headerlink" title="31.删除远程标签"></a>31.删除远程标签</h2><p>git push origin :refs/tags/$tagname</p>
<ul>
<li>要求先删除本地标签</li>
</ul>
<h2 id="32-忽略文件"><a href="#32-忽略文件" class="headerlink" title="32.忽略文件"></a>32.忽略文件</h2><ul>
<li>.gitignore文件<a href="https://github.com/github/gitignore" target="_blank" rel="external">github</a></li>
<li>原则是：<ul>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ul>
</li>
</ul>
<h2 id="33-查看忽略文件"><a href="#33-查看忽略文件" class="headerlink" title="33.查看忽略文件"></a>33.查看忽略文件</h2><p>git check-ignore</p>
<ul>
<li><code>-v</code>：查看忽略规则的详细行数</li>
</ul>
<h2 id="34-命令别名"><a href="#34-命令别名" class="headerlink" title="34.命令别名"></a>34.命令别名</h2><p>git config –global alias.$shortname $name<br><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></p>
<h2 id="35-配置"><a href="#35-配置" class="headerlink" title="35.配置"></a>35.配置</h2><ul>
<li>全局配置文件位置：<code>C:\Users\$username\.gitconfig</code></li>
<li>git config –global user.name <code>value</code></li>
<li>git config –global user.email <code>value</code> </li>
</ul>
<h2 id="36-拉取"><a href="#36-拉取" class="headerlink" title="36.拉取"></a>36.拉取</h2><p>git pull origin master</p>
<ul>
<li>若提示refusing to merge unrelated histories则需添加参数<code>--allow-unrelated-histories</code></li>
</ul>
<h2 id="37-更新fork的repo"><a href="#37-更新fork的repo" class="headerlink" title="37.更新fork的repo"></a>37.更新fork的repo</h2><p>1 <strong>git remote -v</strong><br>查看当前Fork项目已配置的远程仓库（List the current configured remote repository for your fork）<br>2 <strong>git remote add upstream <code>url</code></strong><br>指定将要同步Fork项目的一个远程上游仓库（Specify a new remote upstream repository that will be synced with the fork.）<br>3 <strong>git remote -v</strong><br>再次查看<br>4 <strong>git fetch upstream</strong><br>拉取上游仓库的所有分支和更改记录，mater分支提交记录会在本地分支中保存。（Fetch the branches and their respective commits from the upstream repository. Commits to master will be stored in a local branch, upstream/master.）<br>5 <strong>git checkout master</strong><br>迁出本地master分支（Check out your fork’s local master branch.）<br>6 <strong>git merge upstream/master</strong><br>将上游仓库的master分支更改记录合并到本地master分支中，即同步且不会丢失本地更改记录。（Merge the changes from upstream/master into your local master branch. This brings your fork’s master branch into sync with the upstream repository, without losing your local changes.）</p>
<h2 id="38-添加SSH至Github"><a href="#38-添加SSH至Github" class="headerlink" title="38.添加SSH至Github"></a>38.添加SSH至Github</h2><p>1 <strong>生成</strong><br>ssh-keygen -t rsa -b 4096 -C “your_email@example.com”<br>2 <strong>拷贝</strong><br>将<code>C:\Users\Administrator\.ssh\id_rsa.pub</code>的值添加到Github个人设置的SSH中。<br>3 <strong>检验</strong><br>ssh -T git@github.com</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰git教程</a><br>2 <a href="https://help.github.com/articles/syncing-a-fork/" target="_blank" rel="external">syncing-a-fork</a></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
