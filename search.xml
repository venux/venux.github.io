<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Oracle表名列名长度限制</title>
      <link href="//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E8%A1%A8%E5%90%8D%E5%88%97%E5%90%8D%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/"/>
      <url>//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E8%A1%A8%E5%90%8D%E5%88%97%E5%90%8D%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://blog.csdn.net/haiross/article/details/38379615" target="_blank" rel="noopener">oracle的表名、字段名、constraint名的长度限制分别是多少？</a></p>]]></content>
      
      <categories>
          
          <category> 02.数据库 </category>
          
          <category> 04.Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL比较</title>
      <link href="//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E6%AF%94%E8%BE%83/"/>
      <url>//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://sqlwithmanoj.com/2015/05/03/what-is-sql-plsql-t-sql-and-difference-between-them/" target="_blank" rel="noopener">What is SQL, PL/SQL, T-SQL and difference between them</a></li><li><a href="https://stackoverflow.com/questions/1043265/what-is-the-difference-between-sql-pl-sql-and-t-sql" target="_blank" rel="noopener">What is the difference between SQL, PL-SQL and T-SQL?</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> SQL Server </tag>
            
            <tag> Oracle </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle服务名</title>
      <link href="//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%90%8D/"/>
      <url>//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%90%8D/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>TNS serviceNAME</p><ul><li>格式1：<strong>IP地址:端口号/实例名</strong>，实例192.168.10.5：1521/ORCL；</li><li>格式2：<strong>服务名</strong>，在TNSNAMES.ORA文件配置；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://blog.csdn.net/BlueCY/article/details/76164941" target="_blank" rel="noopener">Oracle ODBC 配置（不需安装oracle客户端）</a></p>]]></content>
      
      <categories>
          
          <category> 02.数据库 </category>
          
          <category> 04.Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle字符集</title>
      <link href="//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
      <url>//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
      <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://blog.csdn.net/meunsina/article/details/53954215" target="_blank" rel="noopener">彻底搞懂Oracle字符集</a><br>2 <a href="https://blog.csdn.net/wstoneh01/article/details/50588720" target="_blank" rel="noopener">正确设置与使用SQL Server的字符集（Collation，即排序规则）</a><br>3 <a href="https://blog.csdn.net/luofujiang/article/details/9030819" target="_blank" rel="noopener">ORA-12704:字符集不匹配错误</a></p>]]></content>
      
      <categories>
          
          <category> 02.数据库 </category>
          
          <category> 04.Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle ODBC配置</title>
      <link href="//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%20ODBC%E9%85%8D%E7%BD%AE/"/>
      <url>//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%20ODBC%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://blog.csdn.net/BlueCY/article/details/76164941" target="_blank" rel="noopener">Oracle ODBC 配置（不需安装oracle客户端）</a></p>]]></content>
      
      <categories>
          
          <category> 02.数据库 </category>
          
          <category> 04.Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQLServer转Oracle</title>
      <link href="//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/SQLServer%E8%BD%ACOracle/"/>
      <url>//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/SQLServer%E8%BD%ACOracle/</url>
      <content type="html"><![CDATA[<h2 id="1-情景"><a href="#1-情景" class="headerlink" title="1. 情景"></a>1. 情景</h2><p>公司项目的新客户数据库为 Oracle，故需将项目的 SQL Server 库转换为 Oracle 库。</p><h2 id="2-工具"><a href="#2-工具" class="headerlink" title="2. 工具"></a>2. 工具</h2><ul><li>SQL Server 自带的 bcm（注意：需将 SQL Server 安装目录下对应版本的 Tools\Binn 目录，如<code>C:\Program Files\Microsoft SQL Server\100\Tools\Binn</code> 添加到环境变量 Path 中）；</li><li><a href="http://download.oracle.com/otn/java/sqldeveloper/sqldeveloper-17.2.0.188.1159-no-jre.zip" target="_blank" rel="noopener">SQL Developer 17.2</a>(注意：需安装配置 Java 8)；</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/db/hol08/sqldev_migration/mssqlserver/migrate_microsoft_sqlserver_otn.htm" target="_blank" rel="noopener">Migrating a Microsoft SQL Server Database to Oracle Database 11g</a></li><li><a href="https://blog.csdn.net/rootcn/article/details/8894130" target="_blank" rel="noopener">用 SQL Developer 3.2 将 SQL Server 2008 数据库离线迁移到 Oracle 11g</a></li><li><a href="https://www.cnblogs.com/benbenfishfish/p/8675075.html" target="_blank" rel="noopener">Oracle和sqlserver数据类型对应</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> SQL Server </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>12.重构-总结</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/12.%E9%87%8D%E6%9E%84-%E6%80%BB%E7%BB%93/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/12.%E9%87%8D%E6%9E%84-%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>前面的篇幅只是一个介绍，一个起点，如果没有这些技术，就无法对程序进行改动。有了这些技术，你仍然做不到，但起码可以开始尝试。</p><ul><li>何时应该使用、何时不应该使用；</li><li>何时开始、何时停止；</li><li>何时前进、何时等待；</li></ul><a id="more"></a><h2 id="2-得道"><a href="#2-得道" class="headerlink" title="2. 得道"></a>2. 得道</h2><p>可以自信地停止重构。</p><h2 id="3-学习"><a href="#3-学习" class="headerlink" title="3. 学习"></a>3. 学习</h2><ul><li>随时挑选一个目标；</li><li>没把握就停下来；</li><li>学习原路返回；</li><li>二重奏（多人协作重构、结对编程）；</li></ul><h2 id="4-要点"><a href="#4-要点" class="headerlink" title="4. 要点"></a>4. 要点</h2><ul><li>若代码无法方便添加新特性，请先重构；</li><li>重构技术就是以微小的步伐修改程序；</li><li>傻瓜都能编写计算机可以理解的代码，而唯有能编写人类容易理解的代码才是优秀的程序员；</li><li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本；</li><li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构；</li><li>事不过三，三则重构；</li><li>不要过早发布接口（API），修改代码所有权政策，使得重构更顺畅；</li><li>过多注释情况，请先重构；</li><li>大家都认为会出错的地方，检测是否抛出了预期的异常；</li><li><strong>测试、测试、测试！！！</strong>：<ul><li>重构前，先检查是否有一套可靠的测试机制，且具备自我检验能力；</li><li>自动化测试；</li><li>频繁运行测试；</li><li>单元测试；</li><li>考虑可能的出错边界条件，多测试；</li></ul></li></ul><h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h2><ul><li>大规模的重构只会带来灾难；</li><li>沟通：团队朝着同一个方向一起努力；</li><li>永远不要忘记“两顶帽子”：保持代码的功能完全不变，既不多又不少。对于需要修改的问题，先记下来。重构结束无误后，再进行修改。</li><li><strong>千万别打乱工作。</strong></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第15章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gradle</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Gradle/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Gradle/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>一个自动化构建工具，用于加速开发者生产率，特点：</p><ul><li>Build Anything;</li><li>Automate Everything;</li><li>Deliver Faster;</li></ul><a id="more"></a><h2 id="2-安装-amp-配置-amp-测试-amp-升级"><a href="#2-安装-amp-配置-amp-测试-amp-升级" class="headerlink" title="2. 安装 &amp; 配置 &amp; 测试 &amp; 升级"></a>2. 安装 &amp; 配置 &amp; 测试 &amp; 升级</h2><h3 id="2-1-前提"><a href="#2-1-前提" class="headerlink" title="2.1 前提"></a>2.1 前提</h3><p>JDK 1.7 版本以上。</p><h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><ul><li>通过包管理工具（SDKMAN、Homebrew、Scoop、Chocolatey、MacPorts）安装，具体参加<a href="https://gradle.org/install/#helpful-information" target="_blank" rel="noopener">官网</a>；</li><li>手动安装，下载二进制压缩包、解压到指定目录；</li></ul><h3 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h3><p>将 $GradlePaht\bin 添加到 Path 环境变量中；</p><h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><p>gradle -v</p><h3 id="2-5-升级"><a href="#2-5-升级" class="headerlink" title="2.5 升级"></a>2.5 升级</h3><p>使用 Gradle Wrapper 可方便快捷升级 Gradle。具体命令：<code>gradle wrapper --gradle-version=4.8 --distribution-type=bin</code>。</p><h3 id="2-6-Gradle-文件结构"><a href="#2-6-Gradle-文件结构" class="headerlink" title="2.6 Gradle 文件结构"></a>2.6 Gradle 文件结构</h3><ul><li>build.gradle：构建 Gradle 脚本；</li><li>settings.gradle：指定哪些项目需要构建，可配置多个项目；</li><li>gradle<ul><li>wrapper<ul><li>gradle-wrapper.jar：包含下载 Gradle 发布包的编译后代码；</li><li>gradle-wrapper.properties：运行时配置；</li></ul></li></ul></li><li>gradlew：Unix 系统的启动脚本；</li><li>gradlew.bat：Windows 系统的启动脚本；</li></ul><h2 id="3-Gradle-Wrapper（简称-Wrapper）"><a href="#3-Gradle-Wrapper（简称-Wrapper）" class="headerlink" title="3. Gradle Wrapper（简称 Wrapper）"></a>3. Gradle Wrapper（简称 Wrapper）</h2><p><strong>推荐使用 Gradle Wrapper 来执行 Gradle 构建。</strong>它是一串脚本用于动态调用指定版本的 Gradle，若不存在，则先下载。这样，开发者可快速开始和运行 Gradle 项目，而不必按照手册安装流程，从而节约时间和金钱。具体流程如下图：<br><img src="https://docs.gradle.org/4.8/userguide/img/wrapper-workflow.png" alt="Gradle Wrapper"></p><h3 id="3-1-优点"><a href="#3-1-优点" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><ul><li>标准化指定 Gradle 版本的项目，使得构建更加可靠和健壮。</li><li>在不同环境或不同用户之间，提供多个版本 Gradle，更加简单方便；</li><li>标准化；</li><li>可靠性；</li><li>可控制性；</li><li>健壮性；</li></ul><h3 id="3-2-新建-Gradle-Wrapper"><a href="#3-2-新建-Gradle-Wrapper" class="headerlink" title="3.2 新建 Gradle Wrapper"></a>3.2 新建 Gradle Wrapper</h3><p>通常要生成 Wrapper 文件需要向安装一个 Gradle，庆幸的是这是一次性的。每个 Gradle 都自带一个叫 wrapper 的任务。<br>运行 <code>gradle wrapper</code> 命令用以生成 Wrapper 文件，具体路径 <code>gradle/wrapper</code>。</p><p><code>注意：</code>若所有开发者和环境均需使用 Wrapper 文件，请将其添加到版本管理工具中。部分公司不允许将二进制文件添加到版本管理工具，这样就没其他解决方案了。</p><h4 id="3-2-1-参数配置选项："><a href="#3-2-1-参数配置选项：" class="headerlink" title="3.2.1 参数配置选项："></a>3.2.1 参数配置选项：</h4><ul><li><code>--gradle-version</code>：指定 Gradle 版本。</li><li><code>--distribution-type</code>：发布包类型，可选择 <strong>bin</strong> 和 <strong>all</strong>。默认为 <strong>bin</strong>。</li><li><code>--gradle-distribution-url</code>：发布包地址，该选项会忽略<code>--gradle-version</code>和<code>--distribution-type</code>参数。</li><li><code>--gradle-distribution-sha256-sum</code>：校验发布包 SHA256 HASH 码。</li></ul><p><code>示例</code>：gradle wrapper –gradle-version 4.0 –distribution-type all </p><h4 id="3-2-2-gradle-wrapper-properties文件"><a href="#3-2-2-gradle-wrapper-properties文件" class="headerlink" title="3.2.2 gradle-wrapper.properties文件"></a>3.2.2 gradle-wrapper.properties文件</h4><p>主要用以存储 Gradle 发布包信息，具体如下：</p><ul><li>Gradle 发布包的服务网路路径；</li><li>Gradle 发布包的类型，默认为 <code>-bin</code> 二进制包，只包括运行时而不包括示例代码和文档；</li><li>Gradle 发布包的版本，默认为生成 Wrapper 文件时的版本；</li></ul><h3 id="3-3-使用-Gradle-Wrapper"><a href="#3-3-使用-Gradle-Wrapper" class="headerlink" title="3.3 使用 Gradle Wrapper"></a>3.3 使用 Gradle Wrapper</h3><p>根据不同系统，运行 <code>gradlew</code> 或 <code>gradlew.bat</code> 脚本来取代 <code>gradle</code> 命令。<br><code>ps</code>：</p><ul><li>若本机未装配置版本的 Gradle，则会自动下载并保持到本机中。若配置未变，则复用。</li><li>多个项目可能分别有 Wrapper 脚本，请确认执行正确的脚本。</li></ul><h3 id="3-4-升级-Gradle-Wrapper"><a href="#3-4-升级-Gradle-Wrapper" class="headerlink" title="3.4 升级 Gradle Wrapper"></a>3.4 升级 Gradle Wrapper</h3><ul><li>手动修改配置文件<code>gradle-wrapper.properties</code>的<code>distributionUrl</code>属性；</li><li><strong>推荐</strong>执行<code>gradle wrapper</code> task 时，指定版本信息，默认为当前版本；</li></ul><h3 id="3-5-自定义-Gradle-Wrapper"><a href="#3-5-自定义-Gradle-Wrapper" class="headerlink" title="3.5 自定义 Gradle Wrapper"></a>3.5 自定义 Gradle Wrapper</h3><p>默认设置可满足大多数要求，然而可通过修改<code>build.gradle</code>配置来自定义相关配置。<br>块节点为<code>wrapper</code>，具体参数详情请参考<a href="https://docs.gradle.org/4.8/dsl/org.gradle.api.tasks.wrapper.Wrapper.html" target="_blank" rel="noopener">Wrapper</a>。</p><h2 id="4-创建一个新的-Gradle-构建"><a href="#4-创建一个新的-Gradle-构建" class="headerlink" title="4. 创建一个新的 Gradle 构建"></a>4. 创建一个新的 Gradle 构建</h2><h3 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h3><p><code>gradle init</code>命令，该命令可<a href="https://docs.gradle.org/4.7/userguide/build_init_plugin.html?&amp;_ga=2.66304238.1375004092.1528446888-1875152485.1526436983#sec:build_init_types" target="_blank" rel="noopener">创建不同类型的项目</a>，且可将 Maven 项目（pom.xml）转换为 Gradle 项目。</p><h3 id="4-2-创建-task"><a href="#4-2-创建-task" class="headerlink" title="4.2 创建 task"></a>4.2 创建 task</h3><p>Gradle 提供一系列 API（使用 Groovy 或 基于 Kotlin 的 DSL 语言） 用于创建和配置 task。一个 Project 包括一个 Task 集合，每个单独提供一些基础功能。<a href="https://docs.gradle.org/4.7/userguide/more_about_tasks.html" target="_blank" rel="noopener">具体详情</a><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> <span class="keyword">copy</span>(type: <span class="keyword">Copy</span>, <span class="keyword">group</span>: <span class="string">"Custom"</span>, <span class="keyword">description</span>: <span class="string">"Copies sources to the dest directory"</span>) &#123;</span><br><span class="line">    <span class="keyword">from</span> <span class="string">"src"</span></span><br><span class="line">    <span class="keyword">into</span> <span class="string">"dest"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-3-应用插件"><a href="#4-3-应用插件" class="headerlink" title="4.3 应用插件"></a>4.3 应用插件</h3><p>Gradle 提供一系列<a href="http://plugins.gradle.org/?_ga=2.27464572.1375004092.1528446888-1875152485.1526436983" target="_blank" rel="noopener">插件</a>。<br><code>ps</code>：plugins{} 代码块放置在配置文件最上方。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins&#123;</span><br><span class="line">    id <span class="string">"base"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-查看可用的-task"><a href="#4-4-查看可用的-task" class="headerlink" title="4.4 查看可用的 task"></a>4.4 查看可用的 task</h3><p><code>gradle tasks</code> 命令</p><h3 id="4-5-分析-amp-调试构建"><a href="#4-5-分析-amp-调试构建" class="headerlink" title="4.5 分析 &amp; 调试构建"></a>4.5 分析 &amp; 调试构建</h3><p>Gradle 提供一个叫<code>build scan</code>（专业版功能）的方式用于构建过程可视化。通过使用<code>--scan</code>命令或者对项目应用<code>scan</code>插件即可。</p><h3 id="4-6-查看可用的-properties"><a href="#4-6-查看可用的-properties" class="headerlink" title="4.6 查看可用的 properties"></a>4.6 查看可用的 properties</h3><p><code>gradle properties</code> 命令</p><h2 id="5-创建构建浏览（Build-Scans）"><a href="#5-创建构建浏览（Build-Scans）" class="headerlink" title="5. 创建构建浏览（Build Scans）"></a>5. 创建构建浏览（Build Scans）</h2><p>构建浏览是一个用于展示构建的 what happened and why 的工具，具有可分享，集中管理特性。可免费发布到 <a href="https://scans.gradle.com" target="_blank" rel="noopener">https://scans.gradle.com</a>。方式：</p><ul><li><code>--scan</code>命令参数；</li><li>插件  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.gradle.build-scan'</span> version <span class="string">'1.13.3'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>同意许可协议，或者直接配置好<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buildScan &#123;</span><br><span class="line">    termsOfServiceUrl = <span class="string">'https://gradle.com/terms-of-service'</span></span><br><span class="line">    termsOfServiceAgree = <span class="string">'yes'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对所有构建进行默认配置 build scan，在<code>~/.gradle/init.d</code>目录中创建 gradle 文件用于默认 build。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">initscript &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.gradle:build-scan-plugin:1.13.3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rootProject &#123;</span><br><span class="line">    apply plugin: com.gradle.scan.plugin.BuildScanPlugin</span><br><span class="line"></span><br><span class="line">    buildScan &#123;</span><br><span class="line">        termsOfServiceUrl = <span class="string">'https://gradle.com/terms-of-service'</span></span><br><span class="line">        termsOfServiceAgree = <span class="string">'yes'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://docs.gradle.com/build-scan-plugin" target="_blank" rel="noopener">官方用户手册</a></p><h2 id="6-迁移-Maven-至-Gradle"><a href="#6-迁移-Maven-至-Gradle" class="headerlink" title="6. 迁移 Maven 至 Gradle"></a>6. 迁移 Maven 至 Gradle</h2><h3 id="6-1-自动转换"><a href="#6-1-自动转换" class="headerlink" title="6.1 自动转换"></a>6.1 自动转换</h3><p><code>gradle init</code>命令：该命令允许自动将 Maven 项目转换为 Gradle 项目。<br><code>ps</code>：</p><ul><li>自动转换中组件不会自动转换，或有问题，需手动处理。</li><li>如果幸运地转换成功，可使用<code>gradle build</code>测试。</li></ul><p>具体迁移信息详见<a href="https://guides.gradle.org/migrating-from-maven" target="_blank" rel="noopener">迁移 Maven 至 Gradle</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>11.重构-重构工具（Don Roberts 和 John Brant）</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/11.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E5%B7%A5%E5%85%B7/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/11.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1. 总结"></a>1. 总结</h2><p>作者那时写《重构》一书时，还未像现如今一样。现在，各类 IDE 都提供重构工具辅助重构，而不用自己去实现一整套重构工具或手动重构了。所以，现在程序员自然而然的乐意像整理代码一样去整理系统，即重构。这样，对代码的可维护性、可复用性和可理解性大大加强。</p><a id="more"></a><h2 id="2-辅助工具"><a href="#2-辅助工具" class="headerlink" title="2. 辅助工具"></a>2. 辅助工具</h2><ul><li>自动化重构工具；</li><li>自动化测试工具；</li></ul><h2 id="3-重构工具的技术标准"><a href="#3-重构工具的技术标准" class="headerlink" title="3. 重构工具的技术标准"></a>3. 重构工具的技术标准</h2><ul><li>程序数据库；</li><li>解析树；</li><li>准确性；</li></ul><h2 id="4-重构工具的实用标准"><a href="#4-重构工具的实用标准" class="headerlink" title="4. 重构工具的实用标准"></a>4. 重构工具的实用标准</h2><ul><li>速度；</li><li>撤销；</li><li>与其他工具集成；</li><li>易用性（个人添加）；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第14章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>10.重构-重构、复用与现实（William Opdyke）</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/10.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E3%80%81%E5%A4%8D%E7%94%A8%E4%B8%8E%E7%8E%B0%E5%AE%9E/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/10.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E3%80%81%E5%A4%8D%E7%94%A8%E4%B8%8E%E7%8E%B0%E5%AE%9E/</url>
      <content type="html"><![CDATA[<h2 id="1-重构"><a href="#1-重构" class="headerlink" title="1. 重构"></a>1. 重构</h2><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h3><ul><li>生产进度的压力：<ul><li>重写整个程序（理想情况）；</li><li>复制、修改现有系统；  </li></ul></li><li>不知道如何重构；</li><li>如果利益是长远的，为什么现在做呢？可能收获利益之时，就已经不在职位上了；</li><li>代码重构是额外工作，老板看不到付出；</li><li>重构可能破坏现有程序；</li></ul><h3 id="1-2-回答"><a href="#1-2-回答" class="headerlink" title="1.2 回答"></a>1.2 回答</h3><ul><li>重构可以带来短期利益和长期利益。</li><li>已有重构工具和技术，可快速，无痛苦完成；</li><li>重构虽然花费精力和时间开销，当可在其他阶段减小相应开销；</li><li>当重构成为软件开发规则的一部分时，人们就觉得它必不可少；</li></ul><a id="more"></a><h2 id="2-做法"><a href="#2-做法" class="headerlink" title="2. 做法"></a>2. 做法</h2><ul><li>了解如何重构、在哪儿重构；</li><li>合理利用重构工具；</li><li>遵守重构规则；</li><li>团队保持共识；</li></ul><h2 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h2><p>安全性是令人关系的议题，特别是大型系统。许多应用程序由于财政、法律和道德伦理的压力，需要不间断、可靠、不出错的提供服务。</p><h2 id="3-1-如何进行安全重构"><a href="#3-1-如何进行安全重构" class="headerlink" title="3.1 如何进行安全重构"></a>3.1 如何进行安全重构</h2><ul><li>选择：<ul><li>相信编码功力；</li><li>相信编译器能捕捉错误；</li><li>相信测试能测出错误；</li><li>相信代码复审能捕捉错误；</li></ul></li><li>局限性：<ul><li>人人都可能犯错；</li><li>一些微妙错误编译器无法捕捉；</li><li>测试不可能覆盖所有情况，测出所有问题；</li><li>代码复审很可能没有，或出错，或没找到错误；</li></ul></li><li>方案：<ul><li>定义并快速实现一个重构工具的原型，用以检查某项重构是否可以安全地施加于程序上。若可能，则重构。这避免了大量可能因为人为错误引入的 bug。</li></ul></li></ul><h2 id="4-复用"><a href="#4-复用" class="headerlink" title="4. 复用"></a>4. 复用</h2><h3 id="4-1-问题（类似于重构）"><a href="#4-1-问题（类似于重构）" class="headerlink" title="4.1 问题（类似于重构）"></a>4.1 问题（类似于重构）</h3><ul><li>不知道“该复用什么”或“如何复用”；</li><li>对采用复用方法缺乏动力，除非有短期利益；</li><li>开销、学习曲线和探索成本；</li><li>项目压力；</li></ul><h3 id="4-2-回答（原则）"><a href="#4-2-回答（原则）" class="headerlink" title="4.2 回答（原则）"></a>4.2 回答（原则）</h3><ul><li>对员工进行培训；</li><li>尽量获取短期利益；</li><li>减少开销；</li><li>安全引入新技术；<br><code>ps</code>：这些不仅仅可用于重构和软件复用，还可用于技术传播。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第13章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>09.重构-大型重构</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/09.%E9%87%8D%E6%9E%84-%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/09.%E9%87%8D%E6%9E%84-%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="1-重构特点"><a href="#1-重构特点" class="headerlink" title="1. 重构特点"></a>1. 重构特点</h2><ul><li>大型重构中，情况复杂，变化多样性，没有准确的重构步骤，只能根据实际情况考虑分析；</li><li>大型重构耗时长，需合理安排工作，只在需要添加新功能或修补错误时才重构；</li><li>不必一开始就完成整个系统的重构，而应该只需满足任务需求就可；</li><li>大规模重构时，整个团队需建立共识。</li></ul><a id="more"></a><h2 id="2-问题及方案"><a href="#2-问题及方案" class="headerlink" title="2. 问题及方案"></a>2. 问题及方案</h2><ul><li>混乱的继承体系：Tease Apart Inheritance（梳理并分解继承体系）；</li><li>过程式代码：Convert Procedural Design to Objects（将面向过程设计改为面向对象设计）；</li><li>传统两层结构（用户界面和数据库），业务代码和界面耦合：Separate Domain from Presentation；</li><li>过于复杂的类：Extract Hierarchy；</li></ul><h2 id="3-Tease-Apart-Inheritance（梳理并分解继承体系）"><a href="#3-Tease-Apart-Inheritance（梳理并分解继承体系）" class="headerlink" title="3. Tease Apart Inheritance（梳理并分解继承体系）"></a>3. Tease Apart Inheritance（梳理并分解继承体系）</h2><p>问题：某个继承体系同时承担多种职责。<br>建立多个继承体系，并使用委托（依赖）关系用于调用。<br><code>ps</code>：</p><ul><li>参考抽象工厂模式（创建型）、桥接模式（结构性、抽象与实现分离）；</li><li>注意耦合关系；</li></ul><h2 id="4-Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）"><a href="#4-Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）" class="headerlink" title="4. Convert Procedural Design to Objects（将过程化设计转换为对象设计）"></a>4. Convert Procedural Design to Objects（将过程化设计转换为对象设计）</h2><p>将数据记录变为对象，将大块的行为拆分成小块，并将行为移动到对象中。</p><h2 id="5-Separate-Domain-from-Presentation（将领域和表现分离）"><a href="#5-Separate-Domain-from-Presentation（将领域和表现分离）" class="headerlink" title="5. Separate Domain from Presentation（将领域和表现分离）"></a>5. Separate Domain from Presentation（将领域和表现分离）</h2><p>将领域逻辑和表现界面分离。<br><code>ps</code>：</p><ul><li>MVC（模型-视图-控制器）模式：最核心价值在于将用户界面（视图、展现层）和领域逻辑（模型）分离。</li></ul><h2 id="6-Extract-Hierarchy（提炼继承体系）"><a href="#6-Extract-Hierarchy（提炼继承体系）" class="headerlink" title="6. Extract Hierarchy（提炼继承体系）"></a>6. Extract Hierarchy（提炼继承体系）</h2><p>问题：一个类承担了太多职责，其中一部分工作是以大量的条件表达式来完成的。<br>建立继承体系，以一个子类来表示一种特殊情况。<br><code>ps</code>：</p><ul><li>只有当条件逻辑在对象的整个生命周期保持不变时，才可使用该策略。</li><li>该策略是一项大型重构，请先梳理清晰，明确步骤后，再动手处理。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第12章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>08.重构-处理类的继承关系(generalization)</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/08.%E9%87%8D%E6%9E%84-%E5%A4%84%E7%90%86%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/08.%E9%87%8D%E6%9E%84-%E5%A4%84%E7%90%86%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>字段位置不正确：Pull Up Field、Pull Down Field；</li><li>函数位置不正确：Pull Up Method、Pull Down Method；</li><li>构造函数：Pull Up Constructor Body（向上）、Replace Constructor with Factory Method；</li><li>函数大体相同、细节不同：Form Template Method；</li><li>改变继承体系：Extract Subclass、Extract Superclass、Extract Interface；</li><li>继承体系部分类无用：Collapse（瓦解） Hierarchy（层次结构）；</li><li>委托替代继承：Replace Inheritance with Delegation；</li><li>继承替代委托：Replace Delegation with Inheritance；</li></ul><a id="more"></a><h2 id="2-Pull-Up-Field-Method（字段-函数上移）"><a href="#2-Pull-Up-Field-Method（字段-函数上移）" class="headerlink" title="2. Pull Up Field/Method（字段/函数上移）"></a>2. Pull Up Field/Method（字段/函数上移）</h2><p>将多个子类的相同字段/函数移到超类。</p><h2 id="3-Pull-Down-Field-Method（字段-函数下移）"><a href="#3-Pull-Down-Field-Method（字段-函数下移）" class="headerlink" title="3. Pull Down Field/Method（字段/函数下移）"></a>3. Pull Down Field/Method（字段/函数下移）</h2><p>超类的字段/函数只与部分（而非全部）子类有关，移动到相关子类中。</p><h2 id="4-Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#4-Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="4. Pull Up Constructor Body（构造函数本体上移）"></a>4. Pull Up Constructor Body（构造函数本体上移）</h2><p>多个子类的构造函数相同，将主体移动到超类构造函数中，并在子类中调用它。</p><h2 id="5-Replace-Constructor-with-Factory-Method（使用工厂方法替代构造函数）"><a href="#5-Replace-Constructor-with-Factory-Method（使用工厂方法替代构造函数）" class="headerlink" title="5. Replace Constructor with Factory Method（使用工厂方法替代构造函数）"></a>5. Replace Constructor with Factory Method（使用工厂方法替代构造函数）</h2><p>由于无法将构造函数本体下移，故改为使用工厂方法模式。</p><h2 id="6-Extract-Subclass（提炼子类）"><a href="#6-Extract-Subclass（提炼子类）" class="headerlink" title="6. Extract Subclass（提炼子类）"></a>6. Extract Subclass（提炼子类）</h2><p>问题：类中的某些特性只被某些（而非全部）实例使用。<br>新建一个子类，移动特性到子类中。<br><code>ps</code>：Extract Class 是另一种选择，两者抉择之处在于委托和继承之间的选择。</p><h2 id="7-Extract-SuperClass（提炼超类）"><a href="#7-Extract-SuperClass（提炼超类）" class="headerlink" title="7. Extract SuperClass（提炼超类）"></a>7. Extract SuperClass（提炼超类）</h2><p>为两个相似的类建立一个超类，将相同特性移至超类。</p><h2 id="8-Extract-Interface（提炼接口）"><a href="#8-Extract-Interface（提炼接口）" class="headerlink" title="8. Extract Interface（提炼接口）"></a>8. Extract Interface（提炼接口）</h2><p>多个类有相似的行为，或多个类的接口有相似部分，将相同的行为提炼到一个独立的接口中。</p><h2 id="9-Collapse-Hierarchy（折叠继承体系）"><a href="#9-Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="9. Collapse Hierarchy（折叠继承体系）"></a>9. Collapse Hierarchy（折叠继承体系）</h2><p>问题：超类和子类之间无太大区别。<br>将它们合为一体。</p><h2 id="10-Form-Template-Method（塑造模板函数）"><a href="#10-Form-Template-Method（塑造模板函数）" class="headerlink" title="10. Form Template Method（塑造模板函数）"></a>10. Form Template Method（塑造模板函数）</h2><p>问题：子类的某些函数以相同顺序执行类似操作，细节有所不同。<br>将这些操作分别放进独立函数中，并保持相同签名。而后将原函数提炼到超类中。<br><code>ps</code>：即模板方法模式。</p><h2 id="11-Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#11-Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="11. Replace Inheritance with Delegation（以委托取代继承）"></a>11. Replace Inheritance with Delegation（以委托取代继承）</h2><p>问题：某个子类只使用超类的一部分，或根本不需要继承而来的数据。<br>在子类中新建一个字段引用超类，调整子类函数，而后让它调用超类，最后去除两者之间的继承关系。<br><code>ps</code>：此处的委托其实应该理解为委托调用关系，即依赖关系，而非 C# 的委托。</p><h2 id="12-Replace-Delegation-with-Inheritance（以继承取代委托）"><a href="#12-Replace-Delegation-with-Inheritance（以继承取代委托）" class="headerlink" title="12. Replace Delegation with Inheritance（以继承取代委托）"></a>12. Replace Delegation with Inheritance（以继承取代委托）</h2><p>问题：两个类之间使用委托关系，并经常为了<strong>整个接口（即所有函数）</strong>编写许多极其简单的委托函数。<br>让委托类继承被委托类。<br><code>ps</code>：</p><ul><li>该重构手法与 Replace Inheritance with Delegation 恰恰相反。</li><li>如果你并没有使用被委托类的所有函数，就不该使用该重构手法。</li><li>被委托对象被不止一个对象共享，而且被委托对象是可变的，此时就不该使用该重构手法。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第11章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>07.重构-简化函数调用</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/07.%E9%87%8D%E6%9E%84-%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/07.%E9%87%8D%E6%9E%84-%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>函数名称不清晰：Rename Method；</li><li>参数不明确：Add Parameter、Remove Parameter；</li><li>参数过多：Preserve Whole Object、Introduce Parameter Object； </li><li>函数参数来自该函数可以获取的对象：Replace Parameter with Method；</li><li>参数被用于条件表达式：Replace Parameter with Explicit Method；</li><li>多个相似函数添加参数：Parameterize Method；</li><li>查询命令函数分离：Separate Query from Modifier；</li><li>不必要的暴露：Hide Method、Remove Setting Method；</li><li>隐藏创建对象：Replace Constructor with Factory Method；</li><li>转型：Encapsulate Downcast；</li><li>错误码、异常、测试：Replace Error Code with Exception、Replace Exception with Test；</li></ul><a id="more"></a><h2 id="2-Rename-Method（函数改名）"><a href="#2-Rename-Method（函数改名）" class="headerlink" title="2. Rename Method（函数改名）"></a>2. Rename Method（函数改名）</h2><p>修改函数名称，更加清晰明了。</p><h2 id="3-Add-Parameter（添加参数）"><a href="#3-Add-Parameter（添加参数）" class="headerlink" title="3. Add Parameter（添加参数）"></a>3. Add Parameter（添加参数）</h2><p>为函数添加参数，带进所需信息。</p><h3 id="3-1-动机"><a href="#3-1-动机" class="headerlink" title="3.1 动机"></a>3.1 动机</h3><p>请先确认是否一定需要添加新参数：</p><ul><li>你能从已有参数得到所需信息么？</li><li>有可能通过某个函数得到所需信息么？</li><li>这个函数是否应该属于拥有该信息的对象所有？</li><li>现有参数过多，是否考虑使用 Introduce Parameter Object？<br><code>ps</code>：若旧函数是接口一部分，不好删除，请标记为 deprecated（不赞成）。</li></ul><h2 id="4-Remove-Parameter（移除参数）"><a href="#4-Remove-Parameter（移除参数）" class="headerlink" title="4. Remove Parameter（移除参数）"></a>4. Remove Parameter（移除参数）</h2><p>将不需要的参数移除。</p><h2 id="5-Separate-Query-from-Modifer（将查询函数和修改函数分离）"><a href="#5-Separate-Query-from-Modifer（将查询函数和修改函数分离）" class="headerlink" title="5. Separate Query from Modifer（将查询函数和修改函数分离）"></a>5. Separate Query from Modifer（将查询函数和修改函数分离）</h2><p>建立两个不同的函数，一个负责查询，另一个负责修改。</p><h3 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h3><ul><li>明确表示“有副作用”和“无副作用”两种函数之间的差异；</li><li>任何有返回值的函数，都不应该有<strong>看得到</strong>（提取出查询函数，将结果缓存到某个字段）的副作用。<br><code>ps</code>：多线程环境下，建立第三个函数来做“查询-修改”，该还是调用独立的查询函数和修改函数，并被声明为 synchronized。若为声明为 synchronized，则将它们的可见范围限制在包级别或 private 级别。如此就能保证安全、同步的操作。</li></ul><h2 id="6-Parameterize-Method（令函数携带参数）"><a href="#6-Parameterize-Method（令函数携带参数）" class="headerlink" title="6. Parameterize Method（令函数携带参数）"></a>6. Parameterize Method（令函数携带参数）</h2><p>建立单一函数，以参数表达那些不同的值。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><p>多个函数处理类似工作，仅因为值不同而略有不同。</p><h2 id="7-Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#7-Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="7. Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>7. Replace Parameter with Explicit Methods（以明确函数取代参数）</h2><p>问题：函数完全取决于参数值而采取不同行为。<br>针对该参数的的每一个可能值，建立一个独立函数。<br><code>ps</code>：</p><ul><li>与 Parameterize Method 正好相反。</li><li>若参数值对函数行为没太多影像，就不该使用该重构手法。</li><li>若需要条件判断，考虑使用 Replace Conditional with Polymorphism。</li></ul><h2 id="8-Preserve-Whole-Object（保持对象完整）"><a href="#8-Preserve-Whole-Object（保持对象完整）" class="headerlink" title="8. Preserve Whole Object（保持对象完整）"></a>8. Preserve Whole Object（保持对象完整）</h2><p>将从某个对象取出某些值作为参数传递改为直接传递整个对象。<br><code>ps</code>：</p><ul><li>两面性，该重构手法会产生依赖关系，请考虑后在使用。</li><li>先考虑 Move Method。</li></ul><h2 id="9-Replace-Parameter-with-Methods（以函数取代参数）"><a href="#9-Replace-Parameter-with-Methods（以函数取代参数）" class="headerlink" title="9. Replace Parameter with Methods（以函数取代参数）"></a>9. Replace Parameter with Methods（以函数取代参数）</h2><p>问题：对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能调用前一个函数。<br>让参数接受者去除该项参数，直接调用前一个函数。</p><h3 id="9-1-动机"><a href="#9-1-动机" class="headerlink" title="9.1 动机"></a>9.1 动机</h3><p>如果函数可以通过其他途径获取参数，就不应该通过参数传递。应尽可能缩短参数列的长度。</p><h2 id="10-Introduce-Parameter-Object（引入参数对象）"><a href="#10-Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="10. Introduce Parameter Object（引入参数对象）"></a>10. Introduce Parameter Object（引入参数对象）</h2><p>以一个对象取代这些参数。</p><h3 id="10-1-动机"><a href="#10-1-动机" class="headerlink" title="10.1 动机"></a>10.1 动机</h3><p>特定的一组参数总是被一起传递，好几个函数都使用这组参数。这就是所谓的 Data Clumps（数据泥团）。</p><h2 id="11-Remove-Setting-Method（移除设值函数）"><a href="#11-Remove-Setting-Method（移除设值函数）" class="headerlink" title="11. Remove Setting Method（移除设值函数）"></a>11. Remove Setting Method（移除设值函数）</h2><p>若某个字段在对象创建后就不再改变，则应移除该字段的所有设值函数。</p><h2 id="12-Hide-Method（隐藏函数）"><a href="#12-Hide-Method（隐藏函数）" class="headerlink" title="12. Hide Method（隐藏函数）"></a>12. Hide Method（隐藏函数）</h2><p>该函数不被外界使用，请设为 private。</p><h2 id="13-Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#13-Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="13. Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>13. Replace Constructor with Factory Method（以工厂函数取代构造函数）</h2><p>将构造函数替换为工厂函数。</p><h3 id="13-1-动机"><a href="#13-1-动机" class="headerlink" title="13.1 动机"></a>13.1 动机</h3><ul><li>在派生类中以工程函数取代类型码；</li><li>以明确函数创建子类；</li></ul><h2 id="14-Encapsulate-Downcast（封装向下转型）"><a href="#14-Encapsulate-Downcast（封装向下转型）" class="headerlink" title="14. Encapsulate Downcast（封装向下转型）"></a>14. Encapsulate Downcast（封装向下转型）</h2><p>将向下转型动作移到函数中。</p><h2 id="15-Replace-Error-Code-with-Exception（以异常取代错误码）"><a href="#15-Replace-Error-Code-with-Exception（以异常取代错误码）" class="headerlink" title="15. Replace Error Code with Exception（以异常取代错误码）"></a>15. Replace Error Code with Exception（以异常取代错误码）</h2><p>某个函数返回一个特定的代码，用以表示某种错误情况。改用异常。</p><h2 id="16-Replace-Exception-with-Test（以测试取代异常）"><a href="#16-Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="16. Replace Exception with Test（以测试取代异常）"></a>16. Replace Exception with Test（以测试取代异常）</h2><p>问题：面对一个调用者可以预先检查的条件，你抛出了一个异常。<br>修改调用者，使它在调用函数之前先做检查。</p><h3 id="16-1-动机"><a href="#16-1-动机" class="headerlink" title="16.1 动机"></a>16.1 动机</h3><ul><li>异常滥用情况，异常只应该被用于意料之外的错误行为，而不应该成为条件检查的替代品。<br><code>ps</code>：我自己的坏习惯就是滥用异常，而且统一捕获。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第10章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>其他</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%85%B6%E4%BB%96/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%85%B6%E4%BB%96/</url>
      <content type="html"><![CDATA[<h2 id="1-查询命令职责分离（CQRS）"><a href="#1-查询命令职责分离（CQRS）" class="headerlink" title="1. 查询命令职责分离（CQRS）"></a>1. 查询命令职责分离（CQRS）</h2><p>明确地将“修改对象状态”的函数（修改函数）和“查询对象状态”的函数（查询函数）分开设计。</p><h2 id="2-将复杂的处理过程分解为小函数。"><a href="#2-将复杂的处理过程分解为小函数。" class="headerlink" title="2. 将复杂的处理过程分解为小函数。"></a>2. 将复杂的处理过程分解为小函数。</h2><h2 id="3-任何有返回值的函数，都不应该有看得到的副作用。"><a href="#3-任何有返回值的函数，都不应该有看得到的副作用。" class="headerlink" title="3.任何有返回值的函数，都不应该有看得到的副作用。"></a>3.任何有返回值的函数，都不应该有看得到的副作用。</h2><h2 id="4-Range-模式"><a href="#4-Range-模式" class="headerlink" title="4. Range 模式"></a>4. Range 模式</h2><p>使用范围对象替代多个参数。</p>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>06.重构-简化条件表达式</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/06.%E9%87%8D%E6%9E%84-%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/06.%E9%87%8D%E6%9E%84-%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>复杂条件逻辑拆分：Decompose（分解） Conditional；</li><li>代码多次测试结果相同：Consolidate（合并） Conditional Expression；</li><li>条件代码重复：Consolidate Duplicate Conditional Fragments（碎片）；</li><li>“单一出口”特殊情况：Replace Nested Conditional with Guard Clauses；</li><li>去除控制标记：Remove Control Flag；</li><li>switch 语句：Replace Conditional with Polymorphism（多态）；</li><li>去除 Null 检验：Introduce Null Object；</li></ul><a id="more"></a><h2 id="2-Decompose-Conditional（分解条件表达式）"><a href="#2-Decompose-Conditional（分解条件表达式）" class="headerlink" title="2. Decompose Conditional（分解条件表达式）"></a>2. Decompose Conditional（分解条件表达式）</h2><p>从 if-then-else 中分别提炼到独立函数；</p><h2 id="3-Consolidate-Conditional-Expression（合并条件表达式）"><a href="#3-Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="3. Consolidate Conditional Expression（合并条件表达式）"></a>3. Consolidate Conditional Expression（合并条件表达式）</h2><p>将同样结果的条件测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。<br><code>ps</code>:</p><ul><li>类似多个 case 使用同样的代码。</li><li>如果你认为这些检查的确需要彼此独立，就可以不要使用该项重构，不过必须表示清楚自己的意义。</li></ul><h2 id="4-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#4-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="4. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>4. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h2><p>将重复代码提取到条件表达式之外。</p><h2 id="5-Remove-Control-Flag（移除控制标记）"><a href="#5-Remove-Control-Flag（移除控制标记）" class="headerlink" title="5. Remove Control Flag（移除控制标记）"></a>5. Remove Control Flag（移除控制标记）</h2><p>以 break、continue、return 语句取代控制标记。</p><h2 id="6-Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式，防御编程）"><a href="#6-Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式，防御编程）" class="headerlink" title="6. Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式，防御编程）"></a>6. Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式，防御编程）</h2><p>使用卫语句表现所有特殊情况。<br><strong>精髓</strong>：给某一条分支以特别的重视。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><ul><li>条件表达式不同形式：<ul><li>所有分支都是正常行为：使用 if-else；</li><li>只有一种是正常行为，其他都是不正常情况：if-return,XXX；</li></ul></li><li>将条件反转，而后使用该重构手法；</li></ul><h3 id="6-2-示例"><a href="#6-2-示例" class="headerlink" title="6.2 示例"></a>6.2 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">false</span> &amp;&amp; B==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="comment">//Do Here</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">true</span> &amp;&amp; B==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#7-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="7. Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>7. Replace Conditional with Polymorphism（以多态取代条件表达式）</h2><p>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。<br><code>ps</code>：多态最根本的好处：根据对象的不同类型（形态）采用不同的行为，而不必编写明显的条件表达式。</p><h3 id="7-1-做法"><a href="#7-1-做法" class="headerlink" title="7.1 做法"></a>7.1 做法</h3><ul><li>建立继承结构<ul><li>Replace Type Code with Subclasses；</li><li>Replace Type Code with State/Strategy；</li></ul></li></ul><h2 id="8-Introduce-Null-Object（引入-Null-对象）"><a href="#8-Introduce-Null-Object（引入-Null-对象）" class="headerlink" title="8. Introduce Null Object（引入 Null 对象）"></a>8. Introduce Null Object（引入 Null 对象）</h2><p>将 null 值替换为 null 对象。<br><code>ps</code>：</p><ul><li>空对象一定是常量，它们的任何成分都不会发生变化。因此，可考虑使用单例模式保证唯一实例。</li><li>本质上来说，Null object 模式属于 Special Case 模式。</li></ul><h2 id="9-Introduce-Assertion（引入断言）"><a href="#9-Introduce-Assertion（引入断言）" class="headerlink" title="9. Introduce Assertion（引入断言）"></a>9. Introduce Assertion（引入断言）</h2><p>以断言明确表现某些用以对程序状态的假设。<br><code>ps</code>：</p><ul><li>断言是个条件表达式，应该总是为真。若失败，则表示程序员犯错了，所以断言的失败会导致一个非受控异常（unchecked exception）。</li><li>断言绝对不能被系统其它部分使用，实际上，最后成品往往需删除断言。</li><li>不要滥用断言，请不要使用它来检查“你认为应该为真”的条件，请只是用它来检查“一定必须为真”的条件。</li><li>如果断言所指示的约束条件不能满足，代码是否仍能正常运行？若可以，则移除断言。</li><li>断言的价值在于：帮助程序员理解代码正确运行的必要条件。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第9章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>05.重构-重新组织数据</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/05.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/05.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>表示方式：Replace Value with Object、Change Value to Reference；</li><li>数组的行为方式很像一种数据结构：Replace Array with Object；</li><li>魔法数：Replace Magic Number with Symbolic Constant；</li><li>对象关联方向：Change Unidirectional Association to Bidirectional（单向-&gt;双向）、Change Bidirectional Association to Unidirectional（双向-&gt;单向）；</li><li>非公开数据：Encapsulate Field、Encapsulate Collection；</li><li>记录暴露在外：Replace Record with Data Class；</li><li>类型码（type code）：Replace Type Code with Class、Replace Type Code with Subclasses、Replace Type Code with State/Strategy；</li></ul><a id="more"></a><h2 id="2-Self-Encapsulate-Field（自封装字段）"><a href="#2-Self-Encapsulate-Field（自封装字段）" class="headerlink" title="2. Self Encapsulate Field（自封装字段）"></a>2. Self Encapsulate Field（自封装字段）</h2><p>为这个字段设置取值、设值函数，并只能通过该函数访问。</p><h2 id="3-Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#3-Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="3. Replace Data Value with Object（以对象取代数据值）"></a>3. Replace Data Value with Object（以对象取代数据值）</h2><p>将数据项变成对象。</p><h2 id="4-Change-Value-to-Reference（将值对象改为引用对象）"><a href="#4-Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="4. Change Value to Reference（将值对象改为引用对象）"></a>4. Change Value to Reference（将值对象改为引用对象）</h2><p>问题：你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。<br>将这个值对象改为引用对象。</p><h3 id="4-1-动机"><a href="#4-1-动机" class="headerlink" title="4.1 动机"></a>4.1 动机</h3><ul><li>实例共享，防止多份拷贝；</li><li>解决方案：如单例模式、静态函数等；</li></ul><h2 id="5-Change-Reference-to-Value（将引用对象改为值对象）"><a href="#5-Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="5. Change Reference to Value（将引用对象改为值对象）"></a>5. Change Reference to Value（将引用对象改为值对象）</h2><p>问题：你有一个引用对象，很小且不可变，而且不易管理。<br>将这个引用对象改为值对象。</p><h3 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h3><ul><li>值对象特性：不可变；</li><li>提供 equals() 和 hashCode() 等实现；</li></ul><h2 id="6-Replace-Array-with-Object（以对象取代数组）"><a href="#6-Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="6. Replace Array with Object（以对象取代数组）"></a>6. Replace Array with Object（以对象取代数组）</h2><p>问题：你有一个数组，其中的元素每个都代表不同的东西。<br><code>ps</code>：Martin Flower 写《重构》一书时，基于 Java1.0 -&gt; Java1.1 版本，那时还没有泛型一说。现如今应该不会出现这种数组存储完全不同类型的问题，否则就是需求分析建模出错。<br>以对象取代数组，对于数组中的每个元素，都使用一个字段表示。</p><h2 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h2><ul><li>数组存储不同类型数据；</li><li>个人理解另一个问题：数组数据涉及到相关操作，可考虑将属性修改为直接继承已有列表类型的对象，而后扩展相应操作。</li></ul><h2 id="7-Duplicate-Observed-Data（复制“被监视数据”）"><a href="#7-Duplicate-Observed-Data（复制“被监视数据”）" class="headerlink" title="7. Duplicate Observed Data（复制“被监视数据”）"></a>7. Duplicate Observed Data（复制“被监视数据”）</h2><p>将数据复制到一个领域对象中。建立一个 Observer 模式，用以同步领域对象和 GUI 对象内的重复数据。</p><h3 id="7-1-动机"><a href="#7-1-动机" class="headerlink" title="7.1 动机"></a>7.1 动机</h3><ul><li>UI 和业务逻辑代码分离；</li></ul><h2 id="8-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#8-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="8. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>8. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h2><p>添加一个反向指针，并使修改函数能够同时更新两条连接。</p><h3 id="8-1-动机"><a href="#8-1-动机" class="headerlink" title="8.1 动机"></a>8.1 动机</h3><ul><li>被引用类需要其引用者以便进行某些处理。</li></ul><h2 id="9-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）"><a href="#9-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）" class="headerlink" title="9. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）"></a>9. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）</h2><p>去除不必要的关联。</p><h3 id="9-1-动机"><a href="#9-1-动机" class="headerlink" title="9.1 动机"></a>9.1 动机</h3><ul><li>双向关联维护复杂，引用垃圾回收不了；</li><li>依赖关系太强，导致紧耦合；</li></ul><h2 id="10-Replace-Magic-Number-with-Symbolic-Constant（使用字面常量替换魔法数）"><a href="#10-Replace-Magic-Number-with-Symbolic-Constant（使用字面常量替换魔法数）" class="headerlink" title="10. Replace Magic Number with Symbolic Constant（使用字面常量替换魔法数）"></a>10. Replace Magic Number with Symbolic Constant（使用字面常量替换魔法数）</h2><p>创造一个变量，根据其意义为它命名，并将上述的字面数值替换为这个常量。<br><code>ps</code>：</p><ul><li>常量不会造成任何性能开销，却可以大大提高代码可读性。</li><li>若魔法数是类型码，考虑使用 Replace Type Code with Class；</li></ul><h2 id="11-Encapsulate-Field（封装字段）"><a href="#11-Encapsulate-Field（封装字段）" class="headerlink" title="11. Encapsulate Field（封装字段）"></a>11. Encapsulate Field（封装字段）</h2><p>将字段声明为 private，并提供 get/set 方法。<br><code>ps</code>：面向对象的原则之一就是封装，或称为“数据隐藏”。故数据不应该声明为 public，而通过（函数）行为暴露。</p><h2 id="12-Encapsulate-Collection（封装集合）"><a href="#12-Encapsulate-Collection（封装集合）" class="headerlink" title="12. Encapsulate Collection（封装集合）"></a>12. Encapsulate Collection（封装集合）</h2><p>让这个函数返回该集合的一个只读副本，并在这个类中提供添加/删除集合元素的函数。</p><h3 id="12-1-动机"><a href="#12-1-动机" class="headerlink" title="12.1 动机"></a>12.1 动机</h3><ul><li>集合用来保存一组实例，并提供取值/设值函数；</li><li>取值函数不应该返回集合本身，因为这会使得用户修改集合内容而集合拥有者却不知晓，过多暴露对象内部数据结构的信息；</li><li>不应该为集合提供一个设置函数，而应该提供添加/删除元素的函数；</li><li>封装数组，直接将数组替换为其他集合；</li></ul><h2 id="13-Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#13-Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="13. Replace Record with Data Class（以数据类取代记录）"></a>13. Replace Record with Data Class（以数据类取代记录）</h2><p>为该记录创建一个“哑”数据对象。<br><code>ps</code>：其实就是单独建立一个实体（Model/Entity），只有取值/设值函数。</p><h2 id="14-Replace-Type-Code-with-Class（以类取代状态码）"><a href="#14-Replace-Type-Code-with-Class（以类取代状态码）" class="headerlink" title="14. Replace Type Code with Class（以类取代状态码）"></a>14. Replace Type Code with Class（以类取代状态码）</h2><p>以一个新的类替换该数值类型码。<br><code>ps</code>：</p><ul><li>现如今有枚举类型，强类型检查，可优先考虑。</li><li>或者单独建立一个类，提供相应的状态码的静态字段，类似于 C# 中 Encoding 类的实现。</li></ul><h2 id="15-Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#15-Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="15. Replace Type Code with Subclasses（以子类取代类型码）"></a>15. Replace Type Code with Subclasses（以子类取代类型码）</h2><p>以子类取代这个类型码。<br><code>ps</code>：</p><ul><li>主要作用是为 Replace Conditional with Polymorphism 搭建平台。</li><li>若宿主类中无条件表达式，推荐使用 Replace Type Code with Class。</li></ul><h3 id="15-1-动机"><a href="#15-1-动机" class="headerlink" title="15.1 动机"></a>15.1 动机</h3><ul><li>以类型码的宿主类作为基类，针对每种类型码建立相应子类；</li><li>把“对不同行为的了解”从类用户转移到类自身；</li><li>不适用情况，需使用 Replace Type Code with State/Strategy：<ul><li>类型码在对象创建后发生改变；</li><li>由于某种原因，类型码宿主已有子类；</li></ul></li></ul><h2 id="16-Replace-Type-Code-with-State-Strategy（使用-State-Strategy-模式取代类型码）"><a href="#16-Replace-Type-Code-with-State-Strategy（使用-State-Strategy-模式取代类型码）" class="headerlink" title="16. Replace Type Code with State/Strategy（使用 State/Strategy 模式取代类型码）"></a>16. Replace Type Code with State/Strategy（使用 State/Strategy 模式取代类型码）</h2><p>以状态对象取代类型码。</p><ul><li>状态：State；</li><li>算法：Strategy；</li></ul><h2 id="17-Replace-Subclass-with-Fields（以字段取代子类）"><a href="#17-Replace-Subclass-with-Fields（以字段取代子类）" class="headerlink" title="17. Replace Subclass with Fields（以字段取代子类）"></a>17. Replace Subclass with Fields（以字段取代子类）</h2><p>问题：各个子类的唯一差别在于“返回常量数据”的函数上。<br>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。</p><h3 id="17-1-动机"><a href="#17-1-动机" class="headerlink" title="17.1 动机"></a>17.1 动机</h3><p>建立子类的目的是为了增加新特性或变化行为。其中，有一类行为变化被称为“常量函数”，它们会返回一个硬编码的值，使得不同子类的同一个函数返回不同的值。<br><strong>若子类只有常量函数，则没存在的价值。可直接在超类中使用字段表示类型（如 C# 中的 Encoding 类）</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第8章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>04.重构-在对象之间搬移特性</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/04.%E9%87%8D%E6%9E%84-%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/04.%E9%87%8D%E6%9E%84-%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>职责不清晰：Move Field、Move Method；</li><li>类承担过多职责：Extract Class；</li><li>类职责过少：Inline Class；</li><li>类之间关联：Hide Delegate、Remove Middle Man；</li><li>不能访问类的源码，却又想添加职责：Introduce Foreign Method、Introduce Local Extension；</li></ul><a id="more"></a><h2 id="2-Move-Method（搬移函数）"><a href="#2-Move-Method（搬移函数）" class="headerlink" title="2. Move Method（搬移函数）"></a>2. Move Method（搬移函数）</h2><p>问题：类中，有个函数与另一类过多交互。<br>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是直接移除。</p><h3 id="2-1-动机"><a href="#2-1-动机" class="headerlink" title="2.1 动机"></a>2.1 动机</h3><ul><li>类中有太多行为职责；</li><li>类之间太多合作导致高度耦合；</li></ul><h2 id="3-Move-Field（搬移字段）"><a href="#3-Move-Field（搬移字段）" class="headerlink" title="3. Move Field（搬移字段）"></a>3. Move Field（搬移字段）</h2><p>问题：类中，某个字段被另外一个类更多的使用。<br>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。</p><h3 id="3-2-做法"><a href="#3-2-做法" class="headerlink" title="3.2 做法"></a>3.2 做法</h3><ul><li>Self Encapsulate Field：即对字段进行包装，提高 get、set 操作；</li></ul><h2 id="4-Extract-Class（提炼类）"><a href="#4-Extract-Class（提炼类）" class="headerlink" title="4. Extract Class（提炼类）"></a>4. Extract Class（提炼类）</h2><p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p><h3 id="4-1-动机"><a href="#4-1-动机" class="headerlink" title="4.1 动机"></a>4.1 动机</h3><ul><li>类的职责过多；</li><li>类有部分特性需子类化；</li></ul><h2 id="5-Inline-Class（类内联化）"><a href="#5-Inline-Class（类内联化）" class="headerlink" title="5. Inline Class（类内联化）"></a>5. Inline Class（类内联化）</h2><p>将这个类的所有特性搬移到另一个类中，然后移除原类。此手法正好与 Extract Class 相反。</p><h3 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h3><p>一个类不再承担足够职责，不再有单独存在的里有。</p><h2 id="6-Hide-Delegate（隐藏“委托关系”）"><a href="#6-Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="6. Hide Delegate（隐藏“委托关系”）"></a>6. Hide Delegate（隐藏“委托关系”）</h2><p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><p>“封装”意味着每个对象都应该尽可能少了解系统的其他部分。</p><h2 id="7-Remove-Middle-Man（移除中间人）"><a href="#7-Remove-Middle-Man（移除中间人）" class="headerlink" title="7. Remove Middle Man（移除中间人）"></a>7. Remove Middle Man（移除中间人）</h2><p>问题：某个类做了过多的简单委托动作。<br>让客户直接调用委托类。</p><h3 id="7-1-动机"><a href="#7-1-动机" class="headerlink" title="7.1 动机"></a>7.1 动机</h3><ul><li>合适的隐藏程度；</li><li>与 Hide Delegate 相反；</li></ul><h2 id="8-Introduce-Foreign-Method（引入外部函数）"><a href="#8-Introduce-Foreign-Method（引入外部函数）" class="headerlink" title="8. Introduce Foreign Method（引入外部函数）"></a>8. Introduce Foreign Method（引入外部函数）</h2><p>问题：你需要为提供服务的类增加一个函数，但无法修改这个类。<br>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</p><h3 id="8-1-动机"><a href="#8-1-动机" class="headerlink" title="8.1 动机"></a>8.1 动机</h3><ul><li>同样功能防止重复代码。</li><li>若许多类都需要同样的外加函数，则应提取出来，使用 Introduce Local Extension。<br><code>ps:</code>类似 C# 的扩展函数。</li><li>坚持“函数与数据应该被统一封装”的原则。</li></ul><h2 id="9-Introduce-Local-Extension（引入本地扩展）"><a href="#9-Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="9. Introduce Local Extension（引入本地扩展）"></a>9. Introduce Local Extension（引入本地扩展）</h2><p>问题：你需要为提供服务的类增加一些函数，但无法修改这个类。<br>建立一个新类，使它包含这些额外函数。让这个扩展品成为原类的子类或包装类。<br>  <code>ps:</code>C# 的扩展方法更简单易用，若编程语言不支持扩展方法，则使用子类或包装类形式。</p><h3 id="9-1-注意事项"><a href="#9-1-注意事项" class="headerlink" title="9.1 注意事项"></a>9.1 注意事项</h3><ul><li>优先级：扩展方法 &gt; 子类 &gt; 包装类；</li><li>添加“转型构造函数”，即源类型作为参数的构造函数；</li><li>子类问题：必须在对象创建期实施、必须创建子类对象（若旧对象一直使用，则有两个对象保存原数据，数据修改会有问题）；</li><li>包装类 Wrapper；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第7章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>03.重构-重新组织函数</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/03.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/03.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>Long Methods（过长函数）：Extract Method；</li><li>某些函数没做什么太多事情：Inline Method；</li><li>临时变量：Replace Temp with Query、Split Temporary Variable、Replace Method with Method Object；</li><li>参数问题：Remove Assignments to Parameters；</li><li>改进算法：Substitute Algorithm；</li></ul><a id="more"></a><h2 id="2-Extract-Method（提炼函数）"><a href="#2-Extract-Method（提炼函数）" class="headerlink" title="2. Extract Method（提炼函数）"></a>2. Extract Method（提炼函数）</h2><p>将一段代码放进一个独立函数中，并让函数名称解释其用途。</p><h3 id="2-1-动机"><a href="#2-1-动机" class="headerlink" title="2.1 动机"></a>2.1 动机</h3><ul><li>函数粒度小，易于复用和覆写；</li><li>高层函数更像注释；</li></ul><h3 id="2-2-做法"><a href="#2-2-做法" class="headerlink" title="2.2 做法"></a>2.2 做法</h3><ul><li>无局部变量：直接挪移</li><li>有局部变量，但不修改它或局部变量是对象：局部变量当做参数传递</li><li>对局部变量再赋值（Remove Assignments to Parameters）<ul><li>若只有被提炼代码使用：挪移局部变量</li><li>否则：返回值</li><li>返回变量不止一个：推荐只返回一个值，使用多个函数；若编程语言支持“出参数”（output parameter），则可使用。（类似 C# 的 ref 和 out，可考虑新特性元组 Tuple）<br>详见书P133。</li></ul></li></ul><h2 id="3-Inline-Method（内联函数）"><a href="#3-Inline-Method（内联函数）" class="headerlink" title="3. Inline Method（内联函数）"></a>3. Inline Method（内联函数）</h2><p>在函数调用点插入函数本体，然后移除该函数。</p><h3 id="3-1-动机"><a href="#3-1-动机" class="headerlink" title="3.1 动机"></a>3.1 动机</h3><ul><li>短小函数只有一处调用，过多导致复杂性太高，移动不方便等等；</li><li>防止间接层过多，晕头转向；</li></ul><h3 id="3-2-做法"><a href="#3-2-做法" class="headerlink" title="3.2 做法"></a>3.2 做法</h3><ul><li>检查函数，确定不具备多态性<ul><li>若子类继承该函数，就不能内联；<br>详见书P140</li></ul></li></ul><h2 id="4-Inline-Temp（内联临时变量）"><a href="#4-Inline-Temp（内联临时变量）" class="headerlink" title="4. Inline Temp（内联临时变量）"></a>4. Inline Temp（内联临时变量）</h2><p>将所有对该变量的引用操作，替换为对它赋值的那个表达式自身。</p><h3 id="4-1-动机"><a href="#4-1-动机" class="headerlink" title="4.1 动机"></a>4.1 动机</h3><ul><li>临时变量被赋予某个函数调用的返回值。<br><code>ps</code>：个人感觉部分情况还是可使用临时变量，以便调试使用，更清晰。</li></ul><h2 id="5-Replace-Temp-with-Query（以查询替代临时变量）"><a href="#5-Replace-Temp-with-Query（以查询替代临时变量）" class="headerlink" title="5. Replace Temp with Query（以查询替代临时变量）"></a>5. Replace Temp with Query（以查询替代临时变量）</h2><p>将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用。<br><code>ps</code>：该操作会导致函数执行多次，故为了效率考虑，若执行速度慢的查询，还是需使用临时变量。</p><h2 id="6-Introduce-Explaining-Variable（引入解释下变量）"><a href="#6-Introduce-Explaining-Variable（引入解释下变量）" class="headerlink" title="6. Introduce Explaining Variable（引入解释下变量）"></a>6. Introduce Explaining Variable（引入解释下变量）</h2><p>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><ul><li>与 Inline Temp（内联临时变量）相反；</li><li>表达式可能非常复杂而难以阅读，临时变量可帮助拆分，提高阅读性；<br><code>ps</code>：作者推荐使用 Extract Method，以便复用。</li></ul><h2 id="7-Split-Temporary-Variable（分解临时变量）"><a href="#7-Split-Temporary-Variable（分解临时变量）" class="headerlink" title="7. Split Temporary Variable（分解临时变量）"></a>7. Split Temporary Variable（分解临时变量）</h2><p>针对每次赋值，创造一个独立、对应的临时变量。</p><h3 id="7-1-动机"><a href="#7-1-动机" class="headerlink" title="7.1 动机"></a>7.1 动机</h3><p>某个临时变量被赋值超过一次，它既不是<strong>循环变量</strong>，又不是<strong>搜集计算结果</strong>。除了这两种情况，其他意味着临时变量承担了多个责任，应该被替换为多个临时变量，每个变量只承担一个责任。</p><h2 id="8-Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#8-Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="8. Remove Assignments to Parameters（移除对参数的赋值）"></a>8. Remove Assignments to Parameters（移除对参数的赋值）</h2><p>以一个临时变量取代该参数的位置。</p><h3 id="8-1-动机"><a href="#8-1-动机" class="headerlink" title="8.1 动机"></a>8.1 动机</h3><ul><li>防止混用<strong>按值传递</strong>和<strong>按引用传递</strong>；</li><li>不要对参数赋值（特别是 Java、C# 这类只采用值传递的编程语言），出参数（ref、out）除外；</li><li>可以为参数加上 final 修饰符，强制不对参数赋值；<br><code>ps</code>：在按值传递的情况下，对参数的任何修改，都不会对调用端造成任何影响。</li></ul><h2 id="9-Replace-Method-with-Method-Object（以函数对象取代函数）"><a href="#9-Replace-Method-with-Method-Object（以函数对象取代函数）" class="headerlink" title="9. Replace Method with Method Object（以函数对象取代函数）"></a>9. Replace Method with Method Object（以函数对象取代函数）</h2><p>问题：你有一个大型函数，其中对局部变量的使用使你无法采用 Extract Method。<br>将这个函数放进一个单独对象中，这样该局部变量就成为了这个对象的字段，然后就可拆分。</p><h2 id="10-Substitute-Algorithm（替换算法）"><a href="#10-Substitute-Algorithm（替换算法）" class="headerlink" title="10. Substitute Algorithm（替换算法）"></a>10. Substitute Algorithm（替换算法）</h2><p>将函数本体替换为另一个算法。</p><h3 id="10-1-动机"><a href="#10-1-动机" class="headerlink" title="10.1 动机"></a>10.1 动机</h3><p>解决问题有好几种方法，其中某些方法会比另一些简单。<br>使用这项重构手法之前，请先确定自己已经尽可能分解了原先函数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第6章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>02.重构-重构手法</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/02.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E6%89%8B%E6%B3%95/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/02.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E6%89%8B%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-重构的记录格式"><a href="#1-重构的记录格式" class="headerlink" title="1. 重构的记录格式"></a>1. 重构的记录格式</h2><ul><li>名称（name）</li><li>简短概要（summary）：介绍重构手法的适用场景，以及它所做的事情。</li><li>动机（motivation）：Why，介绍“为什么需要这个重构”和“什么情况下不该适用这个重构”。</li><li>做法（mechanics）：How。</li><li>范例（examples）</li></ul><a id="more"></a><h2 id="2-寻找引用点"><a href="#2-寻找引用点" class="headerlink" title="2. 寻找引用点"></a>2. 寻找引用点</h2><ul><li>文本查找工具，不要盲目地查找-替换；</li><li>编译器，缺点：<ul><li>被删除的部分在继承体系中不知声明一次；</li><li>效率太慢；</li><li>无法找到反射机制的引用点；</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第5章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>01.重构-介绍</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/01.%E9%87%8D%E6%9E%84-%E4%BB%8B%E7%BB%8D/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/01.%E9%87%8D%E6%9E%84-%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul><li>重构（refactoring）是在不改变软件可观察行为的前提下改善其内部结构。</li><li>重构是这样一个过程：在不改变代码外在行为的前提下，对代码进行修改，以改进程序的内部结构。</li><li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高可理解性，降低其修改成本。</li><li>重构（动词）：使用一系列重构首发，在不改变软件可观察行为的前提下，调整其结构。</li></ul><a id="more"></a><h2 id="2-原则"><a href="#2-原则" class="headerlink" title="2. 原则"></a>2. 原则</h2><ul><li>不改变软件行为只是重构的最基本要求；</li><li>不需了解软件行为才是目的；</li><li>个人理解：封装完整性？调用 API 而无需了解 API 内部实现和行为。</li><li>设计模式为重构提供了目标；</li><li>判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据放在一起。<ul><li><code>ps:</code>有些设计模式破坏这个原则，如 Strategy 和 Visitor，Self Delegation，这是为了对抗坏味道 Divergent Change。</li><li>最根本的原则：将总是一起变化的东西放在一起。</li></ul></li></ul><h2 id="3-目的"><a href="#3-目的" class="headerlink" title="3. 目的"></a>3. 目的</h2><ul><li>重构改进软件设计<ul><li>消除重复代码</li></ul></li><li>重构使软件更容易理解</li><li>重构帮助找到 bug</li><li>重构提高编程速度</li><li>重构使得设计思路更详细明确；</li><li>重构被用于开发框架、抽取可复用组件、使软件架构更清晰、使新功能增加更容易；</li><li>重构可以减少重复劳动，使得程序更加简洁有力；</li></ul><h2 id="4-经验"><a href="#4-经验" class="headerlink" title="4. 经验"></a>4. 经验</h2><ul><li>重构前需建立一组可靠的测试环境，且必须能自我检验；</li><li>重构技术就是以微小的步伐修改程序，如果出错，可以很容易发现；</li><li>良好的名称是代码清晰的关键；</li><li>尽量除去临时变量；</li><li>最好不要在另一个对象的属性基础上运用 switch 语句，如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用；</li><li>技术复审是减少错误、提高开发速度的一条重要途径。</li></ul><h2 id="5-何时重构"><a href="#5-何时重构" class="headerlink" title="5. 何时重构"></a>5. 何时重构</h2><ul><li>反对专门拨出时间进行重构；</li><li>重构应该随时随地进行；</li><li>不应该为了重构而重构；</li><li>三次法则（事不过三，三则重构）<ul><li>第一次做某件事时只管去做；</li><li>第二次做类似的事会产生反感，但无论如何还是可以去做；</li><li>第三次再做类似的事，就应该重构。</li></ul></li><li>添加功能时重构；</li><li>修补错误时重构；</li><li>复审代码时重构；</li></ul><h2 id="6-为什么重构有用-–-Kent-Beck"><a href="#6-为什么重构有用-–-Kent-Beck" class="headerlink" title="6. 为什么重构有用 – Kent Beck"></a>6. 为什么重构有用 – Kent Beck</h2><h3 id="6-1-问题"><a href="#6-1-问题" class="headerlink" title="6.1 问题"></a>6.1 问题</h3><ul><li>难以阅读的程序，难以修改；</li><li>逻辑重复的程序，难以修改；</li><li>添加新行为时需要修改已有代码的程序，难以修改；</li><li>带复杂条件逻辑的程序，难以修改；</li></ul><h3 id="6-2-期望"><a href="#6-2-期望" class="headerlink" title="6.2 期望"></a>6.2 期望</h3><ul><li>容易阅读；</li><li>所有逻辑都只在唯一地点指定；</li><li>新的改动不会危及现有行为；</li><li>尽可能简单表达条件逻辑；</li></ul><h2 id="7-间接层"><a href="#7-间接层" class="headerlink" title="7. 间接层"></a>7. 间接层</h2><blockquote><p>计算机科学是这样一门科学：它相信所有问题都可以通过增加一个间接层来解决。</p><footer><strong>Dennis DeBruler</strong></footer></blockquote><h2 id="8-重构难题"><a href="#8-重构难题" class="headerlink" title="8. 重构难题"></a>8. 重构难题</h2><h3 id="8-1-数据库"><a href="#8-1-数据库" class="headerlink" title="8.1 数据库"></a>8.1 数据库</h3><ul><li>绝大多数程序都与其背后的数据库结构紧密耦合在一起；</li><li>数据迁移（migration）；</li><li>在非对象数据库中，解决办法之一是：在对象模型和数据库模型之间插入一个分割层，隔离两个模型各自的编号；</li></ul><h3 id="8-2-修改接口"><a href="#8-2-修改接口" class="headerlink" title="8.2 修改接口"></a>8.2 修改接口</h3><p>只有当需要修改的接口被哪些“找不到，即使找到也不能修改”的代码使用时，接口的修改才会成为问题。此时，这个接口是个已发布接口（published interface），比公开接口（public interface）更进一步。</p><ul><li>必须同时维护新旧两个接口，直到所有用户都有时间对这个变化做出反应；<ul><li>让旧接口调用新接口，千万不要复制函数实现；</li><li>将旧接口标记为 deprecated（java 的已过时），例如 Java 容器类；</li></ul></li><li>尽量不要发布接口，除非真的有必要；</li><li>Java 还有一种特别的接口修改：在 throws 子句中增加一个异常。此时，需要新建函数，然后在旧函数调用它，并处理这个异常。</li></ul><p><code>ps:</code>不要过早发布接口。请修改你的代码所有权政策，使重构更顺畅。</p><h3 id="8-3-难以通过重构手法完成的设计改动"><a href="#8-3-难以通过重构手法完成的设计改动" class="headerlink" title="8.3 难以通过重构手法完成的设计改动"></a>8.3 难以通过重构手法完成的设计改动</h3><p>先想象重构的情况，考虑候选设计方案难度，而后在设计上投入更多力气。</p><h2 id="9-何时不该重构"><a href="#9-何时不该重构" class="headerlink" title="9. 何时不该重构"></a>9. 何时不该重构</h2><ul><li>有时候代码是在太混乱，重构还不如重新重写一个；</li><li>重写（而非重构）的一个清楚讯号就是：现有代码根本不能正常运作；</li><li>折中办法：将“大块头软件”重构为封装良好的小型组件；</li><li>项目已近最后期限，此刻应该避免重构；</li></ul><h2 id="10-代码的坏味道（Bad-Smell）"><a href="#10-代码的坏味道（Bad-Smell）" class="headerlink" title="10. 代码的坏味道（Bad Smell）"></a>10. 代码的坏味道（Bad Smell）</h2><h3 id="10-1-Duplicated-Code（重复代码）"><a href="#10-1-Duplicated-Code（重复代码）" class="headerlink" title="10.1 Duplicated Code（重复代码）"></a>10.1 Duplicated Code（重复代码）</h3><ul><li>Extract（提取） Method：重复代码；</li><li>Pull Up Method：多个子类重复代码，提取代码放到超类；</li><li>Form Template Method：各个子类有所差异，使用 Template Method（模板方法）模式；</li><li>Substitute（替代） Algorithm：不同算法做同样的事；</li><li>Extract Class：若两个毫不相关的类出现，则将重复代码提炼到一个独立类；</li></ul><h3 id="10-2-Long-Method（过长函数）"><a href="#10-2-Long-Method（过长函数）" class="headerlink" title="10.2 Long Method（过长函数）"></a>10.2 Long Method（过长函数）</h3><p>“间接层”所能带来的全部利益–解释能力、共享能力、选择能力–都是由小型函数支持的。小函数真正容易理解的关键之处在于一个好名字。</p><ul><li>Extract Method</li><li>Replace Temp with Query</li><li>Introduce Parameter Object</li><li>Preserve（保持） Whole Object</li><li>Replace Method with Method Object</li><li>Decompose（分解） Conditional</li></ul><h3 id="10-3-Large-Class（过大的类）"><a href="#10-3-Large-Class（过大的类）" class="headerlink" title="10.3 Large Class（过大的类）"></a>10.3 Large Class（过大的类）</h3><ul><li>Extract Class</li><li>Extract Subclass</li><li>Extract Interface：先确定客户端如何使用它们，而后为每种使用方式提炼出一个接口。</li><li>Duplicate Observed Data</li></ul><h3 id="10-4-Long-Parameter-List（过长参数列）"><a href="#10-4-Long-Parameter-List（过长参数列）" class="headerlink" title="10.4 Long Parameter List（过长参数列）"></a>10.4 Long Parameter List（过长参数列）</h3><ul><li>Replace Parameter with Method</li><li>Preserve Whole Object</li><li>Introduce Parameter Object：如果某些数据缺乏合理的对象归属，可为它们制造一个“参数对象”；<br>-<code>ps:</code>例外情况，有时候不希望造成“被调用对象”与“较大对象”间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情合理。但需注意引发的代价。若参数列太长或变化太频繁，就需要重新考虑依赖结构。</li></ul><h3 id="10-5-Divergent-Change（发散式变化）"><a href="#10-5-Divergent-Change（发散式变化）" class="headerlink" title="10.5 Divergent Change（发散式变化）"></a>10.5 Divergent Change（发散式变化）</h3><p>某个类因为不同原因在不同方向发生变化。此时也许将对象拆分更好，这么一来每个对象就可以只因一种变化而修改。</p><ul><li>Extract Class</li></ul><h3 id="10-6-Shotgun-Surgery（散弹式修改）"><a href="#10-6-Shotgun-Surgery（散弹式修改）" class="headerlink" title="10.6 Shotgun Surgery（散弹式修改）"></a>10.6 Shotgun Surgery（散弹式修改）</h3><p>某种变化引发在许多不同的类内做出许多小修改。考虑把所有需要修改的代码放进同一个类。</p><ul><li>Move Method</li><li>Move Field</li><li>Inline Class</li></ul><p><code>ps:</code>Divergent Change 是指“一个类受多种变化的影响”，Shotgun Surgery 则是指“一种变化引发多个类相应修改”。</p><h3 id="10-7-Feature-Envy（依恋情结）"><a href="#10-7-Feature-Envy（依恋情结）" class="headerlink" title="10.7 Feature Envy（依恋情结）"></a>10.7 Feature Envy（依恋情结）</h3><ul><li>Extract Method</li><li>Move Method</li></ul><h3 id="10-8-Data-Clumps（数据泥团）"><a href="#10-8-Data-Clumps（数据泥团）" class="headerlink" title="10.8 Data Clumps（数据泥团）"></a>10.8 Data Clumps（数据泥团）</h3><p>两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有数据它们自己的对象。</p><ul><li>Extract Class</li><li>Introduce Parameter Object</li><li>Preserve Whole Object</li></ul><h3 id="10-9-Primitive-Obsession（基本类型偏执）"><a href="#10-9-Primitive-Obsession（基本类型偏执）" class="headerlink" title="10.9 Primitive Obsession（基本类型偏执）"></a>10.9 Primitive Obsession（基本类型偏执）</h3><ul><li>Replace Data Value with Object</li><li>Replace Type Code with Class</li><li>Replace Type Code with Subclass</li><li>Replace Type Code with State/Strategy</li><li>Extract Class</li><li>Introduce Parameter Object</li><li>Replace Array with Object</li></ul><h3 id="10-10-Switch-Statements（switch表达式）"><a href="#10-10-Switch-Statements（switch表达式）" class="headerlink" title="10.10 Switch Statements（switch表达式）"></a>10.10 Switch Statements（switch表达式）</h3><p>面向对象程序的一个最明显的特征就是：少用 switch（或 case）语句，问题在于重复，同样 switch 语句散布不同地方，需同时修改。解决方案是<strong>多态</strong>。</p><ul><li>Extract Method</li><li>Extract Class</li><li>Replace Type Code with Subclass</li><li>Replace Type Code with State/Strategy</li><li>Replace Conditional with Polymorphism（多态性）</li><li>Replace Parameter with Explicit（明确的） Methods</li><li>Introduce Null Object</li></ul><h3 id="10-11-Paraller-Inheritance-Hierarchies（平行继承体系）"><a href="#10-11-Paraller-Inheritance-Hierarchies（平行继承体系）" class="headerlink" title="10.11 Paraller Inheritance Hierarchies（平行继承体系）"></a>10.11 Paraller Inheritance Hierarchies（平行继承体系）</h3><p>Shotgun Surgery 的特殊情况，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。<br><strong>策略</strong>：让一个继承体系的实例引用另一个继承体系的实例。</p><ul><li>Move Method</li><li>Move Field</li></ul><h3 id="10-12-Lazy-Class（冗赘类）"><a href="#10-12-Lazy-Class（冗赘类）" class="headerlink" title="10.12 Lazy Class（冗赘类）"></a>10.12 Lazy Class（冗赘类）</h3><p>你所创建的每一个类，都得有人去理解和维护它，若一个类重构后完全没啥意义，就应该考虑删除它。</p><ul><li>Collapse（崩溃、折叠） Hierarchy</li><li>Inline Class</li></ul><h3 id="10-13-Speculative-Generality（夸夸其谈未来性）"><a href="#10-13-Speculative-Generality（夸夸其谈未来性）" class="headerlink" title="10.13 Speculative Generality（夸夸其谈未来性）"></a>10.13 Speculative Generality（夸夸其谈未来性）</h3><ul><li>Collapse Hierarchy</li><li>Inline Class</li><li>Remove Parameter</li><li>Rename Method</li></ul><h3 id="10-14-Temporary-Field（令人迷惑的临时字段）"><a href="#10-14-Temporary-Field（令人迷惑的临时字段）" class="headerlink" title="10.14 Temporary Field（令人迷惑的临时字段）"></a>10.14 Temporary Field（令人迷惑的临时字段）</h3><ul><li>Extract Class</li><li>Introduce Null Object</li></ul><h3 id="10-15-Message-Chains（过度耦合的消息链）"><a href="#10-15-Message-Chains（过度耦合的消息链）" class="headerlink" title="10.15 Message Chains（过度耦合的消息链）"></a>10.15 Message Chains（过度耦合的消息链）</h3><ul><li>Hide Delegate</li><li>Extract Method</li><li>Move Method</li></ul><h3 id="10-16-Middle-Man（中间人）"><a href="#10-16-Middle-Man（中间人）" class="headerlink" title="10.16 Middle Man（中间人）"></a>10.16 Middle Man（中间人）</h3><p>过度委托</p><ul><li>Remove Middle Man</li><li>Inline Method</li><li>Replace Delegation with Inheritance</li></ul><h3 id="10-17-Inappropriate-Intimacy（不恰当的亲密关系，即狎昵关系）"><a href="#10-17-Inappropriate-Intimacy（不恰当的亲密关系，即狎昵关系）" class="headerlink" title="10.17 Inappropriate Intimacy（不恰当的亲密关系，即狎昵关系）"></a>10.17 Inappropriate Intimacy（不恰当的亲密关系，即狎昵关系）</h3><ul><li>Move Method</li><li>Move Field</li><li>Change Bidirectional（双向） Association（关联） to Unidirectional（单向）</li><li>Extract Class</li><li>Hide Delegate</li><li>Replace Inheritance with Delegation</li></ul><h3 id="10-18-Alternative-Classes-with-Different-Interfaces（异曲同工的类）"><a href="#10-18-Alternative-Classes-with-Different-Interfaces（异曲同工的类）" class="headerlink" title="10.18 Alternative Classes with Different Interfaces（异曲同工的类）"></a>10.18 Alternative Classes with Different Interfaces（异曲同工的类）</h3><ul><li>Rename Method</li><li>Move Method</li><li>Extract SuperClass</li></ul><h3 id="10-19-Incomplete-Library-Class（不完美的类库）"><a href="#10-19-Incomplete-Library-Class（不完美的类库）" class="headerlink" title="10.19 Incomplete Library Class（不完美的类库）"></a>10.19 Incomplete Library Class（不完美的类库）</h3><ul><li>Introduce Foreign Method</li><li>Introduce Local Extension</li></ul><h3 id="10-20-Data-Class（纯粹的数据类）"><a href="#10-20-Data-Class（纯粹的数据类）" class="headerlink" title="10.20 Data Class（纯粹的数据类）"></a>10.20 Data Class（纯粹的数据类）</h3><p>指拥有一些字段以及访问（读写）这些字段的函数的类，即 Model 实体类。</p><ul><li>Encapsulate（封装） Field</li><li>Encapsulate Collection</li><li>Remove Setting Method</li><li>Move Method</li><li>Extract Method</li><li>Hide Method</li></ul><h3 id="10-21-Refused-Bequest（被拒绝的遗赠）"><a href="#10-21-Refused-Bequest（被拒绝的遗赠）" class="headerlink" title="10.21 Refused Bequest（被拒绝的遗赠）"></a>10.21 Refused Bequest（被拒绝的遗赠）</h3><p>子类不需要超类的函数和数据，意味着继承体系设计错误。</p><ul><li>Push Down Method</li><li>Push Down Field</li><li>Replace Iniheritance with Delegation</li></ul><h3 id="10-22-Comments（过多的注释）"><a href="#10-22-Comments（过多的注释）" class="headerlink" title="10.22 Comments（过多的注释）"></a>10.22 Comments（过多的注释）</h3><p>注释太长太多意味着代码很糟糕。</p><ul><li>Extract Method</li><li>Rename Method</li><li>Introduce Assertion<br><code>ps:</code>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</li></ul><h2 id="11-测试"><a href="#11-测试" class="headerlink" title="11 测试"></a>11 测试</h2><p>如果你想进行重构，首要前提就是拥有一个可靠的测试环境。<br><code>ps</code>：</p><ul><li>确保所有测试都完全自动化，让它们检查自己的测试结果。</li><li>一套测试就是一个强大的 bug 侦测器，能够大大缩减查找 bug 所需要的时间。</li><li>当事情被认为应该会出错时，别忘了检查是否抛出预期的异常。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>Replace Type Code with State/Strategy</li><li>Move Method</li><li>Replace Conditional with Polymorphism</li><li>Form Template Method</li><li>Replace Temp with Query</li><li>Extract Method</li><li>Self Encapsulate(自封装) Field</li></ul><h3 id="重构-vs-性能优化"><a href="#重构-vs-性能优化" class="headerlink" title="重构 vs 性能优化"></a>重构 vs 性能优化</h3><table><thead><tr><th>类型</th><th>重构</th><th>性能优化</th></tr></thead><tbody><tr><td>内部结构</td><td>改变</td><td>改变</td></tr><tr><td>外部行为</td><td>不改变或很小改变</td><td>不改变（除了执行速度）</td></tr><tr><td>目的</td><td>软件更容易被理解和修改，性能没有变化</td><td>性能提升，但往往使代码较难理解</td></tr></tbody></table><h3 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h3><ul><li><strong>怎么对经理说重构</strong>：很多经理嘴巴上说自己“质量驱动”，实际是“进度驱动”，这种情况建议是：不要告诉经理！</li><li>学习一种可以大幅提高生产力的新技术时，你总是难以察觉其不适用的场合。通常你在一个特定场景中学习它，这个场景往往是个项目。这种情况下你很难看出什么会造成这种新技术成效不彰或形成危害。</li><li><blockquote><p>他把未完成的重构工作形容为“债务”。很多公司都需要借债来使自己更有效的运转，但借债就得付利息，过于复杂的代码所造成的维护和扩展的额外成本就是利息。你可以承受一定程度的利息，但如果利息太高，你就会被压垮。把债务管理好是很重要的，你应该随时通过重构来偿还一部分债务。</p><footer><strong>Ward Cunningham</strong></footer></blockquote></li><li>重构与设计互补。</li><li>如果在所有可能的变化出现地点都建立起灵活性，整个系统的复杂度和维护难度都会大大提高。当然，如果最后发现所有这些灵活性都毫无必要，这才是最大的失败。</li><li>重构可以带来更简单的设计，同时又不损失灵活性，也降低了设计过程的难度，减轻了设计压力。</li><li><blockquote><p>哪怕你完全了解系统，也请实际度量它的性能，不要瞎猜。瞎猜可能会让你学到一些东西，但十有八九是错的。</p><footer><strong>Ron Jeffries</strong></footer></blockquote></li><li>如何确定该提炼哪一段代码：寻找注释，它们通常能指出代码用途和实现手法之间的语义距离。</li><li>对象技术的全部要点：将数据和对数据的操作行为包装到一起。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第1-4章）</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 02.重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim编辑器</title>
      <link href="//posts/03.%E5%B7%A5%E5%85%B7/01.Linux/01.CentOS/vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>//posts/03.%E5%B7%A5%E5%85%B7/01.Linux/01.CentOS/vim%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h2 id="2-退出"><a href="#2-退出" class="headerlink" title="2. 退出"></a>2. 退出</h2><p>先按<code>Esc</code>切换命令模式，而后在<code>:</code>后输入相关命令：</p><ul><li><strong>wq</strong>：写入退出，等同于 <strong>x</strong>；</li><li><strong>q!</strong>：不保存退出；</li><li><strong>!</strong>：强制退出，并在提示后回车。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>Linux 命令要小写。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
      <categories>
          
          <category> 03.工具 </category>
          
          <category> 01.Linux </category>
          
          <category> 01.CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSharp与Java对比</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/04.%E5%85%B6%E4%BB%96/CSharp%E4%B8%8EJava%E5%AF%B9%E6%AF%94/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/04.%E5%85%B6%E4%BB%96/CSharp%E4%B8%8EJava%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<h2 id="1-代码风格"><a href="#1-代码风格" class="headerlink" title="1.代码风格"></a>1.代码风格</h2><h3 id="1-1-命名规范"><a href="#1-1-命名规范" class="headerlink" title="1.1 命名规范"></a>1.1 命名规范</h3><h4 id="1-1-1-接口"><a href="#1-1-1-接口" class="headerlink" title="1.1.1 接口"></a>1.1.1 接口</h4><table><thead><tr><th>分类</th><th>详细</th><th>C#</th><th>Java</th></tr></thead><tbody><tr><td>命名</td><td>接口</td><td>前缀I</td><td>无</td></tr><tr><td>命名</td><td>接口实现</td><td>无</td><td>后缀Impl</td></tr><tr><td>命名</td><td>抽象类</td><td>前缀Base</td><td>前缀Abstract</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 04.其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C#代码规范</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<h2 id="1-规范制定原则"><a href="#1-规范制定原则" class="headerlink" title="1.    规范制定原则"></a>1.    规范制定原则</h2><ul><li>方便代码的交流和维护。</li><li>不影响编码的效率，不与大众习惯冲突。</li><li>使代码更美观、阅读更方便。</li><li>使代码的逻辑更清晰、更易于理解。</li></ul><h2 id="2-术语定义"><a href="#2-术语定义" class="headerlink" title="2.    术语定义"></a>2.    术语定义</h2><h3 id="2-1-Pascal-大小写"><a href="#2-1-Pascal-大小写" class="headerlink" title="2.1 Pascal 大小写"></a>2.1 Pascal 大小写</h3><p>将标识符的首字母和后面连接的每个单词的首字母都大写。可以对三字符或更多字符的标识符使用Pascal 大小写。例如： BackColor。</p><h3 id="2-2-Camel-大小写"><a href="#2-2-Camel-大小写" class="headerlink" title="2.2 Camel 大小写"></a>2.2 Camel 大小写</h3><p>标识符的首字母小写，而每个后面连接的单词的首字母都大写。例如：backColor。</p><h2 id="3-代码外观"><a href="#3-代码外观" class="headerlink" title="3. 代码外观"></a>3. 代码外观</h2><h3 id="3-1-列宽"><a href="#3-1-列宽" class="headerlink" title="3.1 列宽"></a>3.1 列宽</h3><p>控制在 120 字符左右。</p><h3 id="3-2-换行"><a href="#3-2-换行" class="headerlink" title="3.2 换行"></a>3.2 换行</h3><ul><li>在逗号后换行。</li><li>在操作符前换行。</li><li>规则1优先于规则2。</li></ul><h3 id="3-3-缩进"><a href="#3-3-缩进" class="headerlink" title="3.3    缩进"></a>3.3    缩进</h3><p>缩进应该是每行一个Tab(4个空格)，不要在代码中使用Tab字符。<br><code>VS设置</code>：工具-&gt;选项-&gt;文本编辑器-&gt;C#-&gt;制表符-&gt;插入空格</p><h3 id="3-4-空行"><a href="#3-4-空行" class="headerlink" title="3.4    空行"></a>3.4    空行</h3><p>空行是为了将逻辑上相关联的代码分块，以便提高代码的可阅读性。</p><ul><li><p>在以下情况下使用两个空行</p><ul><li>接口和类的定义之间。</li><li>枚举和类的定义之间。</li><li>类与类的定义之间.</li></ul></li><li><p>在以下情况下使用一个空行</p><ul><li>方法与方法、属性与属性之间。</li><li>方法中变量声明与语句之间。</li><li>方法与方法之间。</li><li>方法中不同的逻辑块之间。</li><li>方法中的返回语句与其他的语句之间。</li><li>属性与方法、属性与字段、方法与字段之间。</li><li>注释与它注释的语句间不空行，但与其他的语句间空一行。</li></ul></li></ul><h3 id="3-5-程序注释"><a href="#3-5-程序注释" class="headerlink" title="3.5 程序注释"></a>3.5 程序注释</h3><h4 id="3-5-1-文件注释"><a href="#3-5-1-文件注释" class="headerlink" title="3.5.1 文件注释"></a>3.5.1 文件注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//===========================================================</span><br><span class="line">// Copyright (c) $年份 $公司名称.  </span><br><span class="line">// 版权所有.</span><br><span class="line">//===========================================================</span><br></pre></td></tr></table></figure><h4 id="3-5-2-对象注释（类、接口、枚举、结构等）"><a href="#3-5-2-对象注释（类、接口、枚举、结构等）" class="headerlink" title="3.5.2 对象注释（类、接口、枚举、结构等）"></a>3.5.2 对象注释（类、接口、枚举、结构等）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// $功能描述</span><br><span class="line">/// 作者：$作者</span><br><span class="line">/// 日期：$创建日期</span><br><span class="line">/// 版本：$版本号</span><br><span class="line">/// &lt;/summary&gt;</span><br></pre></td></tr></table></figure><h4 id="3-5-3-其他注释（单行注释、多行注释、方法注释）"><a href="#3-5-3-其他注释（单行注释、多行注释、方法注释）" class="headerlink" title="3.5.3 其他注释（单行注释、多行注释、方法注释）"></a>3.5.3 其他注释（单行注释、多行注释、方法注释）</h4><ul><li>方法注释<strong>必须</strong>；</li><li>其他根据情况自行添加。</li></ul><h2 id="4-命名规范"><a href="#4-命名规范" class="headerlink" title="4. 命名规范"></a>4. 命名规范</h2><h3 id="4-1-命名原则"><a href="#4-1-命名原则" class="headerlink" title="4.1 命名原则"></a>4.1 命名原则</h3><ul><li>使名称足够长以便有一定的意义，并且足够短以避免冗长。</li><li>唯一名称在编程上仅用于将各项区分开。</li><li>表现力强的名称是为了帮助人们阅读，提供人们可以理解的名称是有意义的。</li><li>请确保选择的名称符合适用语言的规则和标准。</li></ul><h3 id="4-2-命名空间"><a href="#4-2-命名空间" class="headerlink" title="4.2    命名空间"></a>4.2    命名空间</h3><p>命名命名空间时的一般性规则是使用公司名称，后跟项目名称和可选的功能与设计。<br><code>示例</code>：namespace CompanyName.ProjectName.ModuleName</p><h3 id="4-3-类"><a href="#4-3-类" class="headerlink" title="4.3    类"></a>4.3    类</h3><ul><li>使用 Pascal 大小写。</li><li>用名词或名词短语命名类。</li><li>使用全称避免缩写，除非缩写已是一种公认的约定，如URL、HTML。</li><li>不要使用类型前缀，如在类名称上对类使用 C 前缀。例如，使用类名称 FileStream，而不是 CFileStream。 </li></ul><h3 id="4-4-接口"><a href="#4-4-接口" class="headerlink" title="4.4    接口"></a>4.4    接口</h3><ul><li>用名词或名词短语，或者描述行为的形容词命名接口。例如，接口名称 IComponent 使用描述性名词。接口名称 ICustomAttributeProvider 使用名词短语。名称 IPersistable 使用形容词。 </li><li>使用 Pascal 大小写。 </li><li>少用缩写。 </li><li>给接口名称加上字母 I 前缀，以指示该类型为接口。在定义类/接口对（其中类是接口的标准实现）时使用相似的名称。两个名称的区别应该只是接口名称上有字母 I 前缀。</li><li>当类是接口的标准执行时，定义这一对类/接口组合就要使用相似的名称。两个名称的不同之处只是接口名前有一个I前缀。</li></ul><h3 id="4-5-属性-Attribute"><a href="#4-5-属性-Attribute" class="headerlink" title="4.5 属性 (Attribute)"></a>4.5 属性 (Attribute)</h3><ul><li>将后缀 Attribute 添加到自定义属性类。</li></ul><h3 id="4-6-枚举-Enum"><a href="#4-6-枚举-Enum" class="headerlink" title="4.6    枚举 (Enum)"></a>4.6    枚举 (Enum)</h3><ul><li>对于 Enum 类型和值名称使用 Pascal 大小写。 </li><li>少用缩写。 </li><li>不要在 Enum 类型名称上使用 Enum 后缀。</li></ul><h3 id="4-7-参数"><a href="#4-7-参数" class="headerlink" title="4.7    参数"></a>4.7    参数</h3><ul><li>使用描述性参数名称。参数名称应当具有足够的描述性，以便参数的名称及其类型可用于在大多数情况下确定它的含义。 </li><li>对参数名称使用 Camel 大小写。 </li><li>使用描述参数的含义的名称，而不要使用描述参数的类型的名称。开发工具将提供有关参数的类型的有意义的信息。因此， 通过描述意义，可以更好地使用参数的名称。少用基于类型的参数名称，仅在适合使用它们的地方使用它们。 </li><li>不要使用保留的参数。保留的参数是专用参数，如果需要，可以在未来的版本中公开它们。相反，如果在类库的未来版本中需要更多的数据，请为方法添加新的重载。 </li><li>不要给参数名称加匈牙利语类型表示法的前缀。 </li></ul><h3 id="4-8-方法"><a href="#4-8-方法" class="headerlink" title="4.8    方法"></a>4.8    方法</h3><ul><li>使用动词或动词短语命名方法。 </li><li>使用 Pascal 大小写。</li></ul><h3 id="4-9-属性-property"><a href="#4-9-属性-property" class="headerlink" title="4.9    属性 (property)"></a>4.9    属性 (property)</h3><ul><li>使用名词或名词短语命名属性。 </li><li>使用 Pascal 大小写。 </li><li>不要使用匈牙利语表示法。</li></ul><h3 id="4-10-常量-const"><a href="#4-10-常量-const" class="headerlink" title="4.10    常量 (const)"></a>4.10    常量 (const)</h3><ul><li>所有单词大写，多个单词之间用 “_” 隔开。</li></ul><h3 id="4-11-字段-Field"><a href="#4-11-字段-Field" class="headerlink" title="4.11 字段(Field)"></a>4.11 字段(Field)</h3><ul><li>private、protected 使用 Camel 大小写。</li><li>public 使用 Pascal 大小写。</li><li>为了区分字段和局部变量，建议在首字母前加一下划线_。<br><code>ps</code>：C# 中通常字段只有 private，若需暴露，请使用属性。</li></ul>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 01.CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DDD-01介绍</title>
      <link href="//posts/08.%E6%9E%B6%E6%9E%84/01.DDD/01.%E4%BB%8B%E7%BB%8D/"/>
      <url>//posts/08.%E6%9E%B6%E6%9E%84/01.DDD/01.%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 08.架构 </category>
          
          <category> 01.DDD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java-Tomcat</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-Tomcat/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-Tomcat/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>Apache 基金会下的一款开源的 web 服务器。</p><h2 id="2-下载"><a href="#2-下载" class="headerlink" title="2.下载"></a>2.下载</h2><p><a href="http://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">Tomcat下载</a></p><h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><p>解压缩到指定目录</p><h3 id="3-1-目录结构"><a href="#3-1-目录结构" class="headerlink" title="3.1 目录结构"></a>3.1 目录结构</h3><ul><li>bin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。</li><li>conf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。</li><li>lib：库文件。tomcat运行时需要的jar包所在的目录</li><li>logs：日志</li><li>temp：临时产生的文件，即缓存</li><li>webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问</li><li>work：编译以后的class文件。</li></ul><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><h3 id="4-1-环境变量配置"><a href="#4-1-环境变量配置" class="headerlink" title="4.1 环境变量配置"></a>4.1 环境变量配置</h3><ol><li><strong>CATALINA_HOME</strong>：C:\Program Files\Tomcat 8.5（注：结尾不加分号）</li><li><strong>PATH</strong>:%CATALINA_HOME%\bin;</li><li><strong>CLASS_PATH</strong>:%CATALINA_HOME%\lib;</li></ol><h3 id="4-2-配置文件"><a href="#4-2-配置文件" class="headerlink" title="4.2 配置文件"></a>4.2 配置文件</h3><p>$CATALINA_HOME 目录下的 conf 目录，核心配置文件 server.xml。</p><h2 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h2><p>进入 $CATALINA_HOME 目录下的 bin 目录，运行 startup.bat 即可。</p><h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h3><ul><li><strong>localhost:8080</strong>:Tomcat默认主页</li></ul><h3 id="7-Eclipse集成"><a href="#7-Eclipse集成" class="headerlink" title="7 Eclipse集成"></a>7 Eclipse集成</h3><ul><li>“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。</li></ul><a id="more"></a><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java-JSP</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-JSP/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-JSP/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>JSP（Java Server Pages），一种动态网页开发技术，类似于 ASP。通常以<code>&lt;%</code>开头，以<code>%&gt;</code>结尾。</p><a id="more"></a><h2 id="2-特点（与CGI对比）"><a href="#2-特点（与CGI对比）" class="headerlink" title="2 特点（与CGI对比）"></a>2 特点（与CGI对比）</h2><ul><li>性能更加优越，因为JSP可以直接在HTML网页中动态嵌入元素而不需要单独引用CGI文件。</li><li>服务器调用的是已经编译好的JSP文件，而不像CGI/Perl那样必须先载入解释器和目标脚本。</li><li>JSP 基于Java Servlet API，因此，JSP拥有各种强大的企业级Java API，包括JDBC，JNDI，EJB，JAXP等等。</li><li>JSP页面可以与处理业务逻辑的 Servlet 一起使用，这种模式被Java servlet 模板引擎所支持。</li></ul><h2 id="3-JSP-流程"><a href="#3-JSP-流程" class="headerlink" title="3 JSP 流程"></a>3 JSP 流程</h2><p><img src="/images/posts/jsp-arch.jpg" alt="JSP 位置"><br><img src="/images/posts/jsp-processing.jpg" alt="JSP 流程"></p><ul><li>浏览器发送一个 HTTP 请求给服务器。</li><li>Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成。</li><li>JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码。</li><li>JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎。</li><li>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。</li><li>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。</li><li>Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样。</li></ul><h2 id="4-JSP-生命周期"><a href="#4-JSP-生命周期" class="headerlink" title="4 JSP 生命周期"></a>4 JSP 生命周期</h2><p><img src="/images/posts/jsp_life_cycle.jpg" alt="JSP 生命周期"></p><ul><li><strong>编译阶段</strong>：servlet容器编译servlet源文件，生成servlet类。若未修改，则跳过。<ul><li>解析JSP文件。</li><li>将JSP文件转为servlet。</li><li>编译servlet。</li></ul></li><li><p><strong>初始化阶段</strong>：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//JSP初始化代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行阶段</strong>：调用与JSP对应的servlet实例的服务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">  <span class="comment">//服务端处理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>销毁阶段</strong>：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//清理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-JSP-语法"><a href="#5-JSP-语法" class="headerlink" title="5 JSP 语法"></a>5 JSP 语法</h2><h3 id="5-1-脚本程序"><a href="#5-1-脚本程序" class="headerlink" title="5.1 脚本程序"></a>5.1 脚本程序</h3><p>可包含任意量的Java语句、变量、方法或表达式。格式：<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% 代码片段 %&gt;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:scriptlet&gt;</span><br><span class="line">  代码片段</span><br><span class="line">&lt;/jsp:scriptlet&gt;</span><br></pre></td></tr></table></figure></p><h3 id="5-2-头部支持中文"><a href="#5-2-头部支持中文" class="headerlink" title="5.2 头部支持中文"></a>5.2 头部支持中文</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html;charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="5-3-声明"><a href="#5-3-声明" class="headerlink" title="5.3 声明"></a>5.3 声明</h3><p>一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! declaration;[ declaration;]+ ... %&gt;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:declaration&gt;</span><br><span class="line">  代码片段</span><br><span class="line">&lt;/jsp:declaration&gt;</span><br></pre></td></tr></table></figure></p><h3 id="5-4-表达式"><a href="#5-4-表达式" class="headerlink" title="5.4 表达式"></a>5.4 表达式</h3><p>一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。<br><code>注意：</code>不能以分号来结束。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 表达式 %&gt;</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:expression&gt;</span><br><span class="line">   表达式</span><br><span class="line">&lt;/jsp:expression&gt;</span><br></pre></td></tr></table></figure></p><h3 id="5-5-注释"><a href="#5-5-注释" class="headerlink" title="5.5 注释"></a>5.5 注释</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--注释--%&gt;</span><br></pre></td></tr></table></figure><h3 id="5-6-指令"><a href="#5-6-指令" class="headerlink" title="5.6 指令"></a>5.6 指令</h3><p>设置与整个JSP页面相关的属性。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ directive attribute=<span class="string">"value"</span> %&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>&lt;%@ page … %&gt;</td><td>定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td></tr><tr><td>&lt;%@ include … %&gt;</td><td>包含其他文件</td></tr><tr><td>&lt;%@ taglib … %&gt;</td><td>引入标签库的定义，可以是自定义标签</td></tr></tbody></table><h3 id="5-7-行为"><a href="#5-7-行为" class="headerlink" title="5.7 行为"></a>5.7 行为</h3><p>使用XML语法结构来控制servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。<br>行为标签只有一种语法格式，它严格遵守XML标准。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:action_name attribute=<span class="string">"value"</span> /&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>jsp:include</td><td>用于在当前页面中包含静态或动态资源</td></tr><tr><td>jsp:useBean</td><td>寻找和初始化一个JavaBean组件</td></tr><tr><td>jsp:setProperty</td><td>设置 JavaBean组件的值</td></tr><tr><td>jsp:getProperty</td><td>将 JavaBean组件的值插入到 output中</td></tr><tr><td>jsp:forward</td><td>从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td></tr><tr><td>jsp:plugin</td><td>用于在生成的HTML页面中包含Applet和JavaBean对象</td></tr><tr><td>jsp:element</td><td>动态创建一个XML元素</td></tr><tr><td>jsp:attribute</td><td>定义动态创建的XML元素的属性</td></tr><tr><td>jsp:body</td><td>定义动态创建的XML元素的主体</td></tr><tr><td>jsp:text</td><td>用于封装模板数据</td></tr></tbody></table><h3 id="5-8-隐含对象"><a href="#5-8-隐含对象" class="headerlink" title="5.8 隐含对象"></a>5.8 隐含对象</h3><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>request</td><td>HttpServletRequest类的实例</td></tr><tr><td>response</td><td>HttpServletResponse类的实例</td></tr><tr><td>out</td><td>PrintWriter类的实例，用于把结果输出至网页上</td></tr><tr><td>session</td><td>HttpSession类的实例</td></tr><tr><td>application</td><td>ServletContext类的实例，与应用上下文有关</td></tr><tr><td>config</td><td>ServletConfig类的实例</td></tr><tr><td>pageContext</td><td>PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问</td></tr><tr><td>page</td><td>类似于Java类中的this关键字</td></tr><tr><td>Exception</td><td>Exception类的对象，代表发生错误的JSP页面中对应的异常对象</td></tr></tbody></table><h3 id="5-9-控制流语句"><a href="#5-9-控制流语句" class="headerlink" title="5.9 控制流语句"></a>5.9 控制流语句</h3><h4 id="5-9-1-判断语句"><a href="#5-9-1-判断语句" class="headerlink" title="5.9.1 判断语句"></a>5.9.1 判断语句</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;% <span class="keyword">if</span>(flag)&#123; %&gt;</span><br><span class="line">  &lt;p&gt;True&lt;/p&gt;</span><br><span class="line">&lt;% &#125;<span class="keyword">else</span>&#123; %&gt;</span><br><span class="line">  &lt;p&gt;False&lt;/p&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="5-9-2-循环语句"><a href="#5-9-2-循环语句" class="headerlink" title="5.9.2 循环语句"></a>5.9.2 循环语句</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">for</span> ( index = <span class="number">1</span>; index &lt;= <span class="number">3</span>; index++)&#123; %&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;%= index %&gt; </span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="5-10-运算符"><a href="#5-10-运算符" class="headerlink" title="5.10 运算符"></a>5.10 运算符</h3><p>JSP支持所有Java逻辑和算术运算符。</p><h3 id="5-11-字面量"><a href="#5-11-字面量" class="headerlink" title="5.11 字面量"></a>5.11 字面量</h3><ul><li>布尔值(boolean)：true 和 false;</li><li>整型(int)：与 Java 中的一样;</li><li>浮点型(float)：与 Java 中的一样;</li><li>字符串(string)：以单引号或双引号开始和结束;</li><li>Null：null。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java-名词解释</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<h2 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1 名词解释"></a>1 名词解释</h2><table><thead><tr><th>缩写</th><th>全称</th><th>详细信息</th></tr></thead><tbody><tr><td>POJOs</td><td>Plain Old Java Objects</td><td>普通的 Java对象</td></tr><tr><td>DAO</td><td>Data Access Objects</td><td>数据访问对象</td></tr><tr><td>CGI</td><td>Common Gateway Interfa e</td><td>公共网关接口</td></tr><tr><td>JSP</td><td>Java Server Pages</td><td>Java服务页面（动态网页开发技术）</td></tr></tbody></table><a id="more"></a><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java-MyBatis</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-MyBatis/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-MyBatis/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>MyBatis 是一款<strong>持久层框架</strong>，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><a id="more"></a><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java-Maven</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-Maven/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-Maven/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>Maven 是一个项目构建和管理的自动化工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。</p><p>Maven 使用惯例优于配置的原则 。它要求在没有定制之前，所有的项目都有如下的结构：</p><table><thead><tr><th>目录</th><th>目的</th></tr></thead><tbody><tr><td>${basedir}</td><td>存放 pom.xml和所有的子目录</td></tr><tr><td>${basedir}/src/main/java</td><td>项目的 java源代码</td></tr><tr><td>${basedir}/src/main/resources</td><td>项目的资源，比如说 property文件</td></tr><tr><td>${basedir}/src/test/java</td><td>项目的测试类，比如说 JUnit代码</td></tr><tr><td>${basedir}/src/test/resources</td><td>测试使用的资源</td></tr></tbody></table><p>一个 maven 项目在默认情况下会产生 JAR 文件，另外 ，编译后 的 classes 会放在 ${basedir}/target/classes 下面， JAR 文件会放在 ${basedir}/target 下面。<br><a id="more"></a></p><h2 id="2-下载-amp-安装-amp-配置"><a href="#2-下载-amp-安装-amp-配置" class="headerlink" title="2 下载&amp;安装&amp;配置"></a>2 下载&amp;安装&amp;配置</h2><h3 id="2-1-前提"><a href="#2-1-前提" class="headerlink" title="2.1 前提"></a>2.1 前提</h3><p>需安装配置 java 开发环境</p><h3 id="2-2-下载地址"><a href="#2-2-下载地址" class="headerlink" title="2.2 下载地址"></a>2.2 下载地址</h3><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven下载</a></p><h3 id="2-3-安装"><a href="#2-3-安装" class="headerlink" title="2.3 安装"></a>2.3 安装</h3><p>直接解压缩到指定目录</p><h3 id="2-4-配置"><a href="#2-4-配置" class="headerlink" title="2.4 配置"></a>2.4 配置</h3><p>配置文件：<code>‪C:\Program Files\apache-maven-3.5.0\conf\settings.xml</code></p><ol><li><strong>MAVEN_HOME</strong>:C:\Program Files\apache-maven-3.5.0（注：结尾不加分号）</li><li><strong>PATH</strong>:%MAVEN_HOME%\bin;</li><li><strong>MAVEN_OPTS</strong>: -Xms128m -Xmx512m;(设置Maven可用内存大小)</li><li>修改本地仓库路径：setting.xml 中的 localRepository。</li></ol><h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><ul><li><strong>mvn -v</strong>:版本号</li></ul><h3 id="2-6-集成IDE"><a href="#2-6-集成IDE" class="headerlink" title="2.6 集成IDE"></a>2.6 集成IDE</h3><ul><li>Eclipse IDE：<a href="https://www.eclipse.org/m2e/" target="_blank" rel="noopener">M2Eclipse</a>，直接搜索 Maven 即可。<ul><li>Launching Maven builds from within Eclipse</li><li>Dependency management for Eclipse build path based on Maven’s pom.xml</li><li>Resolving Maven dependencies from the Eclipse workspace without installing to local Maven repository</li><li>Automatic downloading of the required dependencies and sources from the remote Maven repositories</li><li>Wizards for creating new Maven projects, pom.xml and to enable Maven support on existing projects</li><li>Quick search for dependencies in remote Maven repositories</li><li>Quick fixes in the Java editor for looking up required dependencies/jars by the class or package name</li><li>Integration with other Eclipse tools, such as WTP, AJDT, Mylyn, Subclipse and others.</li></ul></li><li>Intellij IDEA:<a href="https://www.jetbrains.com/help/idea/maven.html" target="_blank" rel="noopener">Intellij IDEA-Maven</a></li></ul><h2 id="3-核心概念"><a href="#3-核心概念" class="headerlink" title="3 核心概念"></a>3 核心概念</h2><h3 id="3-1-POM（Project-Object-Model）-ps-个人理解为类似于VS的csproj文件，用于管理项目"><a href="#3-1-POM（Project-Object-Model）-ps-个人理解为类似于VS的csproj文件，用于管理项目" class="headerlink" title="3.1 POM（Project Object Model）[ps:个人理解为类似于VS的csproj文件，用于管理项目]"></a>3.1 POM（Project Object Model）[ps:个人理解为类似于VS的csproj文件，用于管理项目]</h3><p>pom 是一个 xml，是maven工作的基础，在执行 task 或者 goal 时，maven 会去项目根目录下读取 pom.xml 获得需要的配置信息。该文件包括项目的信息和 maven build 项目所需的配置信息，通常有项目信息(如版本、成员)、项目的依赖、插件和 goal 、build 选项等等。<br>pom 是可继承的，大型项目中，子模块的 pom 需指定父模块的 pom。<br>节点定义：</p><ul><li>project：pom文件的顶级元素</li><li>modelVersion：所使用的object model版本，为了确保稳定的使用，这个元素是强制性的。除非maven开发者升级模板，否则不需要修改</li><li>groupId：是项目创建团体或组织的唯一标志符，通常是域名倒写，如groupId  org.apache.maven.plugins就是为所有maven插件预留的</li><li>artifactId：是项目artifact唯一的基地址名</li><li>packaging：artifact打包的方式，如jar、war、ear等等。默认为jar。这个不仅表示项目最终产生何种后缀的文件，也表示build过程使用什么样的lifecycle。</li><li>version：artifact的版本，通常能看见为类似0.0.1-SNAPSHOT，其中SNAPSHOT表示项目开发中，为开发版本</li><li>name：表示项目的展现名，在maven生成的文档中使用</li><li>url：表示项目的地址，在maven生成的文档中使用</li><li>description：表示项目的描述，在maven生成的文档中使用</li><li>dependencies：表示依赖，在子节点dependencies中添加具体依赖的groupId - artifactId和version</li><li>build：表示build配置</li><li>parent：表示父pom</li></ul><h3 id="3-2-Artifact（类似于-nuget-中的包）"><a href="#3-2-Artifact（类似于-nuget-中的包）" class="headerlink" title="3.2 Artifact（类似于 nuget 中的包）"></a>3.2 Artifact（类似于 nuget 中的包）</h3><ul><li>需指定项目要产生的文件，如 jar，源文件，二进制，war，pom 等，类似于 VS 中的项目类型。</li><li>groupId:artifactId:version 组成的标识符唯一识别，唯一确定了一个 artifact。</li><li>需要被使用(依赖)的 artifact 都要放在仓库(见Repository)中。</li></ul><h3 id="3-3-Repositories（仓储）"><a href="#3-3-Repositories（仓储）" class="headerlink" title="3.3 Repositories（仓储）"></a>3.3 Repositories（仓储）</h3><ul><li>主要用来存储 Artifact。</li><li>可分为本地和远程。<ul><li>本地对 Windows 系统存放于<code>用户/.m2/repository</code>，可修改。</li></ul></li></ul><h3 id="3-4-Build-Lifecycle（构建生存周期）"><a href="#3-4-Build-Lifecycle（构建生存周期）" class="headerlink" title="3.4 Build Lifecycle（构建生存周期）"></a>3.4 Build Lifecycle（构建生存周期）</h3><p>指一个项目的构建过程，由 phase（片段） 构成。分三种：</p><ul><li>default：处理项目的部署，大致流程：<ol><li>validate 验证项目是否正确以及必须的信息是否可用</li><li>compile 编译源代码</li><li>test 测试编译后的代码，即执行单元测试代码</li><li>package 打包编译后的代码，在target目录下生成package文件</li><li>integration-test 处理package以便需要时可以部署到集成测试环境</li><li>verify 检验package是否有效并且达到质量标准</li><li>install 安装package到本地仓库，方便本地其它项目使用</li><li>deploy 部署，拷贝最终的package到远程仓库和替他开发这或项目共享，在集成或发布环境完成</li></ol></li><li>clean：处理项目的清理</li><li>site：处理项目的文档生成</li></ul><p>注意：phase 是有序的，执行指定的 phase 时，会先执行完之前的 phase。</p><h3 id="3-5-Goal（任务）"><a href="#3-5-Goal（任务）" class="headerlink" title="3.5 Goal（任务）"></a>3.5 Goal（任务）</h3><p>表示一个特定的任务，区别于 build。</p><ul><li>mvn compile：编译</li><li>mvn package：打包</li><li>mvn deploy：部署</li><li>mvn clean install：先执行 clean 之前的 phase，在执行 clean，install。</li><li>mvn install：安装到本地</li></ul><h3 id="3-6-Archetype（原型）"><a href="#3-6-Archetype（原型）" class="headerlink" title="3.6 Archetype（原型）"></a>3.6 Archetype（原型）</h3><p>类似于 .net core 的项目模板</p><h2 id="4-常用参数"><a href="#4-常用参数" class="headerlink" title="4 常用参数"></a>4 常用参数</h2><ul><li>mvn -e：显示详细错误</li><li>mvn -U：强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖）</li><li>mvn -o：运行offline模式，不联网更新依赖</li><li>mvn -N：仅在当前项目模块执行命令，关闭reactor</li><li>mvn -pl：module_name在指定模块上执行命令</li><li>mvn -ff：在递归执行命令过程中，一旦发生错误就直接退出</li><li>mvn -Dxxx=yyy：指定java全局属性</li><li>mvn -Pxxx：引用profile xxx</li><li>mvn test-compile：编译测试代码</li><li>mvn test：运行程序中的单元测试</li><li>mvn compile：编译项目</li><li>mvn package：打包，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件</li><li>mvn install：打包并安装到本地仓库，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。每个phase都可以作为goal，也可以联合，如之前介绍的mvn clean install</li><li>mvn archetype:generate：创建maven项目</li><li>mvn package：打包，上面已经介绍过了</li><li>mvn package：-Prelease打包，并生成部署用的包，比如deploy/*.tgz</li><li>mvn install：打包并安装到本地库</li><li>mvn eclipse:eclipse：生成eclipse项目文件</li><li>mvn eclipse:clean：清除eclipse项目文件</li><li>mvn site：生成项目相关信息的网站</li><li>mvn -Dwtpversion=2.0：指定maven版本</li><li>mvn -Dmaven.test.skip=true：如果命令包含了test phase，则忽略单元测试</li><li>mvn -DuserProp=filePath：指定用户自定义配置文件位置</li><li>mvn -DdownloadSources=true -Declipse.addVersionToProjectName=true eclipse:eclipse：生成eclipse项目文件，尝试从仓库下载源代码，并且生成的项目包含模块版本（注意如果使用公用POM，上述的开关缺省已打开）</li><li>mvn -Dsurefire.useFile=false：如果执行单元测试出错，用该命令可以在console输出失败的单元测试及相关信息</li><li>set MAVEN_OPTS=-Xmx512m -XX:MaxPermSize=256m：调大jvm内存和持久代，maven/jvm out of memory error</li><li>mvn -X：maven log level设定为debug在运行</li><li>mvn debug：运行jpda允许remote debug</li><li>mvn –help 帮助</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://maven.apache.org/index.html" target="_blank" rel="noopener">Maven官网</a><br>2 <a href="http://blog.csdn.net/column/details/maven-it.html" target="_blank" rel="noopener">Maven入门</a><br>3 <a href="http://www.trinea.cn/android/maven/" target="_blank" rel="noopener">Maven介绍，包括作用、核心概念、用法、常用命令、扩展及配置</a><br>4 <a href="http://www.oracle.com/technetwork/cn/community/java/apache-maven-getting-started-1-406235-zhs.html" target="_blank" rel="noopener">Maven入门介绍</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java-反射</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%8F%8D%E5%B0%84/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<h2 id="1-Class（java-lang-Class）"><a href="#1-Class（java-lang-Class）" class="headerlink" title="1 Class（java.lang.Class）"></a>1 Class（java.lang.Class）</h2><p>该类是反射的核心，获取类的Class对象引用方式：</p><ul><li>使用类文字，如Test.class、double.class（等价于Doubel.TYPE）和void.class；</li><li>使用Object类的getClass()方法</li><li>使用Class类的forName()静态方法</li></ul><a id="more"></a><h2 id="2-字段"><a href="#2-字段" class="headerlink" title="2 字段"></a>2 字段</h2><ul><li>getFields()方法返回所有可访问的公共字段在类中声明或继承自超类。</li><li>getDeclaredFields()方法返回所有字段只出现在类的声明中(不是从继承的字段)。</li><li>getField(String name)和 getDeclaredField(String name)通过字段名获取 Field 对象。</li></ul><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h2><ul><li>java.lang.reflect.Method（继承自抽象类Executable） 类的实例表示一个方法。</li><li>java.lang.reflect.Constructor（继承自抽象类Executable） 类的实例表示一个构造函数。</li><li>Parameter 类：可执行文件中的参数。默认情况，参数名称不存储在类文件中，而类似于arg0,arg1。</li><li>TypeVariable：通用方法或构造函数的类型参数。</li><li>Executable类（抽象）：可执行。<ul><li>getParameters()：获取参数数组；</li><li>getExceptionTypes()：获取异常数组；</li><li>getTypeParameters()：获取类型参数数组；</li><li>getModifiers()：获取修饰符</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[]  getMethods()</span><br><span class="line">Method[]  getDeclaredMethods()：返回当前类的所有声明的构造函数。</span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name,  Class...  parameterTypes)</span></span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name,  Class...  parameterTypes)</span></span></span><br></pre></td></tr></table></figure><h2 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4 构造函数"></a>4 构造函数</h2><ul><li>Constructor[] getConstructors()：返回当前和超类的所有公共构造函数。</li><li>Constructor[]  getDeclaredConstructors()</li><li>Constructor<t> getConstructor(Class…  parameterTypes)</t></li><li>Constructor<t> getDeclaredConstructor(Class…  parameterTypes)</t></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java-集合</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E9%9B%86%E5%90%88/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h2 id="1-集合遍历"><a href="#1-集合遍历" class="headerlink" title="1 集合遍历"></a>1 集合遍历</h2><h3 id="1-1-迭代器（实现-Iterator-接口的实例）"><a href="#1-1-迭代器（实现-Iterator-接口的实例）" class="headerlink" title="1.1 迭代器（实现 Iterator 接口的实例）"></a>1.1 迭代器（实现 Iterator<e> 接口的实例）</e></h3><ul><li>检查是否有尚未访问的元素。</li><li>访问集合中的下一个元素。</li><li>删除集合的最后访问元素。</li></ul><h3 id="1-2-for-each循环"><a href="#1-2-for-each循环" class="headerlink" title="1.2 for-each循环"></a>1.2 for-each循环</h3><ul><li>for-each循环遍历任何实现类实现Iterable接口的集合。</li></ul><p><code>ps:</code>不能使用for-each循环从集合中删除元素，将抛出ConcurrentModificationException异常。</p><h3 id="1-3-forEach-方法"><a href="#1-3-forEach-方法" class="headerlink" title="1.3 forEach()方法"></a>1.3 forEach()方法</h3><ul><li>Iterable接口包含一个新的 forEach(Consumer action)方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a list of strings</span></span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">"A"</span>);</span><br><span class="line">    names.add(<span class="string">"B"</span>);</span><br><span class="line">    names.add(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">    names.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-集合（Set接口）（唯一对象的集合）"><a href="#2-集合（Set接口）（唯一对象的集合）" class="headerlink" title="2 集合（Set接口）（唯一对象的集合）"></a>2 集合（Set接口）（唯一对象的集合）</h3><ul><li>集合是唯一元素的集合。当向集合添加重复元素时，它们将被忽略。</li><li>Java最多允许一个Set中的一个空元素。 </li><li>Set 中元素的排序并不重要。Java不保证 Set 中元素的排序。</li></ul><h3 id="2-1-数学集"><a href="#2-1-数学集" class="headerlink" title="2.1 数学集"></a>2.1 数学集</h3><ul><li>HashSet 类：不保证顺序元素</li><li>LinkedHashSet 类：保证插入元素顺序</li></ul><h3 id="2-2-排序集"><a href="#2-2-排序集" class="headerlink" title="2.2 排序集"></a>2.2 排序集</h3><p>SortedSet 接口表示Java集合中的排序集合框架。</p><ul><li>元素实现Comparable接口，将使用compareTo()方法排序，称之为自然排序；</li><li>传递一个比较器自定义排序；</li><li>若指定Comparator，则用Comparator排序而忽略Comparable。</li><li>TreeSet是SortedSet接口的一个实现。</li></ul><h3 id="2-3-导航集（有序集）"><a href="#2-3-导航集（有序集）" class="headerlink" title="2.3 导航集（有序集）"></a>2.3 导航集（有序集）</h3><p>NavigableSet 表示Java集合中的可导航集合框架。NavigableSet 接口继承了SortedSet接口和扩展 SortedSet 。</p><ul><li>TreeSet 类是 NavigableSet 接口的实现类之一。</li></ul><h2 id="3-列表（List接口）（有序、可重复）"><a href="#3-列表（List接口）（有序、可重复）" class="headerlink" title="3 列表（List接口）（有序、可重复）"></a>3 列表（List接口）（有序、可重复）</h2><ul><li>ArrayList：访问快，添加删除慢</li><li>LinkedList：访问慢，添加删除快</li><li>LinkIterator接口（继承Iterator接口）遍历列表</li></ul><h2 id="4-队列（Queue接口）（先进先出FIFO）"><a href="#4-队列（Queue接口）（先进先出FIFO）" class="headerlink" title="4 队列（Queue接口）（先进先出FIFO）"></a>4 队列（Queue接口）（先进先出FIFO）</h2><ul><li>LinkedList：简单的队列允许在尾部插入和从头部移除。</li><li>PriorityQueue：优先级队列为每个元素分配优先级，并允许从队列中删除具有最高优先级的元素。</li><li>DelayQueue：延迟队列向每个元素添加延迟，并仅在其延迟已过去时删除该元素。</li><li>Deque、ArrayDeque、LinkedList（FIFO或LIFO）：双端队列允许其元件从头部和尾部插入和移除。</li><li>BlockingQueue接口（线程安全、适用于生产者/消费者）、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue：阻塞队列阻塞线程，当线程已满时向其添加元素，当线程为空时，它阻止线程从中删除元素。</li><li>TransferQueue：传输队列是阻塞队列，其中对象的切换发生在生产者线程和消费者线程之间。</li><li>阻塞双端队列是双端队列和阻塞队列的组合。</li></ul><h2 id="5-映射（Map-lt-K-V-gt-接口）-（键不能重复）"><a href="#5-映射（Map-lt-K-V-gt-接口）-（键不能重复）" class="headerlink" title="5 映射（Map&lt;K,V&gt;接口） （键不能重复）"></a>5 映射（Map&lt;K,V&gt;接口） （键不能重复）</h2><ul><li>HashMap</li><li>LinkedHashMap</li><li>WeakHashMap</li></ul><h2 id="6-Collection-类"><a href="#6-Collection-类" class="headerlink" title="6 Collection 类"></a>6 Collection 类</h2><p>该类中包含许多静态的辅助方法用于处理集合，如排序、搜索等。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java各版本新特性</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h2 id="1-Java8-新特性（2014-3-18）"><a href="#1-Java8-新特性（2014-3-18）" class="headerlink" title="1 Java8 新特性（2014/3/18）"></a>1 Java8 新特性（2014/3/18）</h2><ul><li><p><strong>Lambda 表达式</strong> − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 java 7 排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortUsingJava7</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;   </span><br><span class="line">  Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 java 8 排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortUsingJava8</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;</span><br><span class="line">  Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p></li><li><p><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Vehicle vehicle = <span class="keyword">new</span> Car();</span><br><span class="line">      vehicle.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blowHorn</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"按喇叭!!!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FourWheeler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆四轮车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span>, <span class="title">FourWheeler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Vehicle.<span class="keyword">super</span>.print();</span><br><span class="line">      FourWheeler.<span class="keyword">super</span>.print();</span><br><span class="line">      Vehicle.blowHorn();</span><br><span class="line">      System.out.println(<span class="string">"我是一辆汽车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</p></li><li><p><strong>Stream API（链式编程）</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li><li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。  </li><li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream()</span><br><span class="line">                                .filter(string -&gt; !string.isEmpty())</span><br><span class="line">                                .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"筛选列表: "</span> + filtered);</span><br><span class="line">String mergedString = strings.stream()</span><br><span class="line">                              .filter(string -&gt; !string.isEmpty())</span><br><span class="line">                              .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Date Time API − 加强对日期与时间的处理。</p></li><li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li><li>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul><a id="more"></a><h1 id="2-Java9-新特性（）"><a href="#2-Java9-新特性（）" class="headerlink" title="2 Java9 新特性（）"></a>2 Java9 新特性（）</h1><h1 id="3-Java10-新特性（2018-3-20）"><a href="#3-Java10-新特性（2018-3-20）" class="headerlink" title="3 Java10 新特性（2018/3/20）"></a>3 Java10 新特性（2018/3/20）</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础知识02</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8602/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8602/</url>
      <content type="html"><![CDATA[<h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-枚举（Enumeration）"><a href="#1-1-枚举（Enumeration）" class="headerlink" title="1.1 枚举（Enumeration）"></a>1.1 枚举（Enumeration）</h3><p>定义了一种从数据结构中取回连续元素的方式，已被迭代器取代。</p><h3 id="1-2-位集合（BitSet）"><a href="#1-2-位集合（BitSet）" class="headerlink" title="1.2 位集合（BitSet）"></a>1.2 位集合（BitSet）</h3><p>实现了一组可以单独设置和清除的位或标志。该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</p><h3 id="1-3-向量（Vector）"><a href="#1-3-向量（Vector）" class="headerlink" title="1.3 向量（Vector）"></a>1.3 向量（Vector）</h3><ul><li>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。</li><li>和数组一样，Vector对象的元素也能通过索引访问。</li><li>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</li></ul><h3 id="1-4-栈（Stack）"><a href="#1-4-栈（Stack）" class="headerlink" title="1.4 栈（Stack）"></a>1.4 栈（Stack）</h3><p>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</p><h3 id="1-5-字典（Dictionary）（已过时，使用Map接口替代）"><a href="#1-5-字典（Dictionary）（已过时，使用Map接口替代）" class="headerlink" title="1.5 字典（Dictionary）（已过时，使用Map接口替代）"></a>1.5 字典（Dictionary）（已过时，使用Map接口替代）</h3><p>字典（Dictionary） 类是一个<strong>抽象类</strong>，它定义了键映射到值的数据结构。</p><h3 id="1-6-哈希表（Hashtable）"><a href="#1-6-哈希表（Hashtable）" class="headerlink" title="1.6 哈希表（Hashtable）"></a>1.6 哈希表（Hashtable）</h3><p>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。</p><h3 id="1-7-属性（Properties）"><a href="#1-7-属性（Properties）" class="headerlink" title="1.7 属性（Properties）"></a>1.7 属性（Properties）</h3><p>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</p><a id="more"></a><h2 id="2-集合框架"><a href="#2-集合框架" class="headerlink" title="2 集合框架"></a>2 <strong>集合框架</strong></h2><p>集合框架是一个用来代表和操纵集合的统一架构。</p><h3 id="2-1-设计目标"><a href="#2-1-设计目标" class="headerlink" title="2.1 设计目标"></a>2.1 设计目标</h3><ul><li>高性能,基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li><li>允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li><li>对一个集合的扩展和适应必须是简单的。</li></ul><h3 id="2-2-内容"><a href="#2-2-内容" class="headerlink" title="2.2 内容"></a>2.2 内容</h3><ul><li>接口：是代表集合的抽象数据类型。接口允许集合独立操纵其代表的细节。在面向对象的语言，接口通常形成一个层次。</li><li>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。</li><li>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul><h3 id="2-3-集合接口"><a href="#2-3-集合接口" class="headerlink" title="2.3 集合接口"></a>2.3 集合接口</h3><table><thead><tr><th>接口</th><th>描述</th></tr></thead><tbody><tr><td>Collection 接口</td><td>允许你使用一组对象，是Collection层次结构的根接口。</td></tr><tr><td>List 接口</td><td>继承于Collection和一个 List实例存储一个有序集合的元素。</td></tr><tr><td>Set</td><td>继承于 Collection，是一个不包含重复元素的集合。</td></tr><tr><td>SortedSet</td><td>继承于Set保存有序的集合。</td></tr><tr><td>Map</td><td>将唯一的键映射到值。</td></tr><tr><td>Map.Entry</td><td>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</td></tr><tr><td>SortedMap</td><td>继承于Map，使Key保持在升序排列。</td></tr><tr><td>Enumeration</td><td>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</td></tr></tbody></table><h3 id="2-4-集合类"><a href="#2-4-集合类" class="headerlink" title="2.4 集合类"></a>2.4 集合类</h3><table><thead><tr><th>类名</th><th>描述</th></tr></thead><tbody><tr><td>AbstractCollection</td><td>实现了大部分的集合接口。</td></tr><tr><td>AbstractList</td><td>继承于AbstractCollection 并且实现了大部分List接口。</td></tr><tr><td>AbstractSequentialList</td><td>继承于AbstractList，提供了对数据元素的链式访问而不是随机访问。</td></tr><tr><td>LinkedList</td><td>继承于 AbstractSequentialList，实现了一个链表。</td></tr><tr><td>ArrayList</td><td>通过继承AbstractList，实现动态数组。</td></tr><tr><td>AbstractSet</td><td>继承于AbstractCollection 并且实现了大部分Set接口。</td></tr><tr><td>HashSet</td><td>继承了AbstractSet，并且使用一个哈希表。</td></tr><tr><td>LinkedHashSet</td><td>具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。</td></tr><tr><td>TreeSet</td><td>继承于AbstractSet，使用元素的自然顺序对元素进行排序.</td></tr><tr><td>AbstractMap</td><td>实现了大部分的Map接口。</td></tr><tr><td>HashMap</td><td>继承了HashMap，并且使用一个哈希表。</td></tr><tr><td>TreeMap</td><td>继承了AbstractMap，并且使用一颗树。</td></tr><tr><td>WeakHashMap</td><td>继承AbstractMap类，使用弱密钥的哈希表。</td></tr><tr><td>LinkedHashMap</td><td>继承于HashMap，使用元素的自然顺序对元素进行排序.</td></tr><tr><td>IdentityHashMap</td><td>继承AbstractMap类，比较文档时使用引用相等。</td></tr></tbody></table><h2 id="3-序列化"><a href="#3-序列化" class="headerlink" title="3 序列化"></a>3 序列化</h2><ul><li>一个类的对象要想序列化成功，必须满足两个条件：<ul><li>该类必须实现 java.io.Serializable 对象。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的（transient ）。</li></ul></li><li><p>ObjectOutputStream（writeObject）—：序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></li><li><p>ObjectInputStream（readObject）：反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4 网络编程"></a>4 网络编程</h2><h3 id="4-1-网络协议（java-net）"><a href="#4-1-网络协议（java-net）" class="headerlink" title="4.1 网络协议（java.net）"></a>4.1 网络协议（java.net）</h3><ul><li>TCP： TCP是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称TCP / IP。</li><li>UDP:UDP是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。</li></ul><h3 id="4-2-Socket（java-net-Socket）"><a href="#4-2-Socket（java-net-Socket）" class="headerlink" title="4.2 Socket（java.net.Socket）"></a>4.2 Socket（java.net.Socket）</h3><p>主要使用ServerSocket和Socket类</p><ul><li><ol><li>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</li></ol></li><li><ol start="2"><li>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li></ol></li><li><ol start="3"><li>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</li></ol></li><li><ol start="4"><li>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</li></ol></li><li><ol start="5"><li>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</li></ol></li></ul><h2 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5 多线程"></a>5 多线程</h2><h3 id="5-1-线程的生命周期"><a href="#5-1-线程的生命周期" class="headerlink" title="5.1 线程的生命周期"></a>5.1 线程的生命周期</h3><p><img src="/images/posts/Java_Thread.jpg" alt="Thread"></p><ul><li>新建状态:使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</li><li>就绪状态:当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</li><li>运行状态:如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</li><li>阻塞状态:如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li></ul></li><li>死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</li></ul><h3 id="5-2-线程的优先级"><a href="#5-2-线程的优先级" class="headerlink" title="5.2 线程的优先级"></a>5.2 线程的优先级</h3><ul><li>线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</li><li>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</li></ul><h3 id="5-3-创建线程"><a href="#5-3-创建线程" class="headerlink" title="5.3 创建线程"></a>5.3 创建线程</h3><ul><li>通过实现 Runnable 接口；</li><li>通过继承 Thread 类本身；</li><li>通过 Callable 和 Future 创建线程。</li></ul><h2 id="6-文档注释"><a href="#6-文档注释" class="headerlink" title="6 文档注释"></a>6 文档注释</h2><h3 id="6-1-javadoc-标签"><a href="#6-1-javadoc-标签" class="headerlink" title="6.1 javadoc 标签"></a>6.1 javadoc 标签</h3><table><thead><tr><th>标签</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>@author</td><td>标识一个类的作者</td><td>@author description</td></tr><tr><td>@deprecated</td><td>指名一个过期的类或成员</td><td>@deprecated description</td></tr><tr><td>{@docRoot}</td><td>指明当前文档根目录的路径</td><td>Directory Path</td></tr><tr><td>@exception</td><td>标志一个类抛出的异常</td><td>@exception exception-name explanation</td></tr><tr><td>{@inheritDoc}</td><td>从直接父类继承的注释</td><td>Inherits a comment from the immediate surperclass.</td></tr><tr><td>{@link}</td><td>插入一个到另一个主题的链接</td><td>{@link name text}</td></tr><tr><td>{@linkplain}</td><td>插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td>Inserts an in-line link to another topic.</td></tr><tr><td>@param</td><td>说明一个方法的参数</td><td>@param parameter-name explanation</td></tr><tr><td>@return</td><td>说明返回值类型</td><td>@return explanation</td></tr><tr><td>@see</td><td>指定一个到另一个主题的链接</td><td>@see anchor</td></tr><tr><td>@serial</td><td>说明一个序列化属性</td><td>@serial description</td></tr><tr><td>@serialData</td><td>说明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td>@serialData description</td></tr><tr><td>@serialField</td><td>说明一个ObjectStreamField组件</td><td>@serialField name type description</td></tr><tr><td>@since</td><td>标记当引入一个特定的变化时</td><td>@since release</td></tr><tr><td>@throws</td><td>和 @exception标签一样.</td><td>The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td>{@value}</td><td>显示常量的值，该常量必须是static属性。</td><td>Displays the value of a constant, which must be a static field.</td></tr><tr><td>@version</td><td>指定类的版本</td><td>@version info</td></tr></tbody></table><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java环境变量配置</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="1-Java下载"><a href="#1-Java下载" class="headerlink" title="1 Java下载"></a>1 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Java下载</a></h2><h2 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2 环境变量配置"></a>2 环境变量配置</h2><ol><li><strong>JAVA_HOME</strong>:C:\Program Files\Java\jdk1.8.0_144（注：结尾不加分号）</li><li><strong>PATH</strong>:%JAVA_HOME%\bin;</li><li><strong>CLASS_PATH</strong>:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</li></ol><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h2><ul><li><strong>java-version</strong>:版本号</li><li><strong>java</strong>:Java环境</li><li><strong>javac</strong>:Java编译器</li></ul><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础知识01</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/</url>
      <content type="html"><![CDATA[<h2 id="1-Hello-World-示例"><a href="#1-Hello-World-示例" class="headerlink" title="1 Hello World 示例"></a>1 Hello World 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ps:</code></p><ul><li>Java 中类名（CamelCase 风格）要与文件名保持一致；</li><li>Java 中方法名 camelCase 风格；</li><li>main 主函数参数默认为 String []；</li></ul><a id="more"></a><h2 id="2-Java-标识符"><a href="#2-Java-标识符" class="headerlink" title="2 Java 标识符"></a>2 Java 标识符</h2><ul><li>所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始</li></ul><h2 id="3-Java-变量"><a href="#3-Java-变量" class="headerlink" title="3 Java 变量"></a>3 Java 变量</h2><ul><li>局部变量</li><li>类变量（静态变量）</li><li>成员变量（非静态变量）</li></ul><h2 id="4-Java-关键字"><a href="#4-Java-关键字" class="headerlink" title="4 Java 关键字"></a>4 Java 关键字</h2><table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>abstract</td><td>抽象方法，抽象类的修饰符</td></tr><tr><td>assert</td><td>断言条件是否满足</td></tr><tr><td>boolean</td><td>布尔数据类型</td></tr><tr><td>break</td><td>跳出循环或者label代码段</td></tr><tr><td>byte</td><td>8-bit 有符号数据类型</td></tr><tr><td>case</td><td>switch语句的一个条件</td></tr><tr><td>catch</td><td>try搭配捕捉异常信息</td></tr><tr><td>char</td><td>16-bit Unicode字符数据类型</td></tr><tr><td>class</td><td>定义类</td></tr><tr><td>const</td><td>未使用</td></tr><tr><td>continue</td><td>不执行循环体剩余部分</td></tr><tr><td>default</td><td>switch语句中的默认分支</td></tr><tr><td>do</td><td>循环语句，循环体至少会执行一次</td></tr><tr><td>double</td><td>64-bit双精度浮点数</td></tr><tr><td>else</td><td>if条件不成立时执行的分支</td></tr><tr><td>enum</td><td>枚举类型</td></tr><tr><td>extends</td><td>表示一个类是另一个类的子类</td></tr><tr><td>final</td><td>表示一个值在初始化之后就不能再改变了或表示方法不能被重写，或者一个类不能有子类</td></tr><tr><td>finally</td><td>为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。</td></tr><tr><td>float</td><td>32-bit单精度浮点数</td></tr><tr><td>for</td><td>for循环语句</td></tr><tr><td>goto</td><td>未使用</td></tr><tr><td>if</td><td>条件语句</td></tr><tr><td>implements</td><td>表示一个类实现了接口</td></tr><tr><td>import</td><td>导入类</td></tr><tr><td><strong>instanceof</strong></td><td>测试一个对象是否是某个类的实例</td></tr><tr><td>int</td><td>32位整型数</td></tr><tr><td>interface</td><td>接口，一种抽象的类型，仅有方法和常量的定义</td></tr><tr><td>long</td><td>64位整型数</td></tr><tr><td><strong>native</strong></td><td>表示方法用非java代码实现</td></tr><tr><td>new</td><td>分配新的类实例</td></tr><tr><td>package</td><td>一系列相关类组成一个包</td></tr><tr><td>private</td><td>表示私有字段，或者方法等，只能从类内部访问</td></tr><tr><td>protected</td><td>表示字段只能通过类或者其子类访问子类或者在同一个包内的其他类</td></tr><tr><td>public</td><td>表示共有属性或者方法</td></tr><tr><td>return</td><td>方法返回值</td></tr><tr><td>short</td><td>16位数字</td></tr><tr><td>static</td><td>表示在类级别定义，所有实例共享的</td></tr><tr><td><strong>strictfp</strong></td><td>浮点数比较使用严格的规则</td></tr><tr><td>super</td><td>表示基类</td></tr><tr><td>switch</td><td>选择语句</td></tr><tr><td><strong>synchronized</strong></td><td>表示同一时间只能由一个线程访问的代码块</td></tr><tr><td>this</td><td>表示调用当前实例或者调用另一个构造函数</td></tr><tr><td>throw</td><td>抛出异常</td></tr><tr><td><strong>throws</strong></td><td>定义方法可能抛出的异常</td></tr><tr><td><strong>transient</strong></td><td>修饰不要序列化的字段</td></tr><tr><td>try</td><td>表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码</td></tr><tr><td>void</td><td>标记方法不返回任何值</td></tr><tr><td><strong>volatile</strong></td><td>标记字段可能会被多个线程同时访问，而不做同步</td></tr><tr><td>while</td><td>while循环</td></tr></tbody></table><h2 id="5-类-amp-对象"><a href="#5-类-amp-对象" class="headerlink" title="5 类&amp;对象"></a>5 类&amp;对象</h2><ul><li>对象：对象是类的一个实例，有状态和行为。</li><li>类：类是一个模板，它描述一类对象的行为和状态。</li><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li></ul><h2 id="6-源文件"><a href="#6-源文件" class="headerlink" title="6 源文件"></a>6 源文件</h2><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非 public 类</li><li>源文件的名称应该和 public 类的类名保持一致</li><li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li><li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li><li>import 语句和 package 语句对源文件中定义的所有类都有效。</li></ul><h2 id="7-基本数据类型"><a href="#7-基本数据类型" class="headerlink" title="7 基本数据类型"></a>7 基本数据类型</h2><p>八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br><em>PS:</em>字符串不属于基本类型。</p><h3 id="7-1-byte（java-lang-Byte）"><a href="#7-1-byte（java-lang-Byte）" class="headerlink" title="7.1 byte（java.lang.Byte）"></a>7.1 byte（java.lang.Byte）</h3><ul><li>byte数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是-128（-2^7）；</li><li>最大值是127（2^7-1）；</li><li>默认值是0；</li><li>byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；</li></ul><h3 id="7-2-short（java-lang-Short）"><a href="#7-2-short（java-lang-Short）" class="headerlink" title="7.2 short（java.lang.Short）"></a>7.2 short（java.lang.Short）</h3><ul><li>short数据类型是16位、有符号的以二进制补码表示的整数</li><li>最小值是-32768（-2^15）；</li><li>最大值是32767（2^15 - 1）；</li><li>Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是0；</li></ul><h3 id="7-3-int（java-lang-Integer）"><a href="#7-3-int（java-lang-Integer）" class="headerlink" title="7.3 int（java.lang.Integer）"></a>7.3 int（java.lang.Integer）</h3><ul><li>int数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是-2,147,483,648（-2^31）；</li><li>最大值是2,147,483,647（2^31 - 1）；</li><li>一般地整型变量默认为int类型；</li><li>默认值是0；</li></ul><h3 id="7-4-long（java-lang-Long）"><a href="#7-4-long（java-lang-Long）" class="headerlink" title="7.4 long（java.lang.Long）"></a>7.4 long（java.lang.Long）</h3><ul><li>long数据类型是64位、有符号的以二进制补码表示的整数；</li><li>最小值是-9,223,372,036,854,775,808（-2^63）；</li><li>最大值是9,223,372,036,854,775,807（2^63 -1）；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是0L；</li></ul><h3 id="7-5-float（java-lang-Float）"><a href="#7-5-float（java-lang-Float）" class="headerlink" title="7.5 float（java.lang.Float）"></a>7.5 float（java.lang.Float）</h3><ul><li>float数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li>float在储存大型浮点数组的时候可节省内存空间；</li><li>默认值是0.0f；</li><li><strong>浮点数不能用来表示精确的值</strong>，如货币；</li></ul><h3 id="7-6-double（java-lang-Double）"><a href="#7-6-double（java-lang-Double）" class="headerlink" title="7.6 double（java.lang.Double）"></a>7.6 double（java.lang.Double）</h3><ul><li>double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</li><li>浮点数的默认类型为double类型；</li><li><strong>double类型同样不能表示精确的值</strong>，如货币；</li></ul><h3 id="7-7-boolean"><a href="#7-7-boolean" class="headerlink" title="7.7 boolean"></a>7.7 boolean</h3><ul><li>boolean数据类型表示一位的信息；</li><li>只有两个取值：true和false；</li><li>这种类型只作为一种标志来记录true/false情况；</li><li>默认值是false；</li></ul><h3 id="7-8-char（java-lang-Character）"><a href="#7-8-char（java-lang-Character）" class="headerlink" title="7.8 char（java.lang.Character）"></a>7.8 char（java.lang.Character）</h3><ul><li>char类型是一个单一的16位Unicode字符；</li><li>最小值是’\u0000’（即为0）；</li><li>最大值是’\uffff’（即为65,535）；</li><li>char数据类型可以储存任何字符；</li></ul><h3 id="7-9-void（java-lang-Void）"><a href="#7-9-void（java-lang-Void）" class="headerlink" title="7.9 void（java.lang.Void）"></a>7.9 void（java.lang.Void）</h3><p>实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p><h2 id="8-引用类型"><a href="#8-引用类型" class="headerlink" title="8 引用类型"></a>8 引用类型</h2><ul><li>引用类型变量由类的构造函数创建，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。</li><li>对象、<strong>数组</strong>、<strong>字符串</strong>都是引用数据类型。</li><li>所有引用类型的默认值都是null。</li><li>一个引用变量可以用来引用与任何与之兼容的类型。</li></ul><h2 id="9-常量（final）"><a href="#9-常量（final）" class="headerlink" title="9 常量（final）"></a>9 常量（final）</h2><ul><li>常量就是一个固定值。</li><li>通常使用大写字母表示常量。</li><li><strong>字符串</strong>是常量。</li></ul><h2 id="10-局部变量"><a href="#10-局部变量" class="headerlink" title="10 局部变量"></a>10 局部变量</h2><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以<strong>局部变量被声明后，必须经过初始化，才可以使用</strong>。</li></ul><h2 id="11-实例变量"><a href="#11-实例变量" class="headerlink" title="11 实例变量"></a>11 实例变量</h2><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li></ul><h2 id="12-类变量（静态变量）"><a href="#12-类变量（静态变量）" class="headerlink" title="12 类变量（静态变量）"></a>12 类变量（静态变量）</h2><ul><li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法、构造方法和语句块之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用。<strong>常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</strong></li><li><strong>静态变量储存在静态存储区</strong>。经常被声明为常量，很少单独使用static声明变量。</li><li><strong>静态变量在程序开始时创建，在程序结束时销毁</strong>。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以- 在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：ClassName.VariableName的方式访问。</li><li><strong>类变量被声明为public static final类型时，类变量名称必须使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</strong></li></ul><h2 id="13-访问控制修饰符"><a href="#13-访问控制修饰符" class="headerlink" title="13 访问控制修饰符"></a>13 访问控制修饰符</h2><ul><li>default：默认的，在同一包内可见，不使用任何修饰符。<ul><li>接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为public。</li></ul></li><li>private：私有的，在同一类内可见。</li><li>public：共有的，对所有类可见。</li><li>protected 受保护的，对<strong>同一包内的类和所有子类</strong>可见（<strong>注意</strong>：此处对应C#的protected internal，而C#中protected仅仅对所有程序集的子类可见，而对包内的类不可见）。<ul><li>Protected访问修饰符不能修饰类和接口，方法和成员变量能够声明为protected，但是接口的成员变量和成员方法不能声明为protected。</li></ul></li></ul><h2 id="14-访问控制和继承"><a href="#14-访问控制和继承" class="headerlink" title="14 访问控制和继承"></a>14 访问控制和继承</h2><ul><li>父类中声明为public的方法在子类中也必须为public。</li><li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。</li><li>父类中声明为private的方法，不能够被继承。</li></ul><h2 id="15-非访问修饰符"><a href="#15-非访问修饰符" class="headerlink" title="15 非访问修饰符"></a>15 非访问修饰符</h2><ul><li>static<ul><li>用来创建类方法和类变量。</li></ul></li><li>final<ul><li>用来修饰类、方法和变量，<strong>final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的</strong>。</li><li>final变量能被显式地初始化并且只能初始化一次。<strong>被声明为final的对象的引用不能指向不同的对象。但是final对象里的数据可以被改变。</strong>也就是说final对象的引用不能改变，但是里面的值可以改变。</li><li>final修饰符通常和static修饰符一起使用来创建类常量。</li><li>类中的Final方法可以被子类继承，但是不能被子类修改。声明final方法的主要目的是防止该方法的内容被修改。</li><li>final类不能被继承，没有类能够继承final类的任何特性。（即C#的sealed）</li></ul></li><li>abstract<ul><li>用来创建抽象类和抽象方法。</li><li>一个类不能同时被abstract和final修饰。</li><li>抽象类可以包含抽象方法和非抽象方法。</li><li>抽象方法不能被声明成final和static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li></ul></li><li>synchronized<ul><li>synchronized关键字声明的方法同一时间只能被一个线程访问。synchronized修饰符可以应用于四个访问修饰符。</li></ul></li><li>Transient<ul><li>序列化的对象包含被transient修饰的实例变量时，java虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</li></ul></li><li>volatile<ul><li>volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。</li></ul></li></ul><h2 id="16-位运算符"><a href="#16-位运算符" class="headerlink" title="16 位运算符"></a>16 位运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><strong>&amp;</strong></td><td>按位与操作符，当且仅当两个操作数的某一位都非0时候结果的该位才为1。</td></tr><tr><td><strong>&#124;</strong></td><td>按位或操作符，只要两个操作数的某一位有一个非0时候结果的该位就为1。</td></tr><tr><td><strong>^</strong></td><td>按位异或操作符，两个操作数的某一位不相同时候结果的该位就为1。    </td></tr><tr><td><strong>〜</strong></td><td>按位补运算符翻转操作数的每一位。    </td></tr><tr><td><strong>&lt;&lt;</strong></td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td></tr><tr><td><strong>&gt;&gt;</strong></td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td></tr><tr><td><strong>&gt;&gt;&gt;</strong></td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td></tr></tbody></table><h2 id="17-instanceOf"><a href="#17-instanceOf" class="headerlink" title="17 instanceOf"></a>17 instanceOf</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">'James'</span>;</span><br><span class="line"><span class="keyword">boolean</span> result = name instanceOf String; <span class="comment">// 由于name是Strine类型，所以返回true</span></span><br></pre></td></tr></table></figure></p><h2 id="18-for增强（即C-的foreach）"><a href="#18-for增强（即C-的foreach）" class="headerlink" title="18 for增强（即C#的foreach）"></a>18 for增强（即C#的foreach）</h2><p><code>·</code>要用于数组(Java5，之后不清楚是否有扩展，待确认)`</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : numbers )&#123;</span><br><span class="line">  System.out.print( x );</span><br><span class="line">  System.out.print(<span class="string">","</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-switch"><a href="#19-switch" class="headerlink" title="19 switch"></a>19 switch</h2><ul><li>switch语句中的变量类型只能为byte、short、int或者char。<code>(不清楚后续版本是否有扩展，待确认)</code></li><li>case语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li><li>switch语句可以包含一个default分支，<strong>该分支必须是switch语句的最后一个分支</strong>（C#中不一定是最后一个）。</li></ul><h2 id="20-Number类（java-lang）"><a href="#20-Number类（java-lang）" class="headerlink" title="20 Number类（java.lang）"></a>20 Number类（java.lang）</h2><p><img src="/images/posts/Java_Number.jpg" alt="图一"></p><h2 id="21-String类"><a href="#21-String类" class="headerlink" title="21 String类"></a>21 String类</h2><ul><li><strong>字符串属于对象</strong></li><li><strong>和C#不同的是，Java中只有String，而没有string！！！</strong></li><li><strong>String类是不可改变的，所以你一旦创建了String对象，那它的值就无法改变了。</strong></li><li><strong>字符串长度使用length(),即方法而不是C#的属性length。</strong></li></ul><h2 id="22-StringBuffer和StringBuilder"><a href="#22-StringBuffer和StringBuilder" class="headerlink" title="22 StringBuffer和StringBuilder"></a>22 StringBuffer和StringBuilder</h2><ul><li>StringBuilder的方法不是线程安全的（不能同步访问）,而StringBuffer是。</li><li>StringBuilder相较于StringBuffer有速度优势，多数情况下建议使用StringBuilder类。</li><li>在应用程序要求线程安全的情况下，则必须使用StringBuffer类。</li></ul><h2 id="23-数组"><a href="#23-数组" class="headerlink" title="23 数组"></a>23 数组</h2><h3 id="23-1-数组"><a href="#23-1-数组" class="headerlink" title="23.1 数组"></a>23.1 数组</h3><p><img src="/images/posts/Java_Array.jpg" alt="图一"></p><h3 id="23-2-Arrays-类-java-util-Arrays"><a href="#23-2-Arrays-类-java-util-Arrays" class="headerlink" title="23.2 Arrays 类(java.util.Arrays)"></a>23.2 Arrays 类(java.util.Arrays)</h3><ul><li>所有方法都是静态的</li><li>给数组赋值：通过fill方法。</li><li>对数组排序：通过sort方法,按升序。</li><li>比较数组：通过equals方法比较数组中<strong>元素值</strong>是否相等。</li><li>查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找法操作</li></ul><h2 id="24-时间"><a href="#24-时间" class="headerlink" title="24 时间"></a>24 时间</h2><h3 id="24-1-Date-类-java-util-Date"><a href="#24-1-Date-类-java-util-Date" class="headerlink" title="24.1 Date 类(java.util.Date)"></a>24.1 Date 类(java.util.Date)</h3><p>System.currentTimeMillis()计算时间</p><h3 id="24-2-SimpleDateFormat：格式化日期"><a href="#24-2-SimpleDateFormat：格式化日期" class="headerlink" title="24.2 SimpleDateFormat：格式化日期"></a>24.2 SimpleDateFormat：格式化日期</h3><table><thead><tr><th>字母</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>G</td><td>纪元标记</td><td>AD</td></tr><tr><td>y</td><td>四位年份</td><td>2001</td></tr><tr><td>M</td><td>月份</td><td>July or 07</td></tr><tr><td>d</td><td>一个月的日期</td><td>10</td></tr><tr><td>h</td><td>A.M./P.M.(1~12)格式小时</td><td>12</td></tr><tr><td>H</td><td>一天中的小时(0~23)</td><td>22</td></tr><tr><td>m</td><td>分钟数</td><td>30</td></tr><tr><td>s</td><td>秒数</td><td>55</td></tr><tr><td>S</td><td>微妙数</td><td>234</td></tr><tr><td>E</td><td>星期几</td><td>Tuesday</td></tr><tr><td>D</td><td>一年中的日子</td><td>360</td></tr><tr><td>F</td><td>一个月中第几周的周几</td><td>2 (second Wed. in July)</td></tr><tr><td>w</td><td>一年中第几周</td><td>40</td></tr><tr><td>W</td><td>一个月中第几周</td><td>1</td></tr><tr><td>a</td><td>A.M./P.M. 标记</td><td>PM</td></tr><tr><td>k</td><td>一天中的小时(1~24)</td><td>24</td></tr><tr><td>K</td><td>A.M./P.M. (0~11)格式小时</td><td>10</td></tr><tr><td>z</td><td>时区</td><td>Eastern Standard Time</td></tr><tr><td>‘</td><td>文字定界符</td><td>Delimiter</td></tr><tr><td>“</td><td>单引号</td><td>`</td></tr></tbody></table><h3 id="24-3-Calendar"><a href="#24-3-Calendar" class="headerlink" title="24.3 Calendar"></a>24.3 Calendar</h3><ul><li>抽象类</li><li>getInstance()获取实例</li></ul><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>Calendar.YEAR</td><td>年份</td></tr><tr><td>Calendar.MONTH</td><td>月份</td></tr><tr><td>Calendar.DATE</td><td>日期</td></tr><tr><td>Calendar.DAY_OF_MONTH</td><td>日期，和上面的字段意义完全相同</td></tr><tr><td>Calendar.HOUR</td><td>12小时制的小时</td></tr><tr><td>Calendar.HOUR_OF_DAY</td><td>24小时制的小时</td></tr><tr><td>Calendar.MINUTE</td><td>分钟</td></tr><tr><td>Calendar.SECOND</td><td>秒</td></tr><tr><td>Calendar.DAY_OF_WEEK</td><td>星期几</td></tr></tbody></table><h3 id="24-4-GregorianCalendar"><a href="#24-4-GregorianCalendar" class="headerlink" title="24.4 GregorianCalendar"></a>24.4 GregorianCalendar</h3><h2 id="25-正则（java-util-regex包）"><a href="#25-正则（java-util-regex包）" class="headerlink" title="25 正则（java.util.regex包）"></a>25 正则（java.util.regex包）</h2><ul><li>Pattern类：pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。</li><li>Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。</li><li>PatternSyntaxException：PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</li></ul><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td><code>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，&quot;n&quot;匹配字符&quot;n&quot;。&quot;\n&quot;匹配换行符。序列&quot;\\&quot;匹配&quot;\&quot;，&quot;\(&quot;匹配&quot;(&quot;。</code></td></tr><tr><td>^</td><td><code>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与&quot;\n&quot;或&quot;\r&quot;之后的位置匹配。</code></td></tr><tr><td>$</td><td><code>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与&quot;\n&quot;或&quot;\r&quot;之前的位置匹配。</code></td></tr><tr><td>*</td><td><code>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配&quot;z&quot;和&quot;zoo&quot;。* 等效于 {0,}。</code></td></tr><tr><td>+</td><td><code>一次或多次匹配前面的字符或子表达式。例如，&quot;zo+&quot;与&quot;zo&quot;和&quot;zoo&quot;匹配，但与&quot;z&quot;不匹配。+ 等效于 {1,}。</code></td></tr><tr><td>?</td><td><code>零次或一次匹配前面的字符或子表达式。例如，&quot;do(es)?&quot;匹配&quot;do&quot;或&quot;does&quot;中的&quot;do&quot;。? 等效于 {0,1}。</code></td></tr><tr><td>{n}</td><td><code>n 是非负整数。正好匹配 n 次。例如，&quot;o{2}&quot;与&quot;Bob&quot;中的&quot;o&quot;不匹配，但与&quot;food&quot;中的两个&quot;o&quot;匹配。</code></td></tr><tr><td>{n,}</td><td><code>n 是非负整数。至少匹配 n 次。例如，&quot;o{2,}&quot;不匹配&quot;Bob&quot;中的&quot;o&quot;，而匹配&quot;foooood&quot;中的所有 o。&quot;o{1,}&quot;等效于&quot;o+&quot;。&quot;o{0,}&quot;等效于&quot;o*&quot;。</code></td></tr><tr><td>{n,m}</td><td><code>M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，&quot;o{1,3}&quot;匹配&quot;fooooood&quot;中的头三个 o。&#39;o{0,1}&#39; 等效于 &#39;o?&#39;。注意：您不能将空格插入逗号和数字之间。</code></td></tr><tr><td>?</td><td><code>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是&quot;非贪心的&quot;。&quot;非贪心的&quot;模式匹配搜索到的、尽可能短的字符串，而默认的&quot;贪心的&quot;模式匹配搜索到的、尽可能长的字符串。例如，在字符串&quot;oooo&quot;中，&quot;o+?&quot;只匹配单个&quot;o&quot;，而&quot;o+&quot;匹配所有&quot;o&quot;。</code></td></tr><tr><td>.</td><td><code>匹配除&quot;\r\n&quot;之外的任何单个字符。若要匹配包括&quot;\r\n&quot;在内的任意字符，请使用诸如&quot;[\s\S]&quot;之类的模式。</code></td></tr><tr><td>(pattern)</td><td><code>匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果&quot;匹配&quot;集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用&quot;\(&quot;或者&quot;\)&quot;。</code></td></tr><tr><td>(?:pattern)</td><td><code>匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用&quot;or&quot;字符 (&amp;#124;) 组合模式部件的情况很有用。例如，&#39;industr(?:y&amp;#124;ies) 是比 &#39;industry&amp;#124;industries&#39; 更经济的表达式。</code></td></tr><tr><td>(?=pattern)</td><td><code>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#39;Windows (?=95&amp;#124;98&amp;#124;NT&amp;#124;2000)&#39; 匹配&quot;Windows 2000&quot;中的&quot;Windows&quot;，但不匹配&quot;Windows 3.1&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</code></td></tr><tr><td>(?!pattern)</td><td><code>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#39;Windows (?!95&amp;#124;98&amp;#124;NT&amp;#124;2000)&#39; 匹配&quot;Windows 3.1&quot;中的 &quot;Windows&quot;，但不匹配&quot;Windows 2000&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</code></td></tr><tr><td>x&#124;y</td><td><code>匹配 x 或 y。例如，&#39;z&amp;#124;food&#39; 匹配&quot;z&quot;或&quot;food&quot;。&#39;(z&amp;#124;f)ood&#39; 匹配&quot;zood&quot;或&quot;food&quot;。</code></td></tr><tr><td>[xyz]</td><td><code>字符集。匹配包含的任一字符。例如，&quot;[abc]&quot;匹配&quot;plain&quot;中的&quot;a&quot;。</code></td></tr><tr><td>[^xyz]</td><td><code>反向字符集。匹配未包含的任何字符。例如，&quot;[^abc]&quot;匹配&quot;plain&quot;中&quot;p&quot;，&quot;l&quot;，&quot;i&quot;，&quot;n&quot;。</code></td></tr><tr><td>[a-z]</td><td><code>字符范围。匹配指定范围内的任何字符。例如，&quot;[a-z]&quot;匹配&quot;a&quot;到&quot;z&quot;范围内的任何小写字母。</code></td></tr><tr><td>[^a-z]</td><td><code>反向范围字符。匹配不在指定的范围内的任何字符。例如，&quot;[^a-z]&quot;匹配任何不在&quot;a&quot;到&quot;z&quot;范围内的任何字符。</code></td></tr><tr><td>\b</td><td><code>匹配一个字边界，即字与空格间的位置。例如，&quot;er\b&quot;匹配&quot;never&quot;中的&quot;er&quot;，但不匹配&quot;verb&quot;中的&quot;er&quot;。</code></td></tr><tr><td>\B</td><td><code>非字边界匹配。&quot;er\B&quot;匹配&quot;verb&quot;中的&quot;er&quot;，但不匹配&quot;never&quot;中的&quot;er&quot;。</code></td></tr><tr><td>\cx</td><td><code>匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是&quot;c&quot;字符本身。</code></td></tr><tr><td>\d</td><td><code>数字字符匹配。等效于 [0-9]。</code></td></tr><tr><td>\D</td><td><code>非数字字符匹配。等效于 [^0-9]。</code></td></tr><tr><td>\f</td><td><code>换页符匹配。等效于 \x0c 和 \cL。</code></td></tr><tr><td>\n</td><td><code>换行符匹配。等效于 \x0a 和 \cJ。</code></td></tr><tr><td>\r</td><td><code>匹配一个回车符。等效于 \x0d 和 \cM。</code></td></tr><tr><td>\s</td><td><code>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</code></td></tr><tr><td>\S</td><td><code>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</code></td></tr><tr><td>\t</td><td><code>制表符匹配。与 \x09 和 \cI 等效。</code></td></tr><tr><td>\v</td><td><code>垂直制表符匹配。与 \x0b 和 \cK 等效。</code></td></tr><tr><td>\w</td><td><code>匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效。</code></td></tr><tr><td>\W</td><td><code>与任何非单词字符匹配。与&quot;[^A-Za-z0-9_]&quot;等效。</code></td></tr><tr><td>\xn</td><td><code>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，&quot;\x41&quot;匹配&quot;A&quot;。&quot;\x041&quot;与&quot;\x04&quot;&amp;&quot;1&quot;等效。允许在正则表达式中使用 ASCII 代码。</code></td></tr><tr><td>\num</td><td><code>匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，&quot;(.)\1&quot;匹配两个连续的相同字符。</code></td></tr><tr><td>\n</td><td><code>标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</code></td></tr><tr><td>\nm</td><td><code>标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</code></td></tr><tr><td>\nml</td><td><code>当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</code></td></tr><tr><td>\un</td><td><code>匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</code></td></tr></tbody></table><h2 id="26-方法"><a href="#26-方法" class="headerlink" title="26 方法"></a>26 方法</h2><ul><li><strong>方法是通过值传递参数</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPassByValue</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Before swap method, num1 is "</span> + num1 + <span class="string">" and num2 is "</span> + num2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用swap方法</span></span><br><span class="line">      swap(num1, num2);</span><br><span class="line">      System.out.println(<span class="string">"After swap method, num1 is "</span> + num1 + <span class="string">" and num2 is "</span> + num2);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/** 交换两个变量的方法 */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"\tInside the swap method"</span>);</span><br><span class="line">      System.out.println(<span class="string">"\t\tBefore swapping n1 is "</span> + n1 + <span class="string">" n2 is "</span> + n2);</span><br><span class="line">      <span class="comment">// 交换 n1 与 n2的值</span></span><br><span class="line">      <span class="keyword">int</span> temp = n1;</span><br><span class="line">      n1 = n2;</span><br><span class="line">      n2 = temp;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"\t\tAfter swapping n1 is "</span> + n1 + <span class="string">" n2 is "</span> + n2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>结果如下：</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Before swap method, num1 is 1 and num2 is 2</span><br><span class="line">Inside the swap method</span><br><span class="line">Before swapping n1 is 1 n2 is 2</span><br><span class="line">After swapping n1 is 2 n2 is 1</span><br><span class="line">After swap method, num1 is 1 and num2 is 2</span><br></pre></td></tr></table></figure></p><h2 id="27-可变参数"><a href="#27-可变参数" class="headerlink" title="27 可变参数"></a>27 可变参数</h2><p>typeName… parameterName，必须放置在最后一个（即C#的param int arr）</p><h2 id="28-finalize方法（即C-的析构函数）"><a href="#28-finalize方法（即C-的析构函数）" class="headerlink" title="28 finalize方法（即C#的析构函数）"></a>28 finalize方法（即C#的析构函数）</h2><ul><li>在对象被垃圾收集器析构(回收)之前调用，它用来清除回收对象。</li><li>System.gc(); //调用Java垃圾收集器</li></ul><h2 id="29-流（java-io包）"><a href="#29-流（java-io包）" class="headerlink" title="29 流（java.io包）"></a>29 流（java.io包）</h2><p><img src="/images/posts/Java_Stream.jpg" alt="Stream"></p><h3 id="29-1-读取控制台输入"><a href="#29-1-读取控制台输入" class="headerlink" title="29.1 读取控制台输入"></a>29.1 读取控制台输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br></pre></td></tr></table></figure><h3 id="29-2-获取或设置JVM当前工作目录"><a href="#29-2-获取或设置JVM当前工作目录" class="headerlink" title="29.2 获取或设置JVM当前工作目录"></a>29.2 获取或设置JVM当前工作目录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line">System.setProperty(<span class="string">"user.dir"</span>, <span class="string">"C:\\myDir"</span>);</span><br></pre></td></tr></table></figure><h3 id="29-3-文件分隔符"><a href="#29-3-文件分隔符" class="headerlink" title="29.3 文件分隔符"></a>29.3 文件分隔符</h3><p>常量<strong>File.separator</strong>，用于解决Windows在路径名中使用反斜杠（\）作为名称分隔符，而UNIX使用正斜杠（/）的问题。</p><h2 id="30-Scan-java-util-SCanner"><a href="#30-Scan-java-util-SCanner" class="headerlink" title="30 Scan(java.util.SCanner)"></a>30 Scan(java.util.SCanner)</h2><p>主要用于获取用户的输入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure></p><h2 id="31-异常"><a href="#31-异常" class="headerlink" title="31 异常"></a>31 异常</h2><h3 id="31-1-异常类型"><a href="#31-1-异常类型" class="headerlink" title="31.1 异常类型"></a>31.1 异常类型</h3><ul><li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li>错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><h3 id="31-2-异常层次"><a href="#31-2-异常层次" class="headerlink" title="31.2 异常层次"></a>31.2 异常层次</h3><ul><li>所有的异常类是从java.lang.Exception类继承的子类。</li><li>Exception类是Throwable类的子类。除了Exception类外，Throwable还有一个子类Error 。</li></ul><p><img src="/images/posts/Java_Exception.jpg" alt="Exception"></p><h3 id="31-3-非检查性异常"><a href="#31-3-非检查性异常" class="headerlink" title="31.3 非检查性异常"></a>31.3 非检查性异常</h3><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td></tr><tr><td>ArrayStoreException</td><td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td>ClassCastException</td><td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td></tr><tr><td>IllegalArgumentException</td><td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td>IllegalMonitorStateException</td><td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td>IllegalStateException</td><td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td>IllegalThreadStateException</td><td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td>IndexOutOfBoundsException</td><td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td></tr><tr><td>NegativeArraySizeException</td><td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td></tr><tr><td>NullPointerException</td><td>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</td></tr><tr><td>NumberFormatException</td><td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td></tr><tr><td>SecurityException</td><td>由安全管理器抛出的异常，指示存在安全侵犯。</td></tr><tr><td>StringIndexOutOfBoundsException</td><td>此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</td></tr><tr><td>UnsupportedOperationException</td><td>当不支持请求的操作时，抛出该异常。</td></tr></tbody></table><h3 id="31-4-检查性异常类"><a href="#31-4-检查性异常类" class="headerlink" title="31.4 检查性异常类"></a>31.4 检查性异常类</h3><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>应用程序试图加载类时，找不到相应的类，抛出该异常。</td></tr><tr><td>CloneNotSupportedException</td><td>当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</td></tr><tr><td>IllegalAccessException</td><td>拒绝访问一个类的时候，抛出该异常。</td></tr><tr><td>InstantiationException</td><td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td></tr><tr><td>InterruptedException</td><td>一个线程被另一个线程中断，抛出该异常。</td></tr><tr><td>NoSuchFieldException</td><td>请求的变量不存在</td></tr><tr><td>NoSuchMethodException</td><td>请求的方法不存在</td></tr></tbody></table><h3 id="31-5-throws-throw关键字"><a href="#31-5-throws-throw关键字" class="headerlink" title="31.5 throws/throw关键字"></a>31.5 throws/throw关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">// Method implementation</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31-6-自定义异常"><a href="#31-6-自定义异常" class="headerlink" title="31.6 自定义异常"></a>31.6 自定义异常</h3><ul><li>所有异常都必须是Throwable的子类。</li><li>检查性异常：继承Exception类。</li><li>运行时异常：继承RuntimeException 类。</li></ul><h3 id="31-7-异常和错误"><a href="#31-7-异常和错误" class="headerlink" title="31.7 异常和错误"></a>31.7 异常和错误</h3><ul><li>JVM(Java虚拟机)异常：由JVM抛出的异常或错误。例如：NullPointerException类，ArrayIndexOutOfBoundsException类，ClassCastException类。</li><li>程序级异常：由程序或者API程序抛出的异常。例如IllegalArgumentException类，IllegalStateException类。</li></ul><h2 id="38-继承-is-a"><a href="#38-继承-is-a" class="headerlink" title="38 继承(is-a)"></a>38 继承(is-a)</h2><p>可用<code>a instanceof b</code>校验。 </p><ul><li>extends：继承类</li><li>implements：继承接口</li></ul><h2 id="39-重写（override）-amp-重载（overload）"><a href="#39-重写（override）-amp-重载（overload）" class="headerlink" title="39 重写（override）&amp;重载（overload）"></a>39 重写（override）&amp;重载（overload）</h2><table><thead><tr><th>区别点</th><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可以修改</td><td>一定不能修改</td></tr><tr><td>异常</td><td>可以修改</td><td>可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td>访问</td><td>可以修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><h2 id="40-多态（is-a）"><a href="#40-多态（is-a）" class="headerlink" title="40 多态（is-a）"></a>40 多态（is-a）</h2><ul><li>同一个行为具有多个不同表现形式或形态的能力。</li><li>多态性是对象多种表现形式的体现。</li></ul><h2 id="41-接口（interface）"><a href="#41-接口（interface）" class="headerlink" title="41 接口（interface）"></a>41 接口（interface）</h2><ul><li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li><li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。</li><li>接口中的方法都是公有的。</li><li>标识接口：没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</li></ul><h2 id="42-包"><a href="#42-包" class="headerlink" title="42 包"></a>42 包</h2><h3 id="42-1-package"><a href="#42-1-package" class="headerlink" title="42.1 package"></a>42.1 package</h3><ul><li>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。</li><li>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</li></ul><h3 id="42-2-import"><a href="#42-2-import" class="headerlink" title="42.2 import"></a>42.2 import</h3><ul><li>文件中可以包含任意数量的import声明。import声明必须在包声明之后，类声明之前。</li><li>静态导入<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br></pre></td></tr></table></figure></li></ul><h3 id="42-3-CLASSPATH"><a href="#42-3-CLASSPATH" class="headerlink" title="42.3 CLASSPATH"></a>42.3 CLASSPATH</h3><p>类目录的绝对路径叫做class path。设置在系统变量CLASSPATH中。编译器和java虚拟机通过将package名字加到class path后来构造.class文件的路径。<path- two="">\classes是class path，package名字是com.apple.computers,而编译器和JVM会在 <path-two>\classes\com\apple\compters中找.class文件。<br>一个class path可能会包含好几个路径。多路径应该用分隔符分开。默认情况下，编译器和JVM查找当前目录。JAR文件按包含Java平台相关的类，所以他们的目录默认放在了class path中。</path-two></path-></p><h2 id="43-Object"><a href="#43-Object" class="headerlink" title="43 Object"></a>43 Object</h2><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>public String toString()</td><td>它是实现在Object类中，我们可以自定义它。它返回对象的字符串表示形式。通常，它用于调试目的。</td></tr><tr><td>public boolean equals(Object obj)</td><td>它在Object类中实现，我们可以自定义它。它用于比较两个对象的相等性。</td></tr><tr><td>public int hashCode()</td><td>它在Object类中实现，我们可以自定义它。它返回对象的哈希码（整数）值。</td></tr><tr><td>protected Object clone() throws CloneNotSupportedException</td><td>它不在Object类中实现，我们可以通过覆盖克隆方法来自定义它。它用于创建对象的副本。</td></tr><tr><td>protected void finalize() throws Throwable</td><td>它不是在Object类中实现，我们可以自定义它。它在对象被销毁之前被垃圾收集器调用。</td></tr><tr><td>public final Class getClass()</td><td>它在Object类中实现，我们不能自定义它。它返回对对象的Class对象的引用。</td></tr><tr><td>public final void notify()</td><td>它是在Object类中实现的，我们不能自定义它。此方法通知对象的等待队列中的一个线程。</td></tr><tr><td>public final void notifyAll()</td><td>它是在Object类中实现的，我们不能自定义它。此方法通知对象的等待队列中的所有线程。</td></tr><tr><td>public final void wait() throws InterruptedException<br>public final void wait(long timeout) throws InterruptedException<br>public final void wait (long timeout, int nanos) throws InterruptedException</td><td>它是在Object类中实现的，我们不能自定义它。使对象的等待队列中的线程等待，无论是否超时。</td></tr></tbody></table><h3 id="43-1-hashCode"><a href="#43-1-hashCode" class="headerlink" title="43.1 hashCode"></a>43.1 hashCode</h3><ul><li>如果两个对象使用equals()方法相等，则它们必须具有相同的哈希码。</li><li>如果x.hashCode()等于y.hashCode()，则x.equals(y)不必返回true。</li><li><strong>快速实现 hashCode方法</strong>：读取 equals() 使用的所有字段的 hash 码，然后对它们进行按位异或（^）操作。</li></ul><h3 id="43-2-equals"><a href="#43-2-equals" class="headerlink" title="43.2 equals"></a>43.2 equals</h3><p>这里是equals()方法的实现的规范。假设x，y和z是三个对象的非空引用。</p><ul><li>自反性。表达式x.equals(x)应该返回true。</li><li>对称性。如果x.equals(y)返回true，y.equals(x)必须返回true。</li><li>传递性。如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)必须返回true。</li><li>一致性。如果x.equals(y)返回true，它应该保持返回true，直到x或y的状态被修改。如果x.equals(y)返回false，它应该保持返回false，直到x或y的状态被修改。</li><li>与空引用的比较：任何类的对象不应等于空引用。表达式x.equals(null)应始终返回false。</li><li>与hashCode()方法的关系：如果x.equals(y)返回true，x.hashCode()必须返回与y.hashCode()相同的值。</li></ul><h3 id="43-3-toString"><a href="#43-3-toString" class="headerlink" title="43.3 toString"></a>43.3 toString</h3><p>当需要对象的字符串表示时，Java会自动调用toString()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"Hello"</span> + <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></p><p>等同于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"Hello"</span> + <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>).toString();</span><br></pre></td></tr></table></figure></p><h3 id="43-4-clone（浅拷贝）"><a href="#43-4-clone（浅拷贝）" class="headerlink" title="43.4 clone（浅拷贝）"></a>43.4 clone（浅拷贝）</h3><p>Java不提供克隆(复制)对象的自动机制。克隆对象意味着逐位复制对象的内容。要支持克隆操作，请在类中实现clone()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyClass copy = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    copy = (MyClass) <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="43-5-finalize"><a href="#43-5-finalize" class="headerlink" title="43.5 finalize"></a>43.5 finalize</h3><p>finalize()方法将在类的对象销毁之前由垃圾回收器调用。</p><h3 id="Immutables-不可变"><a href="#Immutables-不可变" class="headerlink" title="Immutables(不可变)"></a>Immutables(不可变)</h3><p>在创建状态后无法更改其状态的对象称为不可变对象。一个对象不可变的类称为不可变类。不变的对象可以由程序的不同区域共享而不用担心其状态改变。不可变对象本质上是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">IntWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntWrapper</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="43-7-Objects类-实用程序类"><a href="#43-7-Objects类-实用程序类" class="headerlink" title="43.7 Objects类(实用程序类)"></a>43.7 Objects类(实用程序类)</h3><p>主要用于处理对象。由静态方法组成。 Objects类中的大多数方法都会优雅地处理空值。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>int compare(T a, T b, Comparator c)</td><td>如果参数相同，则返回0，否则返回c.compare(a，b)。因此，如果两个参数都为null，则返回0。</td></tr><tr><td>boolean deepEquals(Object a, Object b)</td><td>检查两个对象是否相等。如果两个参数都相等，则返回true。否则，它返回false。如果两个参数都为null，则返回true。</td></tr><tr><td>boolean equals(Object a, Object b)</td><td>比较两个对象是否相等。如果两个参数相等，则返回true。否则，它返回false。如果两个参数都为null，则返回true。</td></tr><tr><td>int hash(Object… values)</td><td>为所有指定的对象生成哈希码。它可以用于计算对象的哈希码，该哈希码基于多个实例字段。</td></tr><tr><td>int hashCode(Object o)</td><td>返回指定对象的哈希码值。如果参数为null，则返回0。</td></tr><tr><td>boolean isNull(Object obj)</td><td>如果指定的对象为null，isNull()方法返回true。否则，它返回false。您还可以使用比较运算符==检查对象是否为null，例如，obj == null返回obj的true为null。</td></tr><tr><td>boolean nonNull(Object obj)</td><td>执行与isNull()方法相反的检查。</td></tr><tr><td>T requireNonNull(T obj)</td><td>检查参数是否为null。如果参数为null，它会抛出一个NullPointerException异常。此方法设计用于验证方法和构造函数的参数。</td></tr><tr><td>T requireNonNull(T obj, String message)</td><td>第二个版本可以指定当参数为null时抛出的NullPointerException的消息。</td></tr><tr><td>T requireNonNull(T obj, Supplier messageSupplier)</td><td>第三个版本的方法将一个Supplier作为第二个参数。</td></tr><tr><td>String toString(Object o)<br>String toString(Object o, String nullDefault)</td><td>如果参数为null，则toString()方法返回一个“null”字符串。对于非空参数，它返回通过调用参数的toString()方法返回的值。</td></tr></tbody></table><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CLR-21垃圾回收</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<h2 id="1-访问资源步骤"><a href="#1-访问资源步骤" class="headerlink" title="1 访问资源步骤"></a>1 访问资源步骤</h2><ol><li>调用 IL 指令 newobj，为代表资源的类型分配内存（C# 一般使用 new）；</li><li>初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态；</li><li>访问类型的成员来使用资源（有必要可重复）；</li><li>摧毁资源的状态以便清理；</li><li>释放内存（垃圾回收）。<a id="more"></a></li></ol><h2 id="2-无GC存在的问题"><a href="#2-无GC存在的问题" class="headerlink" title="2 无GC存在的问题"></a>2 无GC存在的问题</h2><ul><li>忘记释放内存而造成的<strong>内存泄露</strong></li><li><strong>访问已释放的内存</strong>引起的 bug</li></ul><h2 id="3-托管堆分配资源"><a href="#3-托管堆分配资源" class="headerlink" title="3 托管堆分配资源"></a>3 托管堆分配资源</h2><p>CLR 要求所有<strong>对象</strong>都从<strong>托管堆</strong>分配，进程初始化时，CLR 划出一个地址空间区域作为托管堆，并维护一指针（NextOjbPtr），NextObjPtr 最初指向基地址，主要作用指向下一个对象在堆中的分配位置。一个区域被<strong>非垃圾对象</strong>填满后，CLR 会分配更多区域，重复直至整个进程地址空间填满，故应用程序的内存受进程的虚拟空间限制。32 位进程最多分配 1.5 GB，64 位进程为 8 TB。</p><h2 id="4-new-操作符"><a href="#4-new-操作符" class="headerlink" title="4 new 操作符"></a>4 new 操作符</h2><ol><li>计算类型的字段（及从基类型继承的字段）所需的字节数；</li><li>加上对象的开销所需字节数（每个对象 2 个开销字段：<strong>类型对象指针</strong>、<strong>同步块索引</strong>，32 位应用程序一个字段需要 32 位即 4 字节，64 位应用程序一个字段需要 64 位即 8 字节）；</li><li>CLR 检查区域中是否有分配对象所需的字节数，有则在 NextOjbPtr 指针指向的地址存放对象，为对象分配的字节会被清零。调用类型的构造器，new 操作符返回对象引用，并在此之前移动 NextOjbPtr 指针指向下一个对象存放的地址。无则先进行垃圾回收（第 0 代已满情况下），若还没空间分配则抛出 OutOfMemoryException。</li></ol><h2 id="5-垃圾回收算法"><a href="#5-垃圾回收算法" class="headerlink" title="5 垃圾回收算法"></a>5 垃圾回收算法</h2><h3 id="5-1-引用计数算法（未采用）"><a href="#5-1-引用计数算法（未采用）" class="headerlink" title="5.1 引用计数算法（未采用）"></a>5.1 引用计数算法（未采用）</h3><p>堆上每个对象都维护一个内存字段来统计程序中多少“部分”正在使用对象，若“部分”不再需要对象时，则计数递减，直至为零后可删除对象。<br><strong>存在的问题：</strong>循环引用导致对象永远不会删除。</p><h3 id="5-2-引用跟踪算法（CLR采用）"><a href="#5-2-引用跟踪算法（CLR采用）" class="headerlink" title="5.2 引用跟踪算法（CLR采用）"></a>5.2 引用跟踪算法（CLR采用）</h3><p>引用跟踪算法只计算引用类型的变量，因为只有这种变量（统称为根：类的静态字段、实例字段、方法参数、局部变量）才能引用堆上的对象，值类型直接包含值类型实例。</p><h2 id="6-GC流程"><a href="#6-GC流程" class="headerlink" title="6 GC流程"></a>6 GC流程</h2><ol><li>暂停所有线程，防止线程在 GC 检查期间访问对象并更改状态；</li><li>CLR 进入 GC 标记阶段：<br>2.1. CLR 遍历堆中的所有对象，并将同步块索引字段中的一位设为 0，表明所有对象都应删除；<br>2.2. CLR 检查所有活动根，查看它们引用了哪些对象，若为 null 则忽略继续检查下一个根；<br>2.3. 任何根若引用堆上对象，则标记那个对象（同步块索引中的一位设为1），若对象被标记，则检查对象的根，标记它们引用的对象，若对象已标记则不检查该对象字段，从而避免循环引用产生的死循环；</li><li>标记阶段结束后，堆中的对象要么已标记（可达 reachable），要么未标记（不可达 unreachable），开始进入 GC 的 压缩（compact，实际上应该称为碎片整理）阶段：<br>3.1. CLR 移动堆中已标记对象，使它们占用连续内存空间，恢复引用的“局部化”，减少应用程序工作集，从而提升性能。另外可用空间也是连续的，解决了空间碎片化问题。<strong>注意：</strong>大对象堆中的对象不会压缩，故还是可能发生地址空间碎片化。<br>3.2. CLR 从每个根减去引用对象在内存中便宜的字节数，保证每个根引用的还是之前的对象。</li><li>移动 NextObjPtr 指针指向最后一个幸存对象之后的位置，下一个分配的对象将放到这位置。</li><li>CLR 恢复应用程序的所有线程。</li></ol><p><strong>注意：</strong></p><ul><li>静态字段引用的对象一直存在，直至用于加载类型的 AppDomain 卸载为止。</li><li>内存泄露一个常见原因就是静态字段引用了一个集合对象，然后不停向集合添加数据项，导致一直存活。</li><li><strong>尽量</strong>避免使用静态字段。</li></ul><h2 id="7-基于代的垃圾回收器（generational-garbage-collector）"><a href="#7-基于代的垃圾回收器（generational-garbage-collector）" class="headerlink" title="7 基于代的垃圾回收器（generational garbage collector）"></a>7 基于代的垃圾回收器（generational garbage collector）</h2><ul><li>对象越新，生存期越短。</li><li>对象越老，生存期越长。</li><li>回收堆的一部分，速度快于回收整个堆。</li></ul><p>托管堆只支持三代（System.GC.MaxGenerationa() 返回 2）：第 0 代、第 1 代和第 2 代。</p><p>详细见P454</p><h2 id="8-垃圾回收触发条件"><a href="#8-垃圾回收触发条件" class="headerlink" title="8 垃圾回收触发条件"></a>8 垃圾回收触发条件</h2><ul><li>CLR 检测第 0 代超过预算（最常见）；</li><li>代码显示调用 System.GC.Collect();</li><li>Windows 报告低内存情况；</li><li>CLR 正在卸载 AppDomain；</li><li>CLR 正在关闭（此时 CLR 不会试图压缩或释放内存，Windows 直接回收进程的全部内存）。</li></ul><h2 id="9-大对象"><a href="#9-大对象" class="headerlink" title="9 大对象"></a>9 大对象</h2><p>CLR 将对象分为大对象和小对象，目前认为 85000 字节或更大的对象为大对象。</p><ul><li>大对象不是在小对象的地址空间分配，而是在进程地址空间的其他地方分配；</li><li>目前版本的 GC 不压缩大对象，因为在内存中移动它们代价过高，故在进程中大对象之间造成地址空间的碎片化，可能抛出 OutOfMemoryException；</li><li>大对象总是第 2 代，绝不可能是第 0 代或第 1 代，所以只能为需要长时间存活的资源创建大对象，否则会频繁回收第 2 代，损害性能。</li></ul><h2 id="10-GC模式"><a href="#10-GC模式" class="headerlink" title="10 GC模式"></a>10 GC模式</h2><p>CLR 启动时会选择一个 GC 模式，进程终止前该模式不会改变。</p><ul><li><strong>工作站（默认）：</strong>该模式针对客户端应用程序优化GC。</li><li><strong>服务器：</strong>该模式针对服务器端应用程序优化 GC。</li></ul><p><strong>注意</strong>：</p><ul><li>若计算机为单处理器，则总是使用“工作站” GC 模式；</li></ul><p>除两种主要模式外，还支持两种子模式：并发（默认）或非并发。</p><h2 id="11-特殊清理（Finalize）"><a href="#11-特殊清理（Finalize）" class="headerlink" title="11 特殊清理（Finalize）"></a>11 特殊清理（Finalize）</h2><ul><li>包含本机资源（文件、网络连接、套接字、互斥体）的类型被 GC 时，GC 会回收对象在托管堆中使用的内存，但会造成本机资源的泄露，故 CLR 提供了终结（finalization）的机制，允许对象在被判定为垃圾之后，但在对象内存被回收之前执行一些代码。任何包装了本机资源（文件、网络连接、套接字、互斥体）的类型都支持终结。CLR 判定一个对象不可达时，对象将终结它自己，释放它包装的本机资源。之后，GC 会从托管堆回收对象。</li><li>Object基类定义了受保护的虚方法 Finalize，语法<strong>~ClassName</strong>。</li><li>Finalize 是为<strong>释放本机资源</strong>而设计的。</li></ul><p><strong>注意：</strong></p><ul><li>被视为垃圾的对象在垃圾回收<strong>完毕</strong>后才调用 Finalize 方法，所以这些对象的内存不是马上被回收，造成它被提升为另一代，而这些对象引用的对象也会被提升，导致对象存活时间延长。故<strong>尽量</strong>避免为引用类型的字段定义可终结对象。</li><li>Finalize 方法执行时间不可控，且 GC 不保证多个 Finalize 的调用顺序，故在 Finalize 方法中不要访问其他定义了 Finalize 的类型对象。</li></ul><h2 id="12-dispose"><a href="#12-dispose" class="headerlink" title="12 dispose"></a>12 dispose</h2><ul><li>dispose 模式：实现了 IDisposable 接口即实现了 dispose 模式；</li><li>若类定义的一个字段的类型实现了 dispose 模式，则类本身也应实现。如果才能在类上调用 Dispose 来释放对象自身使用的资源。</li><li><strong>强烈建议</strong>将显式调用 Dispose 方法的代码放到 finally 块中或使用 using 语句块。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>CLR via C# 第21章</li></ul>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 01.CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> CLR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>收藏</title>
      <link href="//posts/07.%E6%94%B6%E8%97%8F/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
      <url>//posts/07.%E6%94%B6%E8%97%8F/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/</url>
      <content type="html"><![CDATA[<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><ul><li><a href="https://martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Inversion of Control Containers and the Dependency Injection pattern by Martin Fowler</a></li><li><a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/" target="_blank" rel="noopener">Service Locator is an Anti-Pattern by Mark Seemann</a></li></ul><h2 id="前端网站"><a href="#前端网站" class="headerlink" title="前端网站"></a>前端网站</h2><ul><li><a href="https://modernizr.com/" target="_blank" rel="noopener">Modernizr</a></li><li><a href="https://caniuse.com/" target="_blank" rel="noopener">Can I Use</a></li><li><a href="https://www.w3.org/" target="_blank" rel="noopener">w3c</a></li><li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">Mozilla开发者网络</a></li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li><a href="http://www.cnblogs.com/WeiGe/p/5658175.html" target="_blank" rel="noopener">QPS从0到4000请求每秒，谈达达后台架构演化之路</a></li></ul><h2 id="杂乱"><a href="#杂乱" class="headerlink" title="杂乱"></a>杂乱</h2><ul><li><a href="https://blog.csdn.net/yxy11256974/article/details/53449703" target="_blank" rel="noopener">如何阅读项目源代码（github）</a></li></ul>]]></content>
      
      <categories>
          
          <category> 07.收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>职业生涯相关文章收藏</title>
      <link href="//posts/09.%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF/%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/"/>
      <url>//posts/09.%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF/%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/</url>
      <content type="html"><![CDATA[<h2 id="职业生涯文章收藏"><a href="#职业生涯文章收藏" class="headerlink" title="职业生涯文章收藏"></a>职业生涯文章收藏</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247487544&amp;idx=1&amp;sn=a15c8762edf234e843e11061def8931a" target="_blank" rel="noopener">程序员吃的是青春饭？本质上取决于……</a></li></ul>]]></content>
      
      <categories>
          
          <category> 09.职业生涯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 职业生涯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UML</title>
      <link href="//posts/03.%E5%B7%A5%E5%85%B7/UML/"/>
      <url>//posts/03.%E5%B7%A5%E5%85%B7/UML/</url>
      <content type="html"><![CDATA[<h2 id="1-UML介绍"><a href="#1-UML介绍" class="headerlink" title="1 UML介绍"></a>1 UML介绍</h2><p>UML(Unified Modeling Language)又称统一建模语言或标准建模语言，一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，包括由需求分析到规格，到构造和配置。 </p><a id="more"></a><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h2><ul><li>用例图（use case diagrams）：描述用户需求，从用户的角度描述系统的功能</li><li>静态图<ul><li>类图（class  diagrams）：显示系统的静态结构</li><li>对象图（object diagrams）</li></ul></li><li>交互图<ul><li>序列图：描述对象之间的交互顺序，着重体现对象间消息传递的时间顺序</li><li>协作图（Collaboration diagrams）：描述对象之间的合作关系，侧重对象之间的消息传递 </li></ul></li><li>行为图<ul><li>状态图（Statechart diagrams）：描述对象的所有状态以及事件发生而引起的状态之间的转移</li><li>活动图（Activity diagrams）：描述满足用例要求所要进行的活动以及活动时间的约束关系</li></ul></li><li>实现图  <ul><li>构件图（Component diagrams）：描述代码构件的物理结构以及各构件之间的依赖关系</li><li>部署图（Deployment diagrams）：系统中硬件的物理体系结构</li></ul></li></ul><h2 id="3-类图"><a href="#3-类图" class="headerlink" title="3 类图"></a>3 类图</h2><h3 id="3-1-类"><a href="#3-1-类" class="headerlink" title="3.1 类"></a>3.1 类</h3><p>1 类(Class)封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。<br>2 在系统中，每个类具有一定的职责，职责指的是类所担任的任务，即类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类一般只有一种职责，在定义类的时候，将类的职责分解成为类的属性和操作（即方法）。<br>3 类的属性即类的数据职责，类的操作即类的行为职责。</p><p><img src="/images/posts/UML1.jpg" alt="类的UML图示"></p><ul><li>类名，斜体表示抽象类</li><li>属性，表示方式：<code>可见性 名称:类型 [= 缺省值]</code>，可见性又分为 +（公有）、-（私有）、#（受保护），缺省值可选项。</li><li>操作：类的行为，即成员方法。表示方式：<code>可见性 名称(参数列表) [:返回类型]</code>，返回类型可选项。</li></ul><h3 id="3-2-接口"><a href="#3-2-接口" class="headerlink" title="3.2 接口"></a>3.2 接口</h3><p><img src="http://www.uml.org.cn/oobject/images/20121123113.jpg" alt="接口的UML图示"></p><h3 id="3-3-关系"><a href="#3-3-关系" class="headerlink" title="3.3 关系"></a>3.3 关系</h3><ul><li><strong>关联关系</strong>：表示一类对象与另一类对象之间有联系（如将一个类的对象作为另一个类的成员变量）<br><img src="http://www.uml.org.cn/oobject/images/2012112314.jpg" alt="关联关系"><ul><li><strong>双向关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112315.jpg" alt="双向关联"></li><li><strong>单向关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112316.jpg" alt="单项关联"></li><li><strong>自关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112317.jpg" alt="自关联"></li><li><strong>多重关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112318.jpg" alt="多重关联"><ul><li>1..1: 表示另一个类的一个对象只与该类的一个对象有关系</li><li>0..*：表示另一个类的一个对象与该类的零个或多个对象有关系</li><li>1..*：表示另一个类的一个对象与该类的一个或多个对象有关系</li><li>0..1：表示另一个类的一个对象没有或只与该类的一个对象有关系</li><li>m..n：表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n)</li></ul></li></ul></li><li><strong>聚合（Aggregation）关系</strong>：表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。<br><img src="http://www.uml.org.cn/oobject/images/2012112319.jpg" alt="聚合关系"></li><li><strong>组合（Composition）关系</strong>：也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123110.jpg" alt="组合关系"></li><li><strong>依赖（Dependency）关系</strong>：一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。用带箭头的虚线表示，由依赖的一方指向被依赖的一方。<br><img src="http://www.uml.org.cn/oobject/images/20121123111.jpg" alt="依赖关系"></li><li><strong>泛化（Generalization）关系</strong>：用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123112.jpg" alt="泛化关系"></li><li><strong>实现（Implementation）关系</strong>：是用来规定接口和实现接口的类或者构建结构的关系，接口是操作的集合，而这些操作就用于规定类或者构建的一种服务。接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系(Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123114.jpg" alt="实现关系"></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/3160571?fr=aladdin&amp;fromid=446747&amp;fromtitle=UML" target="_blank" rel="noopener">统一建模语音百科</a></li><li><a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="noopener">深入浅出UML类图</a></li><li><a href="http://blog.csdn.net/jiuqiyuliang/article/details/8552956/" target="_blank" rel="noopener">浅谈UML的概念和模型之UML九种图</a></li><li><a href="http://blog.csdn.net/fatherican/article/details/44966891" target="_blank" rel="noopener">UML的9种图例解析</a></li></ul>]]></content>
      
      <categories>
          
          <category> 03.工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>缓存解决方案</title>
      <link href="//posts/06.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E7%BC%93%E5%AD%98/"/>
      <url>//posts/06.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h2 id="1-NoSQL总览"><a href="#1-NoSQL总览" class="headerlink" title="1 NoSQL总览"></a>1 NoSQL总览</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>NoSQL（Not Only SQL）,意即“不仅仅是SQL”，非关系型的数据库</p><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><ul><li>键值（key-value）存储数据库</li><li>列存储数据库</li><li>文档型数据库</li><li>图形（Graph)数据库</li></ul><a id="more"></a><h2 id="2-Memcached"><a href="#2-Memcached" class="headerlink" title="2 Memcached"></a>2 Memcached</h2><p>一个自由开源的，高性能，分布式内存对象缓存系统。</p><ul><li>类型：key-value 存储数据库</li><li>优点<ul><li>内存</li><li>多核，支持多线程操作</li></ul></li><li>缺点<ul><li>不支持持久化</li><li>本身不支持分布式，只能在客户端通过像一致性哈希类的分布式算法实现</li><li>单个 key-value 大小有限，一个value最大只支持 1MB</li></ul></li></ul><h2 id="3-Redis"><a href="#3-Redis" class="headerlink" title="3 Redis"></a>3 Redis</h2><p>一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。</p><ul><li>类型：key-value 存储数据库</li><li>优点<ul><li>内存</li><li>支持持久化（快照，AOF等）</li><li>支持服务器端分布式（主从复制方案）</li><li>支持多种数据结构</li><li>单个 key-value 大小有限，一个 value 最大只支持 512MB</li><li>支持pub/sub消息订阅机制</li></ul></li><li>缺点<ul><li>单核，不支持多核心多线程操作</li></ul></li></ul><h2 id="4-MongoDB"><a href="#4-MongoDB" class="headerlink" title="4 MongoDB"></a>4 MongoDB</h2><p>一个基于分布式文件存储的数据库,文档型的非关系型数据库，与上面两者不同。</p><ul><li>类型：文档存储数据库</li><li>优点<ul><li>支持持久化（binlog）</li></ul></li><li>缺点   <ul><li>不支持事务</li></ul></li></ul><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5 应用场景"></a>5 应用场景</h2><p>需要根据使用的具体场景分析：</p><ul><li>需要数据持久化或主从复制，只能采用 Redis。</li><li>需要缓存的数据只是 key-value 这样简单的结构，采用 memcache；若涉及不同数据结构，排序等选用 Redis。</li></ul><h3 id="5-1-推荐"><a href="#5-1-推荐" class="headerlink" title="5.1 推荐"></a>5.1 推荐</h3><ul><li>Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息等）。</li><li>Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。</li><li>MongoDB:主要解决海量数据的访问效率问题。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.cnblogs.com/EE-NovRain/p/3268476.html" target="_blank" rel="noopener">Redis和Memcache对比及选择</a></li><li><a href="http://www.cnblogs.com/EE-NovRain/p/3268465.html" target="_blank" rel="noopener">NoSQL发展简史、粗略分类及选择</a></li><li><a href="http://www.cnblogs.com/cac2020/category/906633.html" target="_blank" rel="noopener">分布式缓存学习之一：Memcached, Redis, MongoDB区别</a></li><li><a href="https://yq.aliyun.com/articles/38224" target="_blank" rel="noopener">Redis、Memcache和MongoDB的区别</a></li></ul>]]></content>
      
      <categories>
          
          <category> 06.解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 解决方案 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高并发网站解决方案</title>
      <link href="//posts/06.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"/>
      <url>//posts/06.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<h2 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1 服务器"></a>1 服务器</h2><ul><li>使用高性能CPU主机</li><li>数据库使用物理机，避免虚拟机，提升IO性能</li><li>使用SSD磁盘，提升IO性能</li><li>提升带宽</li></ul><h2 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2 数据库"></a>2 数据库</h2><h3 id="2-1-读写分离"><a href="#2-1-读写分离" class="headerlink" title="2.1 读写分离"></a>2.1 读写分离</h3><p>主从同步，实时将主库的数据增量复制到从库，而且一个主库可以连接多个从库同步。</p><ul><li>减轻主库（写）压力</li><li>从库（读）可水平扩展（加从库机器）</li><li>避免主从同步延迟<ul><li>优化MySQL参数，比如增大<code>innodb_buffer_pool-size</code>，让更多操作在内存中完成，减少磁盘操作</li><li>硬件推荐的方案</li><li>业务代码优化，将实时性要求高的某些操作，使用主库做读操作</li></ul></li></ul><h3 id="2-2-垂直分库"><a href="#2-2-垂直分库" class="headerlink" title="2.2 垂直分库"></a>2.2 垂直分库</h3><p>按业务拆分成不同的业务数据库，每个系统仅访问对应业务的数据库，避免或减少跨库访问。</p><ul><li>禁用或少用<code>join</code>操作，应在程序中组装数据，让SQL更简单，一方面为以后进一步拆分业务做准备，另一方面也避免了 MySQL 中 join 的性能较低问题。</li></ul><h3 id="2-3-水平分库（sharding）"><a href="#2-3-水平分库（sharding）" class="headerlink" title="2.3 水平分库（sharding）"></a>2.3 水平分库（sharding）</h3><p>单表数据量过大影响读写性能，而又不能进一步垂直拆分时，考虑将数据按字段分类（如 ID，城市）拆分为多个表，即水平分库，拆分时需要考虑数据分布是否均匀、数据聚合度是否较高、冗余表等。</p><h2 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3 缓存"></a>3 缓存</h2><p><a href="">参见缓存解决方案</a></p><h2 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4 消息队列"></a>4 消息队列</h2><h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5 代码"></a>5 代码</h2><h3 id="5-1-异步编程（async-await）"><a href="#5-1-异步编程（async-await）" class="headerlink" title="5.1 异步编程（async/await）"></a>5.1 异步编程（async/await）</h3><h2 id="6-前端"><a href="#6-前端" class="headerlink" title="6 前端"></a>6 前端</h2><h3 id="6-1-HTML静态化"><a href="#6-1-HTML静态化" class="headerlink" title="6.1 HTML静态化"></a>6.1 HTML静态化</h3><h2 id="7-负载均衡、反向代理（nginx）"><a href="#7-负载均衡、反向代理（nginx）" class="headerlink" title="7 负载均衡、反向代理（nginx）"></a>7 负载均衡、反向代理（nginx）</h2><h2 id="8-内容分发网络（CDN）"><a href="#8-内容分发网络（CDN）" class="headerlink" title="8 内容分发网络（CDN）"></a>8 内容分发网络（CDN）</h2><p>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。</p><h2 id="9-分布式集群"><a href="#9-分布式集群" class="headerlink" title="9 分布式集群"></a>9 分布式集群</h2><ul><li>服务器按功能划分：Web服务器（集群）、数据库服务器（集群）、缓存服务器（集群）、附件服务器（集群）等。</li></ul><h2 id="10-镜像"><a href="#10-镜像" class="headerlink" title="10 镜像"></a>10 镜像</h2><p>CDN的实现分为三类：镜像、高速缓存、专线。</p><ul><li>镜像站点（Mirror Site），是最常见的，它让内容直接发布，适用于静态和准动态的数据同步。但是购买和维护新服务器的费用较高，还必须在各个地区设置镜像服务器，配备专业技术人员进行管理与维护。对于大型网站来说，更新所用的带宽成本也大大提高了。</li><li>高速缓存，成本较低，适用于静态内容。Internet的统计表明，超过80%的用户经常访问的是20%的网站的内容，在这个规律下，缓存服务器可以处理大部分客户的静态请求，而原始的服务器只需处理约20%左右的非缓存请求和动态请求，于是大大加快了客户请求的响应时间，并降低了原始服务器的负载。　　CDN服务一般会在全国范围内的关键节点上放置缓存服务器。</li><li>专线，让用户直接访问数据源，可以实现数据的动态同步。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>二八定律：80%的业务访问集中在20%的数据上。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.cnblogs.com/WeiGe/p/5658175.html" target="_blank" rel="noopener">QPS从0到4000请求每秒，谈达达后台架构演化之路</a></li><li><a href="http://blog.csdn.net/y_h_t/article/details/6322823" target="_blank" rel="noopener">高并发量网站解决方案</a></li></ul>]]></content>
      
      <categories>
          
          <category> 06.解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程笔记</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp-%E7%BA%BF%E7%A8%8B/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp-%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h2><h3 id="1-1-进程-amp-线程"><a href="#1-1-进程-amp-线程" class="headerlink" title="1.1 进程&amp;线程"></a>1.1 进程&amp;线程</h3><ul><li><strong>进程</strong>：应用程序的实例要使用的资源的集合。<ul><li>每个进程都被赋予一个虚拟地址空间，确保进程中的数据和代码无法由另一个进程访问，确保了应用程序实例的健壮性；</li><li>进程无法访问OS内核代码，保证系统稳定性和安全性。</li></ul></li><li>线程<a id="more"></a></li></ul><h3 id="1-2-垃圾回收背后的线程情况"><a href="#1-2-垃圾回收背后的线程情况" class="headerlink" title="1.2 垃圾回收背后的线程情况"></a>1.2 垃圾回收背后的线程情况</h3><p>执行垃圾回收时，CLR 必须挂起（暂停）所有线程，遍历它们的栈来查找根以便对堆中的对象进行标记，再次遍历它们的栈（有的对象在压缩期间发生了移动，所以要更新它们的根），再恢复所有的线程。所以，较少线程的数量会显著提升垃圾回收的性能。</p><h3 id="1-3-调试背后的线程情况"><a href="#1-3-调试背后的线程情况" class="headerlink" title="1.3 调试背后的线程情况"></a>1.3 调试背后的线程情况</h3><p>每次使用调试器并遇到断电，Windows 都会挂起正在调试的应用程序中的所有线程，并在单步执行或者运行应用程序后恢复所有线程。所以，线程越多，调试体验越差。</p><h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><h2 id="2-深入"><a href="#2-深入" class="headerlink" title="2 深入"></a>2 深入</h2><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="2-1-要构建高性能应用程序和组件，就应该尽量避免上下文切换；"><a href="#2-1-要构建高性能应用程序和组件，就应该尽量避免上下文切换；" class="headerlink" title="2.1 要构建高性能应用程序和组件，就应该尽量避免上下文切换；"></a>2.1 要构建高性能应用程序和组件，就应该尽量避免上下文切换；</h3><h3 id="2-2-应尽量使用线程池来执行异步操作；"><a href="#2-2-应尽量使用线程池来执行异步操作；" class="headerlink" title="2.2 应尽量使用线程池来执行异步操作；"></a>2.2 应尽量使用线程池来执行异步操作；</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 01.CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> APS.NET </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp-%E9%9D%A2%E8%AF%95/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp-%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="1-C-和-NET"><a href="#1-C-和-NET" class="headerlink" title="1. C#和.NET"></a>1. C#和.NET</h2><h3 id="1-1-C-基础知识"><a href="#1-1-C-基础知识" class="headerlink" title="1.1 C#基础知识"></a>1.1 C#基础知识</h3><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><ul><li>private【Private】 私有（定义类型、嵌套类型）</li><li>protected【Family】 保护（定义类型、嵌套类型、不同程序集中的派生类型）</li><li>C#不支持【Family and Assembly】（定义类型、嵌套类型、同一程序集中的派生类型）</li><li>internal【Assembly】 内部（同一程序集中的所有类型）</li><li>protected internal【Family or Assembly】（定义类型、嵌套类型、同一程序集中的所有类型，不同程序集中的派生类型）</li><li>public【Public】 公有</li></ul><p><em>PS：</em></p><ul><li>【】中为CLR术语。</li><li><code>C#</code>派生类型重写基类型定义的成员，<code>C#编译器</code>要求两者具有相同可访问性，<code>CLR</code>允许放宽但不允许收紧成员的可访问性。</li></ul><a id="more"></a><h4 id="值类型、引用类型"><a href="#值类型、引用类型" class="headerlink" title="值类型、引用类型"></a>值类型、引用类型</h4><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>1 总是从<code>托管堆</code>分配，new 操作符返回指向对象的内存地址；<br>2 堆上分配的每个对象都有一些额外成员（类型对象指针、同步块索引），这些成员必须初始化；<br>3 对象中的其他字节（为字段而设）总是设为零；<br>4 从托管堆分配对象时，可能强制执行一次垃圾回收。</p><h5 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h5><p>1 <code>一般</code>在<code>线程栈</code>上分配；<br>2 优点：缓解托管堆的压力，减少应用程序生存期内的垃圾回收次数；<br>3 所有值类型必须从 System.ValueType 派生；<br>4 值类型可以实现一个或多个接口；<br>5 所有值类型隐式密封；</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul><li>值类型对象两种表示形式：未装箱和已装箱，引用类型总是已装箱</li><li>值类型从 System.ValueType 派生，该类型重写了 Equals 方法，能在两对象的字段值完全匹配返回 true，也重写了 GetHashCode 方法，算法会将实例字段的值计算进去。<em>由于默认实现存在性能问题，故定义值类型需重写。</em></li><li>值类型隐式密封，故不应引入任何虚方法，且所有方法不能时抽象方法，所有方法都隐式密封。</li><li>引用类型包含堆中对象的地址，默认初始化为 null，值类型总是包含基础类型的一个值，默认初始化为 0。</li><li>值类型赋给另一个值类型变量，会执行逐字段复制，引用类型则只复制内存地址，故对值类型变量执行操作不会影响另一个值类型，引用类型则不同。</li><li>由于未装箱的值类型不在堆上分配，一旦定义了该类型的实例的方法不再活动，分配的存储就会释放，而不等垃圾回收。</li></ul><h5 id="值类型设计前提："><a href="#值类型设计前提：" class="headerlink" title="值类型设计前提："></a>值类型设计前提：</h5><ul><li>类型具有基元类型的行为，没有成员会改变类型的任何实例字段。即不可变（immutable），建议将全部字段标记为 readonly。</li><li>类型不需要从其他类型继承。</li><li>类型也不派生其他任何类型。</li><li>类型的实例较小（16字节或更小）。</li><li>类型的实例较大（大于16字节），但不作为方法实参传递，也不作为返回参数。</li></ul><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul><li><a href="http://www.cnblogs.com/venux/p/6307561.html" target="_blank" rel="noopener">个人笔记</a></li></ul><h4 id="委托、事件"><a href="#委托、事件" class="headerlink" title="委托、事件"></a>委托、事件</h4><h4 id="重载、重写"><a href="#重载、重写" class="headerlink" title="重载、重写"></a>重载、重写</h4><h4 id="接口、抽象类"><a href="#接口、抽象类" class="headerlink" title="接口、抽象类"></a>接口、抽象类</h4><h4 id="out和ref"><a href="#out和ref" class="headerlink" title="out和ref"></a>out和ref</h4><h4 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h4><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><ul><li>Equals:如果两个<code>对象</code>具有相同值，就返回true。<ul><li>对象相等性和同一性</li></ul></li><li>GetHashCode:若对象要在哈希表集合（如Dictionary）中作为键，则应重写该方法。<ul><li>良好分布：指针对所有输入，GetHashCode生成的哈希值应该在所有整数中产生一个随机的分布。</li></ul></li><li>ToString:默认返回类型的完整名称（this.GetType().FullName）。</li><li>GetType:返回类型的一个实例。<ul><li>非虚方法，防止类重写，隐瞒类型，从而破坏类型安全性。</li></ul></li><li><a href="https://msdn.microsoft.com/en-us/library/system.object.memberwiseclone(v=vs.110" target="_blank" rel="noopener">MemberwiseClone</a>.aspx):浅拷贝。<ul><li>protected</li><li>非虚方法</li><li>The MemberwiseClone method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object. If a field is a <code>value</code> type, <code>a bit-by-bit copy of the field is performed</code>. If a field is a <code>reference</code> type, <code>the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object</code>.（意即：obj和cloneObj对应的值类型不会同时改变；引用类型同时改变）。    </li></ul></li><li>Finalize:垃圾回收之前调用该<code>虚</code>方法，可重写进行对象清理工作。</li></ul><h4 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h4><p>1 计算类型及其所有基类型（直到Object）中定义的所有<code>实例字段</code>需要的字节数，堆上每个对象都需要一些额外的成员（overhead成员、开销成员），包括<code>类型对象指针type object pointer</code>和<code>同步块索引sync block index</code>，CLR利用这些成员管理对象，额外成员的字节数需要计入对象大小。</p><p>2 从<code>托管堆</code>分配类型要求的字节数，从而分配对象的内存，所有字节设为零。</p><p>3 初始化对象的类型对象指针和同步块索引。</p><p>4 调用类型的实例构造器，传递实参，编译器自动生成代码调用基类构造器，并负责初始化定义的实例字段，最终调用Object的构造器，返回。</p><p>5 返回指向新建对象的一个引用（指针）。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li>C#运行类型定义转换操作符方法，但只有使用转型表达式才调用，使用<code>as</code>或<code>is</code>永不调用它们。</li></ol><h4 id="类型、对象、线程栈、托管堆在运行时的相互关系"><a href="#类型、对象、线程栈、托管堆在运行时的相互关系" class="headerlink" title="类型、对象、线程栈、托管堆在运行时的相互关系"></a>类型、对象、线程栈、托管堆在运行时的相互关系</h4><p>CLR via C# 4.4 P90</p><h4 id="字段和属性有什么区别"><a href="#字段和属性有什么区别" class="headerlink" title="字段和属性有什么区别"></a>字段和属性有什么区别</h4><ul><li><p>答一：两者都是类的成员。不同的是：<br>  1 字段是数据成员，属性是方法成员;<br>  2 访问上对于属性访问需要使用访问元get,set，字段没有访问元直接赋值或者取值;<br>  3 属性能override，visual字段不能。</p></li><li><p>答二：如果你编写一些控件给别的开发者用，而需要给他们提供“数据绑定”这种傻瓜化的机制，那么使用属性才可以做到。<br>属性是方法而字段不是，当你用反射去掉用的时候，它们有各自的API。因为属性是方法，所以它可以和方法那样定义在接口中，或者被继承和重写，重写属性被ORM/AOP等框架用来注入代码。</p></li></ul><h4 id="抽象方法，和虚方法的区别"><a href="#抽象方法，和虚方法的区别" class="headerlink" title="抽象方法，和虚方法的区别"></a>抽象方法，和虚方法的区别</h4><ul><li>抽象方法一定是虚方法，虚方法未必是抽象方法。</li><li>虚方法是指可以被继承类重写的方法，而抽象方法是指，基类是抽象类，没有实现它，因此必须被继承类重写的方法。</li></ul><h4 id="new的几种用法"><a href="#new的几种用法" class="headerlink" title="new的几种用法"></a>new的几种用法</h4><ul><li>创建对象或者结构（只是用于调用结构构造函数）；</li><li>隐藏基类成员；</li><li>泛型里用于约束</li></ul><h4 id="什么叫做泛型"><a href="#什么叫做泛型" class="headerlink" title="什么叫做泛型"></a>什么叫做泛型</h4><ul><li>从编程的角度说是在定义类或者方法的时候省去具体的类型，由调用者来指定，类型+泛型类型合成得到真正的类型。</li><li>从实现机制上说，泛型是CLR在运行时动态根据泛型类型创建的匿名类型。</li><li>从OO设计的角度说，泛型体现了多态性。</li><li>泛型使得程序员可以复用数据结构和算法，并且适应不同的类型，享有编译期间的强类型检查和语法提示。<br>  一些经典的FCL提供的泛型类型和接口,List<t>、Dictionary&lt;T1, T2&gt;这个属于复用数据结构,IComparer<t>、IEnumerable<t>这个属于复用算法</t></t></t></li></ul><h4 id="什么叫做类"><a href="#什么叫做类" class="headerlink" title="什么叫做类"></a>什么叫做类</h4><p>就C#而言，类是对象的模板，对象是类的实例。C#是强类型语言，一切皆需要类型，除了内置的简单类型，那些其实例为引用对象的都叫做类。C#也允许定义抽象类和密封类，以及两者的叠加——静态类，它们都无法实例化，其实这是编译器的限制，本质上它们和一般的类没有区别，是特殊情况。</p><h4 id="EF的理解"><a href="#EF的理解" class="headerlink" title="EF的理解"></a>EF的理解</h4><ul><li>对象关系映射（ORM）机制和LINQ To EF Provider，在此基础上的缓存机制、延迟加载、对象状态跟踪、事务等等。</li><li>EF是微软官方的ORM框架，结束了之前各种第三方ORM混战的局面，统一了API，这无疑是开发者的福音。EF拥有非常优雅的，基于C#/VB语言优化的API，比如原生的LINQ查询，自然的Code First的对数据结构的定义，Fluent API方式的数据库和关系的定义等等。VS完美支持EF并且提供了多种数据库的适配。</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>开发调试时打开编译器的/checked+开关，虽然会慢点，但能轻松进行溢出检查，及时修正BUG。正式发布时使用/checked-开关。</li><li>System.Decimal是<code>非常特殊</code>的类型，虽然C#视其为基元类型，但CLR不然。内部提供各种计算方法和操作符重载，故处理速度慢于CLR基元类型。</li></ul><h3 id="1-2-ASP-NET"><a href="#1-2-ASP-NET" class="headerlink" title="1.2 ASP.NET"></a>1.2 ASP.NET</h3><h4 id="页面传值"><a href="#页面传值" class="headerlink" title="页面传值"></a>页面传值</h4><ul><li><a href="http://www.cnblogs.com/zhangkai2237/archive/2012/05/06/2486462.html" target="_blank" rel="noopener">参考1</a></li></ul><h4 id="ASP-NET服务器控件的生命周期"><a href="#ASP-NET服务器控件的生命周期" class="headerlink" title="ASP.NET服务器控件的生命周期"></a>ASP.NET服务器控件的生命周期</h4><ul><li><a href="http://www.cnblogs.com/waters/articles/3373013.html" target="_blank" rel="noopener">参考1</a></li><li><a href="http://www.cnblogs.com/peterYong/p/6556597.html" target="_blank" rel="noopener">参考2</a></li></ul><h4 id="ASP-NET七个内置对象"><a href="#ASP-NET七个内置对象" class="headerlink" title="ASP.NET七个内置对象"></a>ASP.NET七个内置对象</h4><h3 id="1-3-名词解释"><a href="#1-3-名词解释" class="headerlink" title="1.3 名词解释"></a>1.3 名词解释</h3><ul><li>FCL(Framework Class Library)框架类库</li><li>CLS(Common Language Stander)</li><li>CLR(Common Language Runtime)公共语言运行时</li><li>IDL(Interface Definition Language)接口定义语言</li><li>IL(Intermediate Language)中间语言</li></ul><h3 id="1-4-IL"><a href="#1-4-IL" class="headerlink" title="1.4 IL"></a>1.4 IL</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul><li>add：两值相加，不执行溢出检查</li><li>add.ovf：两值相加，执行溢出检查，抛出System.OverflowException</li><li>sub：减</li><li>sub.ovf</li><li>mul：乘</li><li>mul.ovf</li><li>conv：转换</li><li>conv.ovf</li></ul><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li>CLR via C#(第4版)</li><li><a href="http://bbs.csdn.net/topics/390919248" target="_blank" rel="noopener">文章一</a></li></ul><h2 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2.数据库"></a>2.数据库</h2><h3 id="2-1-基础"><a href="#2-1-基础" class="headerlink" title="2.1 基础"></a>2.1 基础</h3><ul><li>Table1含有字段Col1，Col2，Col3，请用一条标准SQL选出Col2重复条数&gt;=2的所有记录。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">COUNT</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Table1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    Col2</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    <span class="keyword">COUNT</span>(COL2) &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-SQL性能优化"><a href="#2-2-SQL性能优化" class="headerlink" title="2.2 SQL性能优化"></a>2.2 SQL性能优化</h3><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><h2 id="3-数据结构和算法"><a href="#3-数据结构和算法" class="headerlink" title="3. 数据结构和算法"></a>3. 数据结构和算法</h2><h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><h3 id="3-2-算法"><a href="#3-2-算法" class="headerlink" title="3.2 算法"></a>3.2 算法</h3><h4 id="3-2-1-冒泡排序"><a href="#3-2-1-冒泡排序" class="headerlink" title="3.2.1 冒泡排序"></a>3.2.1 冒泡排序</h4><h4 id="3-2-2-快速排序"><a href="#3-2-2-快速排序" class="headerlink" title="3.2.2 快速排序"></a>3.2.2 快速排序</h4><h4 id="3-2-3-冒泡排序"><a href="#3-2-3-冒泡排序" class="headerlink" title="3.2.3 冒泡排序"></a>3.2.3 冒泡排序</h4><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://github.com/aalhour/C-Sharp-Algorithms" target="_blank" rel="noopener">https://github.com/aalhour/C-Sharp-Algorithms</a></p><h2 id="4-编程思想"><a href="#4-编程思想" class="headerlink" title="4. 编程思想"></a>4. 编程思想</h2><h3 id="4-1-原则"><a href="#4-1-原则" class="headerlink" title="4.1 原则"></a>4.1 原则</h3><ul><li>SOLID</li></ul><h3 id="4-2-设计模式"><a href="#4-2-设计模式" class="headerlink" title="4.2 设计模式"></a>4.2 设计模式</h3><h3 id="4-3-MVC"><a href="#4-3-MVC" class="headerlink" title="4.3 MVC"></a>4.3 MVC</h3><h3 id="4-4-DDD"><a href="#4-4-DDD" class="headerlink" title="4.4 DDD"></a>4.4 DDD</h3><h2 id="5-前端"><a href="#5-前端" class="headerlink" title="5. 前端"></a>5. 前端</h2><h3 id="5-1-JavaScript"><a href="#5-1-JavaScript" class="headerlink" title="5.1 JavaScript"></a>5.1 JavaScript</h3><h3 id="5-2-JQuery"><a href="#5-2-JQuery" class="headerlink" title="5.2 JQuery"></a>5.2 JQuery</h3><h3 id="5-3-性能优化"><a href="#5-3-性能优化" class="headerlink" title="5.3 性能优化"></a>5.3 性能优化</h3><h3 id="5-4-其他"><a href="#5-4-其他" class="headerlink" title="5.4 其他"></a>5.4 其他</h3><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><h3 id="6-1-新技术"><a href="#6-1-新技术" class="headerlink" title="6.1 新技术"></a>6.1 新技术</h3><h3 id="6-2-职业规划"><a href="#6-2-职业规划" class="headerlink" title="6.2 职业规划"></a>6.2 职业规划</h3>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 01.CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaEE开发环境搭建</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="1-Java环境"><a href="#1-Java环境" class="headerlink" title="1.Java环境"></a>1.Java环境</h2><h3 id="1-1-Java下载"><a href="#1-1-Java下载" class="headerlink" title="1.1 Java下载"></a>1.1 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Java下载</a></h3><h3 id="1-2-环境变量配置"><a href="#1-2-环境变量配置" class="headerlink" title="1.2 环境变量配置"></a>1.2 环境变量配置</h3><ol><li><strong>JAVA_HOME</strong>:C:\Program Files\Java\jdk1.8.0_144（注：结尾不加分号）</li><li><strong>PATH</strong>:%JAVA_HOME%\bin;</li><li><strong>CLASS_PATH</strong>:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</li></ol><h3 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h3><ul><li><strong>java-version</strong>:版本号</li><li><strong>java</strong>:Java环境</li><li><strong>javac</strong>:Java编译器</li></ul><h3 id="1-4-Eclipse集成"><a href="#1-4-Eclipse集成" class="headerlink" title="1.4 Eclipse集成"></a>1.4 Eclipse集成</h3><ul><li><strong>默认</strong>：Eclipse 会自动关联环境变量中配置的 JDK。</li><li><strong>手动</strong>：“Window”–“Preferences”–“Java”–“Installed JREs”–“Add”–“Standard VM”–选择jdk安装目录。 （多个版本的JDK手工进行配置）</li></ul><a id="more"></a><h2 id="2-Tomcat服务器"><a href="#2-Tomcat服务器" class="headerlink" title="2.Tomcat服务器"></a>2.Tomcat服务器</h2><h3 id="2-1-Tomcat下载"><a href="#2-1-Tomcat下载" class="headerlink" title="2.1 Tomcat下载"></a>2.1 <a href="http://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">Tomcat下载</a></h3><h3 id="2-2-环境变量配置"><a href="#2-2-环境变量配置" class="headerlink" title="2.2 环境变量配置"></a>2.2 环境变量配置</h3><ol><li><strong>CATALINA_HOME</strong>：C:\Program Files\Tomcat 8.5（注：结尾不加分号）</li><li><strong>PATH</strong>:%CATALINA_HOME%\bin;</li></ol><h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h3><ul><li><strong>localhost:8080</strong>:Tomcat默认主页</li></ul><h3 id="2-4-Eclipse集成"><a href="#2-4-Eclipse集成" class="headerlink" title="2.4 Eclipse集成"></a>2.4 Eclipse集成</h3><ul><li>“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。</li></ul><h2 id="3-Eclipse-IDE"><a href="#3-Eclipse-IDE" class="headerlink" title="3.Eclipse IDE"></a>3.Eclipse IDE</h2><h3 id="3-1-Eclipse下载"><a href="#3-1-Eclipse下载" class="headerlink" title="3.1 Eclipse下载"></a>3.1 <a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse下载</a></h3><h2 id="4-Maven"><a href="#4-Maven" class="headerlink" title="4.Maven"></a>4.Maven</h2><p>基于项目对象模型POM（Project Object Model），用来管理项目的构建、报告和文档的软件项目管理工具。主要提供：</p><ul><li>统一开发规范和工具</li><li>统一管理 jar 包</li></ul><h3 id="4-1-Maven下载"><a href="#4-1-Maven下载" class="headerlink" title="4.1 Maven下载"></a>4.1 <a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven下载</a></h3><h3 id="4-2-环境变量配置"><a href="#4-2-环境变量配置" class="headerlink" title="4.2 环境变量配置"></a>4.2 环境变量配置</h3><ol><li><strong>MAVEN_HOME</strong>:C:\Program Files\apache-maven-3.5.0（注：结尾不加分号）</li><li><strong>PATH</strong>:%MAVEN_HOME%\lib;</li><li><strong>MAVEN_OPTS</strong>: -Xms128m -Xmx512m;(设置Maven可用内存大小)</li></ol><h3 id="4-3-测试"><a href="#4-3-测试" class="headerlink" title="4.3 测试"></a>4.3 测试</h3><ul><li><strong>maven -v</strong>:版本号</li></ul><h3 id="4-4-配置文件"><a href="#4-4-配置文件" class="headerlink" title="4.4 配置文件"></a>4.4 配置文件</h3><p><code>‪C:\Program Files\apache-maven-3.5.0\conf\settings.xml</code></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1 <a href="http://maven.apache.org/index.html" target="_blank" rel="noopener">Maven官网</a><br>2 <a href="http://blog.csdn.net/column/details/maven-it.html" target="_blank" rel="noopener">Maven入门</a><br>3 <a href="http://blog.csdn.net/lfsfxy9/article/details/9397937" target="_blank" rel="noopener">Eclipse Maven插件安装</a></p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 02.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
            <tag> Eclipse </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-09.DECORATOR（装饰）— 对象结构型模式</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-09%E8%A3%85%E9%A5%B0/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-09%E8%A3%85%E9%A5%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>动态地给一个对象添加一些额外的职责。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>包装器 Wrapper</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>希望给某个对象而不是整个类添加一些功能。如图形界面添加一些特性（边框，滚动等）。</p><ul><li>使用继承机制是以一种有效途径，然而不够灵活；</li><li>将组件嵌入另一个对象，有这个对象添加特性，该嵌入的对象称为装饰。该装饰与所装饰的组件接口一致，故对其透明。</li></ul><p><img src="/images/posts/装饰1.png" alt="图一"><br><img src="/images/posts/装饰2.png" alt="图二"><br><a id="more"></a></p><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>处理那些可以撤消的职责。</li><li>当不能采用生成子类的方法进行扩充时。<ul><li>一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。</li><li>另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li></ul></li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/装饰3.png" alt="图三"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul><li>Component(VisualComponent)<ul><li>定义一个对象接口，可以给这些对象动态地添加职责。</li></ul></li><li>ConcreteComponent(TextView)<ul><li>定义一个对象，可以给这个对象添加一些职责。</li></ul></li><li>Decorator<ul><li>维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。</li></ul></li><li>ConcreteDecorator(BorderDecorator,ScrollDecorator)<ul><li>向组件添加职责。</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>Decorator 将请求转发给它的 Component 对象，并有可能在转发请求前后执行一些附加的<br>动作。</p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul><li>优点：<ul><li>比静态继承更灵活</li><li>避免在层次结构高层的类有太多的特征</li></ul></li><li>缺点：<ul><li>Decorator 与 Component 不同，故使用 Decorator 不应该依赖 Component</li><li>有许多小对象</li></ul></li></ul><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul><li>接口的一致性；</li><li>省略抽象的 Decorator 类，仅需要一个职责时；</li><li>保存 Component 类的简单性；</li><li>改变对象外壳（Strategy 策略模式可改变对象内核）</li></ul><p><code>注：</code>当 Component 类原本很庞大时，使用 Decorator 模式代价太大，可考虑使用 Strategy 模式。<br><img src="/images/posts/装饰5.png" alt="图五"></p><h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul><li><p>Component</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Component</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void Operation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ConcreteComponent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ConcreteComponent:Component</span><br><span class="line">&#123;</span><br><span class="line">    public override void Operation()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;ConcreteComponent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BaseDecorator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class BaseDecorator:Component</span><br><span class="line">&#123;</span><br><span class="line">    private Component component;</span><br><span class="line"></span><br><span class="line">    public BaseDecorator(Component component)</span><br><span class="line">    &#123;</span><br><span class="line">        this.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void Operation()</span><br><span class="line">    &#123;       </span><br><span class="line">        if(component!=null)</span><br><span class="line">        &#123;</span><br><span class="line">            component.Operation();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ConcreteDecorator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ConcreteDecorator:BaseDecorator</span><br><span class="line">&#123;</span><br><span class="line">    public ConcreteDecorator(Component component)</span><br><span class="line">        ：base(component)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void Operation()</span><br><span class="line">    &#123;       </span><br><span class="line">        base.Operation();</span><br><span class="line">        this.Draw();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    private void Draw()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;ConcreteDecorator&quot;);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Client</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Component component=new ConcreteComponent();</span><br><span class="line">        component.Operation();</span><br><span class="line"></span><br><span class="line">        BaseDecorator decorator=new ConcreteDecorator(component);</span><br><span class="line">        decorator.Operation();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>用户界面工具，Stream。<br><img src="/images/posts/装饰4.png" alt="图四"></p><h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul><li><strong>Adapter 模式：</strong>Decorator 模式不同于 Adapter 模式，因为装饰仅改变对象的职责而不改<br>变它的接口；而适配器将给对象一个全新的接口。</li><li><strong>Composite 模式：</strong>可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅<br>给对象添加一些额外的职责—它的目的不在于对象聚集。</li><li><strong>Strategy 模式：</strong>用一个装饰你可以改变对象的外表；而Strategy模式使得你可以改变<br>对象的内核。这是改变对象的两种途径。</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 01.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-08.COMPOSITE（组合）— 对象结构型模式</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08%E7%BB%84%E5%90%88/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08%E7%BB%84%E5%90%88/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>无</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>在绘图编辑器和图形捕捉系统这样的图形应用程序中，用户可以使用简单的组件创建复杂的图表。用户可以组合多个简单组件以形成一些较大的组件，这些组件又可以组合成更大的组件。一个简单的实现方法是为 Text 和 Line 这样的图元定义一些类，另外定义一些类作为这些图元的容器类（Container）。问题：使用这些类的代码必须区别对待图元对象与容器对象，而实际上大多数情况下用户认为它们是一样的。<br><img src="/images/posts/组合1.jpg" alt="图一"><br><a id="more"></a></p><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul><li>你想表示对象的部分 -整体层次结构。</li><li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/组合2.jpg" alt="图二"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul><li>Component(Graphic)<ul><li>为组合中的对象声明接口。</li><li>在适当的情况下，实现所有类共有接口的缺省行为。</li><li>声明一个接口用于访问和管理 Component 的子组件。</li><li>(可选)在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它。</li></ul></li><li>Leaf(Rectangle、Line、Text 等)<ul><li>在组合中表示叶节点对象，叶节点没有子节点。</li><li>在组合中定义图元对象的行为。</li></ul></li><li>Composite(Picture)<ul><li>定义有子部件的那些部件的行为。</li><li>存储子部件。</li><li>在 Component 接口中实现与子部件有关的操作。</li></ul></li><li>Client<ul><li>通过 Component 接口操纵组合部件的对象。</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>用户使用  Component 类接口与组合结构中的对象进行交互。如果接收者是一个叶节点 ,则直接处理请求。如果接收者是  Composite , 它通常将请求发送给它的子部件，在转发请求之前与/或之后可能执行一些辅助操作。</p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul><li>定义了包含基本对象和组合对象的类层次结构 </li><li>简化客户代码</li><li>使得更容易增加新类型的组件</li><li>使你的设计变得更加一般化</li><li>子部件排序</li><li></li></ul><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul><li>显式的父部件引用</li><li>共享组件</li><li>最大化 Component 接口</li><li>声明管理子部件的操作（透明性 or 安全性）</li><li>Component 是否应该实现一个 Component 列表</li><li>应该由谁删除 Component</li><li>存贮组件最好用哪一种数据结构（列表、树、数组和 hash 表，效率）</li></ul><h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul><li><p>Component</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Component</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void Operation();</span><br><span class="line"></span><br><span class="line">    public virtual void Add(Component component)</span><br><span class="line">    &#123;</span><br><span class="line">        //默认实现，Leaf不需要复写，Composite需要复写</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public virtual void Remove(Component component)</span><br><span class="line">    &#123;</span><br><span class="line">        //默认实现，Leaf不需要复写，Composite需要复写</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public virtual Component GetChild(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        //默认实现，Leaf不需要复写，Composite需要复写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Leaf(Rectangle、Line、Text 等)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Leaf:Component</span><br><span class="line">&#123;</span><br><span class="line">    public override void Operation()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Leaf&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Composite(Picture)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Composite:Component</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;Component&gt; children=new List&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">    public override void Operation()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach(var component in children)</span><br><span class="line">        &#123;</span><br><span class="line">            component.Operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public new void Add(Component component)</span><br><span class="line">    &#123;</span><br><span class="line">        children.Add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public new void Remove(Component component)</span><br><span class="line">    &#123;</span><br><span class="line">       children.Add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public new Component GetChild(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        return children[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Client</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Component leaf=new Leaf();</span><br><span class="line">        leaf.Operation();</span><br><span class="line"></span><br><span class="line">        Component composite=new Composite();</span><br><span class="line">        composite.Add(leaf);</span><br><span class="line">        composite.Operation();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>MVC 中的 View。</p><h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul><li>通常部件 - 父部件连接用于 Responsibility of Chain 模式。</li><li>Decorator 模式经常与 Composite 模式一起使用。当装饰和组合一起使用时，它们通常有一个公共的父类。因此装饰必须支持具有 Add、Remove 和 GetChild 操作的 Component。</li><li>Flyweight 让你共享组件，但不再能引用他们的父部件。</li><li>Itertor 可用来遍历 Composite。</li><li>Visitor 将本来应该分布在 Composite 和 Leaf 类中的操作和行为局部化。</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 01.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-07.BRIDGE（桥接）— 对象结构型模式</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-07%E6%A1%A5%E6%8E%A5/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-07%E6%A1%A5%E6%8E%A5/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>Handle/Body</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>当一个抽象可能有多个实现时，通常用继承来协调它们。抽象类定义对该抽象的接口，而具体的子类则用不同方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。继承机制有两个不足之处：<br>1) 扩展抽象使之适用于不同种类的窗口或新的系统平台很不方便。<br>2) 继承机制使得客户代码与平台相关。<br><a id="more"></a></p><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul><li>你不希望在抽象和它的实现部分之间有一个固定的绑定关系。 例如在程序运行时刻实现部分应可以被选择或者切换。</li><li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时 Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</li><li>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。</li><li>（C++）你想对客户完全隐藏抽象的实现部分。在 C++ 中，类的表示在类接口中是可见的。</li><li>正如在意图一节的第一个类图中所示的那样，有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。 </li><li>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/桥接1.jpg" alt="图一"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul><li>Abstraction(Window)<ul><li>定义抽象类的接口。</li><li>维护一个指向 Implementor 类型对象的指针。</li></ul></li><li>RefinedAbstraction(IconWindow)<ul><li>扩充由 Abstraction 定义的接口。</li></ul></li><li>Implementor(WindowImp)<ul><li>定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致；事实上这两个接口可以完全不同。一般来讲，Implementor 接口仅提供基本操作，而 Abstraction 则定义了基于这些基本操作的较高层次的操作。</li></ul></li><li>ConcreteImplementor(XwindowImp,PMWindowImp)<ul><li>实现 Implementor 接口并定义它的具体实现。</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>Abstraction 将 client 的请求转发给它的 Implementor 对象。</p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul><li>分离接口及其实现部分</li><li>提高可扩充性</li><li>实现细节对客户透明 </li></ul><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul><li><strong>仅有一个 Implementor</strong>在仅有一个实现的时候，没有必要创建一个抽象的 Implementor 类。这是 Bridge 模式的退化情况；在 Abstraction 与 Implementor 之间有一种一对一的关系。尽管如此，当你希望改变一个类的实现不会影响已有的客户程序时，模式的分离机制还是非常有用的—也就是说，不必重新编译它们，仅需重新连接即可。</li><li><strong>创建正确的 Implementor 对象</strong><ul><li>如果 Abstraction 知道所有的 ConcreteImplementor 类，它就可以在它的构造器中对其中的一个类进行实例化，它可以通过传递给构造器的参数确定实例化哪一个类。</li><li>首先选择一个缺省的实现，然后根据需要改变这个实现。</li><li>代理给另一个对象，由它一次决定。</li></ul></li><li><strong>共享 Implementor 对象</strong>多个对象间共享一些实现，有一个对象引用计数器，并对它进行增减操作。</li><li><strong>采用多重继承机制</strong>C#不支持，不考虑</li></ul><h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul><li><p>Abstraction</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Abstraction</span><br><span class="line">&#123;</span><br><span class="line">    Implementor implementor=null;</span><br><span class="line"></span><br><span class="line">    public Abstraction(Implementor implementor)</span><br><span class="line">    &#123;</span><br><span class="line">        this.implementor=implementor;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public void Operation()</span><br><span class="line">    &#123;</span><br><span class="line">        implementor.OperationImp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RefinedAbstraction</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class RefinedAbstraction:Abstraction</span><br><span class="line">&#123;</span><br><span class="line">    public RefinedAbstraction(Implementor implementor)</span><br><span class="line">        :base(implementor)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Implementor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Implementor</span><br><span class="line">&#123;</span><br><span class="line">    void OperationImp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ConcreteImplementor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ConcreteImplementorA</span><br><span class="line">&#123;</span><br><span class="line">    public void OperationImp()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;ConcreteImplementorA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ConcreteImplementorB</span><br><span class="line">&#123;</span><br><span class="line">    public void OperationImp()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;ConcreteImplementorB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>三层架构的BLL和DAL层</p><h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul><li>Abstract Factory 模式可以用来创建和配置一个特定的 Bridge 模式。</li><li>Adapter 模式用来帮助无关的类协同工作，它通常在系统设计完成后才会被使用。然而，Bridge 模式则是在系统开始时就被使用，它使得抽象接口和实现部分可以独立进行改变。</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 01.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-06.ADAPTER（适配器）— 类对象结构型模式</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-06%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-06%E9%80%82%E9%85%8D%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>包装器 Wrapper</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>一个应用可能会有一些类具有不同的接口并且这些接口互不兼容，在这样的应用中象 TextView 这样已经存在并且不相关的类如何协同工作呢？我们可以改变 TextView 类使它兼容 Shape 类的接口，但前提是必须有这个工具箱的源代码。然而即使我们得到了这些源代码，修改 TextView 也是没有什么意义的；因为不应该仅仅为了实现一个应用，工具箱就不得不采用一些与特定领域相关的接口。<br><img src="/images/posts/适配器1.jpg" alt="图一"></p><a id="more"></a><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul><li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li><li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li><li>（仅适用于对象 Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><ul><li>类适配器使用多重继承对一个接口与另一个接口进行匹配<br><img src="/images/posts/适配器2.jpg" alt="图二"></li><li>对象匹配器依赖于对象组合<br><img src="/images/posts/适配器3.jpg" alt="图三"></li></ul><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul><li>Target(Shape)<ul><li>定义 Client 使用的与特定领域相关的接口。</li></ul></li><li>Client(DrawingEditor)<ul><li>与符合 Target 接口的对象协同。</li></ul></li><li>Adaptee(TextView)<ul><li>定义一个已经存在的接口，这个接口需要适配。</li></ul></li><li>Adapter(TextShape)<ul><li>对 Adaptee 的接口与 Target 接口进行适配。</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>Client 在 Adapter 实例上调用一些操作。接着适配器调用 Adaptee 的操作实现这个请求。</p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul><li>类适配器<ul><li>用一个具体的 Adapter 类对 Adaptee 和 Target 进行匹配。结果是当我们想要匹配一个类以及所有它的子类时，类 Adapter 将不能胜任工作。</li><li>使得 Adapter 可以重定义 Adaptee 的部分行为，因为 Adapter 是 Adaptee 的一个子类。</li><li>仅仅引入了一个对象，并不需要额外的指针以间接得到 Adaptee。</li></ul></li><li>对象适配器<ul><li>允许一个 Adapter 与多个 Adaptee 即Adaptee本身以及它的所有子类（如果有子类的话）。</li><li>同时工作 Adapter 也可以一次给所有的 Adaptee 添加功能。</li><li>使得重定义 Adaptee 的行为比较困难。这就需要生成 Adaptee 的子类并且使得 Adapter 引用这个子类而不是引用 Adaptee 本身。</li></ul></li></ul><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul><li>使用 C++ 实现适配器类</li><li>可插入的适配器<ul><li>使用抽象操作<br><img src="/images/posts/适配器4.jpg" alt="图四"></li><li>使用代理对象<br><img src="/images/posts/适配器5.jpg" alt="图五"></li><li>参数化的适配器</li></ul></li></ul><h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul><li><p>Target</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ITarget</span><br><span class="line">&#123;</span><br><span class="line">    void Request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Adaptee</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Adaptee</span><br><span class="line">&#123;</span><br><span class="line">    public void SpecificRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;适配的对象&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Adapter<br>类适配器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ClassAdapter : Adaptee, ITarget</span><br><span class="line">&#123;</span><br><span class="line">    public void Request()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;目标对象&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象适配器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ObjectAdapter : ITarget</span><br><span class="line">&#123;</span><br><span class="line">    private Adaptee adaptee = null;</span><br><span class="line"></span><br><span class="line">    public ObjectAdapter(Adaptee adaptee)</span><br><span class="line">    &#123;</span><br><span class="line">        this.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Request()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;目标对象&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SpecificRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        adaptee.SpecificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Client</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;========类适配器=========&quot;);</span><br><span class="line">        ClassAdapter classAdapter = new ClassAdapter();</span><br><span class="line">        classAdapter.Request();</span><br><span class="line">        classAdapter.SpecificRequest();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(&quot;========对象适配器=========&quot;);</span><br><span class="line">        Adaptee adaptee=new Adaptee();</span><br><span class="line">        ObjectAdapter objectAdapter=new ObjectAdapter(adaptee);</span><br><span class="line"></span><br><span class="line">        objectAdapter.Request();</span><br><span class="line">        objectAdapter.SpecificRequest();</span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>各类第三方接口</p><h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul><li>Bridge 模式的结构与对象适配器类似，但是 Bridge 模式的出发点不同：Bridge 目的是将接口部分和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。而 Adapter 则意味着改变一个已有对象的接口。</li><li>Decorator 模式增强了其他对象的功能而同时又不改变它的接口。因此 decorator 对应用程序的透明性比适配器要好。结果是 decorator 支持递归组合，而纯粹使用适配器是不可能实现这一点的。</li><li>Proxy 模式不改变它的接口的条件下，为另一个对象定义了一个代理。</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 01.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue笔记</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/03.%E5%89%8D%E7%AB%AF/Vue%E7%AC%94%E8%AE%B0/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/03.%E5%89%8D%E7%AB%AF/Vue%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><ul><li>vue</li><li>vue-cli</li><li>vue-devtools</li></ul><h2 id="2-Vue实例生命周期"><a href="#2-Vue实例生命周期" class="headerlink" title="2.Vue实例生命周期"></a>2.Vue实例生命周期</h2><p><img src="/images/posts/vue-lifecycle.png" alt="Vue实例声明周期"></p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 03.前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-05.SINGLETON（单件）— 对象创建型模式</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-05%E5%8D%95%E4%BE%8B/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-05%E5%8D%95%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>无</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。这就是 Singleton 模式。<br><a id="more"></a></p><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/单例1.jpg" alt="图一"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul><li>Singleton<ul><li>定义一个 Instance 操作，允许客户访问它的唯一实例。 Instance 是一个类操作。</li><li>可能负责创建它自己的唯一实例。</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>客户只能通过 Singleton 的 Instance 操作访问一个 Singleton 的实例。</p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul><li>对唯一实例的受控访问</li><li>缩小名空间</li><li>允许对操作和表示的精化</li><li>允许可变数目的实例</li><li>比类操作更灵活</li></ul><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul><li>保证一个唯一的实例</li><li>创建 Singleton 类的子类</li></ul><h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul><li><strong>第一种</strong>：线程不安全，不建议使用</li></ul><p><em>建议</em>：使用sealed关键字标识类不可继承，单例模式的类不应该继承，否则每个子类都可创建实例，违反唯一实例原则。<br><em>备注</em>：只适用于单线程，多线程由于未加锁，导致各个线程都会创建一个实例，违反单例模式的基本原则。<br>As hinted at before, the above is not thread-safe. Two different threads could both have evaluated the test if (instance==null) and found it to be true, then both create instances, which violates the singleton pattern.<br>Note that in fact the instance may already have been created before the expression is evaluated, but the memory model doesn’t guarantee that the new value of instance will be seen by other threads unless suitable memory barriers have been passed.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Sington1</span><br><span class="line">&#123;</span><br><span class="line">    private static Sington1 instance = null;</span><br><span class="line"></span><br><span class="line">    private Sington1()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sington1 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (instance == null)</span><br><span class="line">                instance = new Sington1();</span><br><span class="line"></span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>第二种</strong>：简单版线程安全</li></ul><p><em>备注</em>：该版本代码对于每个线程都会对线程辅助对象locker加锁之后再判断实例是否存在，对于这个操作完全没有必要的，因为当第一个线程创建了该类的实例之后，后面的线程此时只需要直接判断（uniqueInstance==null）为假，此时完全没必要对线程辅助对象加锁之后再去判断，所以上面的实现方式增加了额外的开销，损失了性能。<br>This implementation is thread-safe. The thread takes out a lock on a shared object, and then checks whether or not the instance has been created before creating the instance. This takes care of the memory barrier issue (as locking makes sure that all reads occur logically after the lock acquire, and unlocking makes sure that all writes occur logically before the lock release) and ensures that only one thread will create an instance (as only one thread can be in that part of the code at a time - by the time the second thread enters it,the first thread will have created the instance, so the expression will evaluate to false). Unfortunately, performance suffers as a lock is acquired every<br>time the instance is requested.<br>Note that instead of locking on typeof(Singleton) as some versions of this implementation do, I lock on the value of a static variable which is private to the class. Locking on objects which other classes can access and lock on(such as the type) risks performance issues and even deadlocks.This is a general style preference of mine - wherever possible,only lock on objects specifically created for the purpose of locking, or which document that they are to be locked on for specific purposes (e.g. for waiting/pulsing a queue). Usually such objects should be private to the class they are used in. This helps to make writing thread-safe applications significantly easier.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Sington2</span><br><span class="line">&#123;</span><br><span class="line">    private static Sington2 instance = null;</span><br><span class="line">    // 定义一个标识确保线程同步</span><br><span class="line">    private static readonly object lockObj = null;</span><br><span class="line"></span><br><span class="line">    private Sington2()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sington2 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            // 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span><br><span class="line">            // 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span><br><span class="line">            // lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span><br><span class="line">            lock (lockObj)</span><br><span class="line">            &#123;</span><br><span class="line">                if (instance == null)</span><br><span class="line">                    instance = new Sington2();</span><br><span class="line"></span><br><span class="line">                return instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>第三种：线程安全、双重锁定</strong></li></ul><p><em>备注</em>：该版本代码为了改进上面实现方式的缺陷，我们只需要在lock语句前面加一句判断就可以避免锁所增加的额外开销，这种实现方式我们就叫它 “双重锁定”。<br>This implementation attempts to be thread-safe without the necessity of taking out a lock every time. Unfortunately, there are four downsides to the pattern:<br>1.It doesn’t work in Java. This may seem an odd thing to comment on, but it’s worth knowing if you ever need the singleton pattern in Java, and c# programmers may well also be Java programmers. The Java memory model doesn’t ensure that the constructor completes before the reference to the new object is assigned to instance. The Java memory model underwent a reworking for version 1.5, but double-check locking is still broken after this without a volatile variable (as in c#).<br>2.Without any memory barriers, it’s broken in the ECMA CLI specification too. It’s possible that under the.NET 2.0 memory model(which is stronger than the ECMA spec) it’s safe, but I’d rather not rely on those stronger semantics, especially if there’s any doubt as to the safety. Making the instance variable volatile can make it work, as would explicit memory barrier calls, although in the latter case even experts can’t agree exactly which barriers are required.I tend to try to avoid situations where experts don’t agree what’s right and what’s wrong!<br>3.It’s easy to get wrong. The pattern needs to be pretty much exactly as above - any significant changes are likely to impact either performance or correctness.<br>4.It still doesn’t perform as well as the later implementations.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Sington3</span><br><span class="line">&#123;</span><br><span class="line">    private static Sington3 instance = null;</span><br><span class="line">    // 定义一个标识确保线程同步</span><br><span class="line">    private static readonly object lockObj = null;</span><br><span class="line"></span><br><span class="line">    private Sington3()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sington3 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            // 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span><br><span class="line">            // 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span><br><span class="line">            // lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span><br><span class="line">            // 双重锁定只需要一句判断就可以了</span><br><span class="line">            if (instance == null)</span><br><span class="line">            &#123;</span><br><span class="line">                lock (lockObj)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (instance == null)</span><br><span class="line">                        instance = new Sington3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>第四种：线程安全、不使用锁、静态初始化</strong></li></ul><p><em>备注</em>：静态初始化的方式是在自己的字段被引用时才会实例化,添加了静态构造函数当静态字段被引用时才进行初始化，因此即便很多线程试图引用_instance，<br>也需要等静态构造函数执行完并把静态成员_instance实例化之后可以使用。<br>As you can see, this is really is extremely simple - but why is it thread-safe and how lazy is it? Well, static constructors in c# are specified to execute only when an instance of the class is created or a static member is referenced, and to execute only once per AppDomain. Given that this check for the type being newly constructed needs to be executed whatever else happens, it will be faster than adding extra checking as in the previous examples. There are a couple of wrinkles, however:<br>1.It’s not as lazy as the other implementations. In particular, if you have static members other than Instance, the first reference to those members will involve creating the instance. This is corrected in the next implementation.<br>2.There are complications if one static constructor invokes another which invokes the first again.Look in the.NET specifications (currently section 9.5.3 of partition II) for more details about the exact nature of type initializers - they’re unlikely to bite you, but it’s worth being aware of the consequences of static constructors which refer to each other in a cycle.<br>3.The laziness of type initializers is only guaranteed by.NET when the type isn’t marked with a special flag called beforefieldinit. Unfortunately, the c# compiler (as provided in the .NET 1.1 runtime, at least) marks all types which don’t have a static constructor(i.e.a block which looks like a constructor but is marked static) as beforefieldinit.I now have an article with more details about this issue.Also note that it affects performance, as discussed near the bottom of the page.<br>One shortcut you can take with this implementation (and only this one) is to just make instance a public static readonly variable, and get rid of the property entirely.This makes the basic skeleton code absolutely tiny!Many people, however, prefer to have a property in case further action is needed in future, and JIT inlining is likely to make the performance identical. (Note that the static constructor itself is still required if you require laziness.)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Sington4</span><br><span class="line">&#123;</span><br><span class="line">    private static Sington4 instance = null;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 添加一个静态构造函数，用于屏蔽IL将变量属性自动标记beforefieldinit。</span><br><span class="line">    /// Explicit static constructor to tell c# compiler not to mark type as beforefieldinit</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    static Sington4()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Sington4()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sington4 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (instance == null)</span><br><span class="line">                instance = new Sington4();</span><br><span class="line"></span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>第五种：线程安全、延迟初始化</strong></li></ul><p><em>备注</em>：把初始化工作放到Nested类中的一个静态成员来完成，这样就实现了延迟初始化。<br>Here, instantiation is triggered by the first reference to the static member of the nested class, which only occurs in Instance. This means the implementation is fully lazy, but has all the performance benefits of the previous ones. Note that although nested classes have access to the enclosing class’s private members, the reverse is not true, hence the need for instance to be internal here. That doesn’t raise any other problems, though, as the class itself is private. The code is a bit more complicated in order to make the instantiation lazy, however.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Sington5</span><br><span class="line">&#123;</span><br><span class="line">    private Sington5()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sington5 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return SingtonNested.instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    internal class SingtonNested</span><br><span class="line">    &#123;</span><br><span class="line">        internal static Sington5 instance = new Sington5();</span><br><span class="line"></span><br><span class="line">        // Explicit static constructor to tell c# compiler not to mark type as beforefieldinit</span><br><span class="line">        static SingtonNested()</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>第六种：using .NET 4’s Lazy<t> type</t></strong></li></ul><p>备注：简单和性能良好，而且还提供检查是否已经创建实例的属性IsValueCreated。<br>If you’re using .NET 4 (or higher), you can use the System.Lazy<t> type to make the laziness really simple. All you need to do is pass a delegate to the constructor which calls the Singleton constructor - which is done most easily with a lambda expression.It’s simple and performs well. It also allows you to check whether or not the instance has been created yet with the IsValueCreated property, if you need that.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Sington6</span><br><span class="line">&#123;</span><br><span class="line">    private static readonly Lazy&lt;Sington6&gt; lazy = new Lazy&lt;Sington6&gt;(() =&gt; new Sington6(), true);</span><br><span class="line"></span><br><span class="line">    private Sington6()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sington6 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return lazy.Value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><ul><li><strong>总结</strong><blockquote><p>There are various different ways of implementing the singleton pattern in C#. A reader has written to me detailing a way he has encapsulated the synchronization aspect, which while I acknowledge may be useful in a few very particular situations (specifically where you want very high performance, and the ability to determine whether or not the singleton has been created, and full laziness regardless of other static members being called). I don’t personally see that situation coming up often enough to merit going further with on this page, but please mail me if you’re in that situation.</p><p><strong>My personal preference is for solution 4</strong>: the only time I would normally go away from it is if I needed to be able to call other static methods without triggering initialization, or if I needed to know whether or not the singleton has already been instantiated. I don’t remember the last time I was in that situation, assuming I even have. In that case, I’d probably go for solution 2, which is still nice and easy to get right.</p><p>Solution 5 is elegant, but trickier than 2 or 4, and as I said above, the benefits it provides seem to only be rarely useful. <strong>Solution 6 is a simpler way to achieve laziness, if you’re using .NET 4.</strong> It also has the advantage that it’s obviously lazy. I currently tend to still use solution 4, simply through habit - but if I were working with inexperienced developers I’d quite possibly go for solution 6 to start with as an easy and universally applicable pattern.</p><p><strong>(I wouldn’t use solution 1 because it’s broken, and I wouldn’t use solution 3 because it has no benefits over 5.)</strong></p><footer><strong>Jon Skeet,C# In Depth</strong><cite><a href="http://csharpindepth.com/Articles/General/Singleton.aspx" target="_blank" rel="noopener">Implementing the Singleton Pattern in C#</a></cite></footer></blockquote></li></ul><h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><ul><li>日志</li></ul><h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><p>很多模式可以使用 Singleton 模式实现。参见 AbstractFactory、Builder，和Prototype。</p>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 01.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-04.PROTOTYPE（原型）— 对象创建型模式</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-04%E5%8E%9F%E5%9E%8B/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-04%E5%8E%9F%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>无</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p><img src="/images/posts/原型1.jpg" alt="图一"><br><a id="more"></a></p><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul><li>当要实例化的类是在运行时刻指定时，例如，通过动态装载；</li><li>为了避免创建一个与产品类层次平行的工厂类层次时；</li><li>当一个类的实例只能有几个不同状态组合中的一种时，建立相应数目的原型并克隆它们<br>可能比每次用合适的状态手工实例化该类更方便一些。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/原型2.jpg" alt="图二"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul><li>Prototype（Graphic）<ul><li>声明一个克隆自身的接口。</li></ul></li><li>ConcretePrototype（Staff、WholeNote、HalfNote）<ul><li>实现一个克隆自身的操作。</li></ul></li><li>Client（GraphicTool）<ul><li>让一个原型克隆自身从而创建一个新的对象。</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>客户请求一个原型克隆自身。</p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><p>Prototype有许多和AbstractFactory和Builder一样的效果：它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。此外，这些模式使客户无需改变即可使用与特定应用相关的类。</p><ul><li>运行时刻增加和删除产品</li><li>改变值以指定新对象</li><li>改变结构以指定新对象</li><li>减少子类的构造</li><li>用类动态配置应用</li></ul><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul><li>使用一个原型管理器</li><li>实现克隆操作</li><li>初始化克隆对象</li></ul><h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul><li><p>Prototype</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IPrototype</span><br><span class="line">&#123;</span><br><span class="line">    IPrototype Clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ConcretePrototype（Staff、WholeNote、HalfNote）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ConcretePrototype : IPrototype</span><br><span class="line">&#123;</span><br><span class="line">    public IPrototype Clone()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;ConcretePrototype&quot;);</span><br><span class="line"></span><br><span class="line">        return this.MemberwiseClone() as IPrototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client（GraphicTool）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Client</span><br><span class="line">&#123;</span><br><span class="line">    IPrototype prototype=new ConcretePrototype();</span><br><span class="line">    IPrototype clonePrototype=prototype.Clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>ICloneable.Clone</p><h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul><li>Prototype 和 AbstractFactory 模式在某种方面是相互竞争的。但是它们也可以一起使用。AbstractFactory 可以存储一个被克隆的原型的集合，并且返回产品对象。</li><li>大量使用 Composite 和 Decorator 模式的设计通常也可从 Prototype 模式处获益。</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 01.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-03.FACTORY METHOD（工厂方法）— 对象创建型模式</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-03%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-03%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method 使一个类的实例化延迟到其子类。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>虚构造器（Virtual Constructor）</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>框架使用抽象类定义和维护对象之间的关系。这些对象的创建通常也由框架负责。<br><img src="/images/posts/工厂方法1.jpg" alt="图一"></p><a id="more"></a><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul><li>当一个类不知道它所必须创建的对象的类的时候。</li><li>当一个类希望由它的子类来指定它所创建的对象的时候。</li><li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/工厂方法2.jpg" alt="图二"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul><li>Product(Document)：<ul><li>定义工厂方法所创建的对象的接口。</li></ul></li><li>ConcreteProduct（MyDocument）<ul><li>实现 Product 接口。</li></ul></li><li>Creator（Application）<ul><li>声明工厂方法，该方法返回一个 Product 类型的对象。Creator 也可以定义一个工厂方法的缺省实现，它返回一个缺省的 ConcreteProduct 对象。</li><li>可以调用工厂方法以创建一个 Product 对象。</li></ul></li><li>ConcreteCreator（MyApplication）<ul><li>重定义工厂方法以返回一个 ConcreteProduct 实例。</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>Creator依赖于它的子类来定义工厂方法，所以它返回一个适当的ConcreteProduct实例。</p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><p>工厂方法不再将与特定应用有关的类绑定到你的代码中。代码仅处理 Product 接口；因此它可以与用户定义的任何 ConcreteProduct 类一起使用。<br>工厂方法的一个潜在缺点在于客户可能仅仅为了创建一个特定的 ConcreteProduct 对象，就不得不创建 Creator 的子类。当 Creator 子类不必需时，客户现在必然要处理类演化的其他方面；但是当客户无论如何必须创建 Creator 的子类时，创建子类也是可行的。</p><ul><li>为子类提供挂钩（hook）：用工厂方法在一个类的内部创建对象通常比直接创建对象更灵活。Factory Method 给子类一个挂钩以提供对象的扩展版本。</li><li>连接平行的类层次：当一个类将它的一些职责委托给一个独立的类的时候，就产生了平行类层次。<br><img src="/images/posts/工厂方法3.jpg" alt="图三"></li></ul><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul><li>主要有两种不同的情况<ul><li>1 第一种情况：Creator类是一个抽象类并且不提供它所声明的工厂方法的实现。需要子类来定义实现，因为没有合理的缺省实现。它避免了不得不实例化不<br>可预见类的问题。</li><li>2 第二种情况：Creator是一个具体的类而且为工厂方法提供一个缺省的实现。也有可能有一个定义了缺省实现的抽象类，但这不太常见。具体的Creator主要因为灵活性才使用工厂方法。它所遵循的准则是，“用一个独立的操作创建对象，这样子类才能重定义它们的创建方式。”这条准则保证了子类的设计者能够在必要的时候改变父类所实例化的对象的类。</li></ul></li><li>参数化工厂方法<ul><li>该模式的另一种情况使得工厂方法可以创建多种产品。工厂方法采用一个标识要被创建的对象种类的参数。工厂方法创建的所有对象将共享Product接口。在Document的例子中，Application可能支持不同种类的Document。你给CreateDocument传递一个外部参数来指定将要创建的文档的种类。</li></ul></li><li>特定语言的变化和问题</li><li>使用模板以避免创建子类</li><li>命名约定</li></ul><h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul><li><p>Product</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class IProduct</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ConcreteProduct</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ConcreteProduct : IProduct</span><br><span class="line">&#123;</span><br><span class="line">   public ConcreteProduct()</span><br><span class="line">   &#123;</span><br><span class="line">      Console.WriteLine(&quot;具体产品&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Creator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">abstract class Creator</span><br><span class="line">&#123;</span><br><span class="line">    public abstract IProduct FactoryMethod();</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 工厂方法的缺省实现</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    public IProduct Create()</span><br><span class="line">    &#123;</span><br><span class="line">        return this.FactoryMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ConcreteCreator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ConcreteCreator : Creator</span><br><span class="line">&#123;</span><br><span class="line">    public override IProduct FactoryMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        IProduct product = new ConcreteProduct();</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Creator creator = new ConcreteCreator();</span><br><span class="line">        creator.Create();</span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>工厂方法主要用于工具包和框架中。</p><h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul><li>AbstractFactory：经常用工厂方法来实现。AbstractFactory 模式中动机一节的例子也对FactoryMethod进行了说明。工厂方法通常在TemplateMethods（5.10）中被调用。在上面的文档例子中，NewDocument就是一个模板方法。</li><li>Prototypes：不需要创建Creator的子类。但是，它们通常要求一个针对Product类的Initialize操作。Creator使用Initialize来初始化对象。而FactoryMethod不需要这样的操作。</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 01.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP笔记</title>
      <link href="//posts/04.%E7%BD%91%E7%BB%9C/01.HTTP/01.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>//posts/04.%E7%BD%91%E7%BB%9C/01.HTTP/01.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p><img src="/images/posts/HTTP1.png" alt="图一"></p><h2 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1.应用层"></a>1.应用层</h2><p>决定向用户提供应用服务时通信的活动。<br>TCP/IP协议簇内预存了各类通用的应用服务，如FTP文件传输协议，DNS域名系统服务。HTTP协议也在该层。</p><h2 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2.传输层"></a>2.传输层</h2><p>对上层应用层提供处于网络连接中两台计算机间的数据传输。<br>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。</p><h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h2><p>处理在网络上流动的数据包（网络传输的最小数据单位），该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。</p><a id="more"></a><h2 id="4-链路层"><a href="#4-链路层" class="headerlink" title="4.链路层"></a>4.链路层</h2><p>用来处理连接网络的硬件部分，包括控制操作系统，硬件设备驱动,网络适配器（网卡）及光纤等物理可见部分。</p><h2 id="5-IP协议"><a href="#5-IP协议" class="headerlink" title="5.IP协议"></a>5.IP协议</h2><p>IP（Internet Protocol）网际协议位于网络层。TCP/IP协议簇中的IP指的就是网际协议。<br>作用是把各种数据包发送给对方，而要确保发送正确需满足各类条件，其中两个重要的就是IP地址和MAC（Media Access Control Address）地址。<br>IP地址指明节点被分配的地址，MAC地址指网卡的固定地址，可配对。IP地址可变换而MAC地址基本不变。</p><h2 id="6-ARP协议"><a href="#6-ARP协议" class="headerlink" title="6.ARP协议"></a>6.ARP协议</h2><p>ARP（Address Resolution Protocol）协议是一种用以解析地址的协议，根据通信方的IP地址反查出对应的MAC地址。</p><h2 id="7-TCP协议"><a href="#7-TCP协议" class="headerlink" title="7.TCP协议"></a>7.TCP协议</h2><p>TCP协议位于传输层，提供可靠的字节流服务。采用三次握手（three-way handshaking）策略：发送端先发送带SYN（synchronize）标志的数据包给对方，接收端接受到后回传一个带SYN/ACK（acknowledgement）标志的数据包确认，最后，发送端回传ACK标志的数据包，表示握手结束。</p><h2 id="8-DNS服务"><a href="#8-DNS服务" class="headerlink" title="8.DNS服务"></a>8.DNS服务</h2><p>DNS（Domain Name System）服务用于域名到IP地址之间解析，位于应用层。<br><img src="/images/posts/HTTP2.png" alt="图二"></p><h2 id="9-URI（Uniform-Resource-Identifier）统一资源标识符"><a href="#9-URI（Uniform-Resource-Identifier）统一资源标识符" class="headerlink" title="9.URI（Uniform Resource Identifier）统一资源标识符"></a>9.URI（Uniform Resource Identifier）统一资源标识符</h2><p>由某个协议方案表示的资源的定位标识符。</p><h3 id="9-1Uniform"><a href="#9-1Uniform" class="headerlink" title="9.1Uniform"></a>9.1Uniform</h3><p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。</p><h3 id="9-2Resource"><a href="#9-2Resource" class="headerlink" title="9.2Resource"></a>9.2Resource</h3><p> 资源的定义是可标识的任何东西。</p><h3 id="9-3Identifier"><a href="#9-3Identifier" class="headerlink" title="9.3Identifier"></a>9.3Identifier</h3><p>表示可标识的对象，即标识符。</p><h2 id="10-URL（Uniform-Resource-Locator）统一资源定位符"><a href="#10-URL（Uniform-Resource-Locator）统一资源定位符" class="headerlink" title="10.URL（Uniform Resource Locator）统一资源定位符"></a>10.URL（Uniform Resource Locator）统一资源定位符</h2><p>资源的地点，是URI的子集。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 图解HTTP（第1章：基础知识）</p>]]></content>
      
      <categories>
          
          <category> 04.网络 </category>
          
          <category> 01.HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker基础知识</title>
      <link href="//posts/03.%E5%B7%A5%E5%85%B7/02.Docker/Docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>//posts/03.%E5%B7%A5%E5%85%B7/02.Docker/Docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）</li></ul>]]></content>
      
      <categories>
          
          <category> 03.工具 </category>
          
          <category> 02.Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VS</title>
      <link href="//posts/03.%E5%B7%A5%E5%85%B7/VS/"/>
      <url>//posts/03.%E5%B7%A5%E5%85%B7/VS/</url>
      <content type="html"><![CDATA[<h2 id="1-设置类库程序集自动更新版本号"><a href="#1-设置类库程序集自动更新版本号" class="headerlink" title="1.设置类库程序集自动更新版本号"></a>1.设置类库程序集自动更新版本号</h2><p>修改AssemblyInfo文件</p><ul><li>更改[assembly: AssemblyVersion(“1.0.*”)]</li><li>注释[assembly: AssemblyFileVersion(“1.0.0”)]</li></ul>]]></content>
      
      <categories>
          
          <category> 03.工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> VS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis笔记</title>
      <link href="//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/04.Redis/Redis/"/>
      <url>//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/04.Redis/Redis/</url>
      <content type="html"><![CDATA[<h2 id="1-键值对"><a href="#1-键值对" class="headerlink" title="1 键值对"></a>1 键值对</h2><ul><li>SET TESTKEY “TESTVALUE”,设置键值对TESTKEY-“TESTVALUE”，返回OK；</li><li>GET TESTKEY,获取键TESTKEY的值（获取不存在的键的值返回nil，即空）；</li><li>DEL TESTKEY,删除键为TESTKEY的键值对，成功返回1；</li><li>EXISTS TESTKEY,键是否存在，0否1是</li><li>TYPE TESTKEY,返回键的类型，如string、list等，若键不存在返回None;</li><li>INCR TESTKEY,自动加一，成功返回结果（若TESTKEY不是int值，则报错）<br>  <code>注意：INCR命令是原子操作（即不会被线程调度机制打断的操作）</code>;</li><li>SETNX TEST1 ‘TESTVALUE’，若键不存在则设置，若键存在则不设置，成功返回1，失败返回0；</li><li>EXPIRE TESTKEY 120,设置键TESTKEY有效期120秒（等同于 SET TESTKEY ‘TESTVALUE’ EX 120）；</li><li>PERSIST TESTKEY,取消TESTKEY的有效期，1成功0失败</li><li>TTL TESTKEY,查看键TESTKEY剩余有效期,-2表示键已过期不存在，-1表示永不过期，若重下SET TESTKEY，则状态重置为-1;</li></ul><a id="more"></a><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h2><h3 id="2-1-列表（list）有序、可重复"><a href="#2-1-列表（list）有序、可重复" class="headerlink" title="2.1 列表（list）有序、可重复"></a>2.1 列表（list）有序、可重复</h3><ul><li>RPUSH TESTLIST “ITEM1” “ITEM2” “ITEM3” … “ITEMN”,插入多项到列表尾部，返回列表子项个数；</li><li>LPUSH TESTLIST “ITEM2”,插入一项到列表头部，返回列表子项个数；</li><li>LRANGE TESTLIST 0 -1,列出列表子项，参数1表示从第0个开始，参数2表示到第N个（-1表示最后）；</li><li>LLEN TESTLIST,获取列表子项个数；</li><li>LPOP TESTLIST,移除列表头部项，返回项的值；</li><li>RPOP TESTLIST,移除列表尾部项，返回项的值；</li><li>工具命令BRPOP TESTLIST 0、BLPOP，阻塞版本的取元素，若LIST为空，仅在规定时间（0代表永久）内有新元素加入时候取出，而不是返回NULL；<ul><li>客户端按顺序执行，第一个取得先等其他客户端加入元素，以此类推；</li><li>与RPOP相比，返回值是不同的：它是一个两元素数组，因为它也包括键的名称，因为BRPOP和BLPOP能够阻止等待来自多个列表的元素。</li><li>如果超时，则返回NULL。</li><li>RPOPLPUSH更适合命令创建安全的队列，BRPOPLPUSH阻塞版本</li></ul></li><li>LTRIM TESTLIST 0 2，只保留前3项，丢弃之后的元素；</li></ul><h3 id="2-2-集合（set）无序、不可重复"><a href="#2-2-集合（set）无序、不可重复" class="headerlink" title="2.2 集合（set）无序、不可重复"></a>2.2 集合（set）无序、不可重复</h3><ul><li>SADD TESTSET “ITEM1” “ITEM2” “ITEM3” … “ITEMN”,插入一项到集合中，返回1表示成功，若已有该项则返回0；</li><li>SREM TESTSET “ITEM1”,从集合中移除指定项，返回1表示成功，若无该项则返回0；</li><li>SISMEMBER TESTSET “ITEM1”，验证指定项是否在集合中，0否1是；</li><li>SMEMBERS TESTSET，列出集合项</li><li>SUNION TESTSET1 TEST2 … TESTN,取多个集合并集（无序无重复项）；</li><li>SINTER TESTSET1 TEST2 … TESTN,取多个集合交集</li><li>SUNIONSTORE TESTSETALL TESTSET1 TESTSET2 …TESTSETN,将多个集合并集保存至TESTSETALL</li><li>SCARD TESETSET1，获取集合元素个数</li><li>SPOP TESTSET1，随机取一个集合元素，移除集合</li><li>SRANDMEMBER TESTSET1，随机取一个集合元素，不移除集合</li></ul><h3 id="2-3-有序集合（sorted-set）有序、不可重复"><a href="#2-3-有序集合（sorted-set）有序、不可重复" class="headerlink" title="2.3 有序集合（sorted set）有序、不可重复"></a>2.3 有序集合（sorted set）有序、不可重复</h3><ul><li>ZADD TESTSORTSET 3 “C”,3为关联值，用于排序，float；</li><li>ZRANGE TESTSORTLIST 0 -1 [withscores],列出有序集合子项，参数1表示从第0个开始，参数2表示到第N个（-1表示最后）,[withscores]可选，是否列出score项；</li><li>ZREVRANGE TESTSORTLIST 0，-1,反向列出有序集合元素；</li><li>ZRANK TESTSORTLIST ‘C’,查找指定元素的位置；</li><li>ZREVRANK TESTSORTLIST ‘C’,反向查找指定元素的位置；</li></ul><h3 id="2-4-哈希（Hashes）用于保存对象"><a href="#2-4-哈希（Hashes）用于保存对象" class="headerlink" title="2.4 哈希（Hashes）用于保存对象"></a>2.4 哈希（Hashes）用于保存对象</h3><ul><li>HSET obj name ‘venux’;HSET obj age ‘27’;HSET obj email <a href="mailto:&#39;337225164@qq.com" target="_blank" rel="noopener">&#39;337225164@qq.com</a>‘,保存一个obj对象，单个属性存放用户名、年龄、email。</li><li>HMSET obj name ‘venux’ age ‘27’ email <a href="mailto:&#39;337225164@qq.com" target="_blank" rel="noopener">&#39;337225164@qq.com</a>‘,保存一个obj对象，多个属性存放用户名、年龄、email。</li><li>HGETALL obj,获取obj对象</li><li>HGET obj name,获取obj对象的name属性</li><li>HINCRBY obj age 10,给obj对象的age属性加10，Hash字段中数值类型使用同等的字符串表示，并能通过<code>HINCRBY</code>（原子操作）累加</li></ul><h2 id="3-Redis支持的数据结构"><a href="#3-Redis支持的数据结构" class="headerlink" title="3 Redis支持的数据结构"></a>3 Redis支持的数据结构</h2><ol><li>Binary-safe strings；</li><li>Lists:按插入顺序排序的列表，基于链表；</li><li>Sets:无序、唯一的集合；</li><li>Sorted sets:有序、唯一的有序集合，用一个称为scroe的float字段存放排序值；</li><li>Hashes:一系列属性合集，即对象，字段名和值都为strings；</li><li>Bit arrays (or simply bitmaps):二进制数组；</li><li>HyperLogLogs:this is a probabilistic data structure which is used in order to estimate the cardinality of a set（概率性数据结构，用于评估集合的基数）.</li></ol><h2 id="4-Redis-keys"><a href="#4-Redis-keys" class="headerlink" title="4 Redis keys"></a>4 Redis keys</h2><ul><li>空字符串也是有效的key值；</li><li>太长的key不好，若key代表的对象本身过长，使用hash（如SHA1）后的值作为key值；</li><li>太短的key值也不好，如使用user:1000:followers替代u1000flw，这样可读性更良好；</li><li>尽量（坚持）使用模式，一个良好的模式<code>object-type:id</code>，通常使用<code>:</code>、<code>-</code>、<code>.</code>分割。例如<code>user:1000</code>、<code>comment:1234:reply.to</code>、<code>comment:1234:reply-to</code>；</li><li>键最大容量为512MB。</li></ul><h2 id="5-Redis-Strings"><a href="#5-Redis-Strings" class="headerlink" title="5 Redis Strings"></a>5 Redis Strings</h2><ul><li>键值都为string类型，和<code>Memcached</code>一样，string作为唯一的数据类型；</li><li>值也可用于保存图片资源，只要格式本质是string（如二进制），且大小不能超出512M；</li><li>SET命令选项：SET TESTKEY “TESTVALUE” nx/xx,nx代表如果键已存在，则SET失败；反之xx表示，如果键已存在则成功；</li><li>INCR TESTKEY：将string作为int值累加一并保存新值，DECR减； INCRBY TESTKEY 10：加10，DECRBY减； （其实是同一个底层命令不同表示方式）；</li><li>GETSET：先获取旧值后设置新值（有点儿像<code>i++</code>）；</li><li>MSET A 10 B 20 C 30;MGET A B C;MSET或MGET（返回一个Array）同时操作多个键值对ABC；</li></ul><h2 id="6-Redis-expires（有效期）"><a href="#6-Redis-expires（有效期）" class="headerlink" title="6 Redis expires（有效期）"></a>6 Redis expires（有效期）</h2><ol><li>精度可以说秒或毫秒；</li><li>本质上精度都是毫秒；</li><li>当Redis server停止时，过期的数据也会保存到磁盘中，Redis只是给key加了个有效期的属性；</li></ol><h2 id="7-Redis-Lists"><a href="#7-Redis-Lists" class="headerlink" title="7 Redis Lists"></a>7 Redis Lists</h2><h3 id="7-1-注意区分链表（Linked-Lists）和数组（Array）。"><a href="#7-1-注意区分链表（Linked-Lists）和数组（Array）。" class="headerlink" title="7.1 注意区分链表（Linked Lists）和数组（Array）。"></a>7.1 注意区分链表（Linked Lists）和数组（Array）。</h3><ul><li>Redis Lists本质是链表，在存储上不连续，优点插入时间复杂度为常量即O(1)，缺点索引查找O(n)。</li><li>数组指一系列元素的集合，在存储上是连续的，优点索引查找时间复杂度为常量即O(1)，缺点插入O(n)。</li></ul><h3 id="7-2-适用场景"><a href="#7-2-适用场景" class="headerlink" title="7.2 适用场景"></a>7.2 适用场景</h3><ol><li>记录社交网络最后一个提交更新；</li><li>消息队列等；</li></ol><h2 id="8-Bitmaps（位图不是一个确切的数据类型）"><a href="#8-Bitmaps（位图不是一个确切的数据类型）" class="headerlink" title="8 Bitmaps（位图不是一个确切的数据类型）"></a>8 Bitmaps（位图不是一个确切的数据类型）</h2><ol><li>SETBIT BITKEY 10 1，设置BITKEY键的值的第10位为1；</li><li>GETBIT BITKEY 10，获取BITKEY键的值的第10位；</li></ol><h3 id="8-1-适用场景"><a href="#8-1-适用场景" class="headerlink" title="8.1 适用场景"></a>8.1 适用场景</h3><ol><li>任何实时分析情况；</li><li>高效高性能存储boolean信息，通过各位0或1直接判断各种状态；</li></ol><h2 id="9-HyperLogLogs-估算各类分布概率"><a href="#9-HyperLogLogs-估算各类分布概率" class="headerlink" title="9 HyperLogLogs(估算各类分布概率)"></a>9 HyperLogLogs(估算各类分布概率)</h2><ol><li>PFADD HLLTEST a b c d；插入元素；</li><li>PFCOUNT HLLTEST；查询个数</li></ol><h3 id="9-1-适用场景"><a href="#9-1-适用场景" class="headerlink" title="9.1 适用场景"></a>9.1 适用场景</h3><ol><li>例如统计每天用户查询不同关键词的数目</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://try.redis.io/" target="_blank" rel="noopener">redis入门</a><br>2 <a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">介绍Redis数据结构和抽象</a></p>]]></content>
      
      <categories>
          
          <category> 02.数据库 </category>
          
          <category> 04.Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-02.BUILDER（生成器）— 对象创建型模式</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-02%E5%BB%BA%E9%80%A0%E8%80%85/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-02%E5%BB%BA%E9%80%A0%E8%80%85/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>无</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>一个RTF（Rich Text Format）文档交换格式的阅读器应能将 RTF 转换为多种正文格式。该阅读器可以将 RTF 文档转换成普通 ASCII 文本或转换成一个能以交互方式编辑的正文窗口组件。但问题在于可能转换的数目是无限的。因此要能够很容易实现新的转换的增加，同时却不改变 RTF 阅读器。<br><img src="/images/posts/建造者1.jpg" alt="图一"></p><a id="more"></a><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul><li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li><li>当构造过程必须允许被构造的对象有不同的表示时。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/建造者2.jpg" alt="图二"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul><li>Builder（TextConverter）<ul><li>为创建一个 Product 对象的各个部件指定抽象接口。</li></ul></li><li>ConcreteBuilder（ASCIIConverter、TeXConverter、TextWidgetConverter）<ul><li>实现Builder的接口以构造和装配该产品的各个部件；</li><li>定义并明确它所创建的表示；</li><li>提供一个检索产品的接口（例如，GetASCIIText和GetTextWidget）。</li></ul></li><li>Director（RTFReader）<ul><li>构造一个使用Builder接口的对象。</li></ul></li><li>Product（ASCIIText、TeXText、TextWidget）<ul><li>表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程；</li><li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><ul><li>客户创建 Director 对象，并用它所想要的 Builder 对象进行配置。</li><li>一旦产品部件被生成，导向器就会通知生成器。</li><li>生成器处理导向器的请求，并将部件添加到该产品中。</li><li>客户从生成器中检索产品。</li></ul><p>下面的交互图说明了Builder和Director是如何与一个客户协作的。<br><img src="/images/posts/建造者3.jpg" alt="图二"></p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul><li>它使你可以改变一个产品的内部表示</li><li>它将构造代码和表示代码分开</li><li>它使你可对构造过程进行更精细的控制 </li></ul><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul><li>装配和构造接口</li><li>为什么产品没有抽象类</li><li>在 Builder 中缺省的方法为空</li></ul><h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul><li><p>Builder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IBuilder</span><br><span class="line">&#123;</span><br><span class="line">    void BuildPart1();</span><br><span class="line">    void BuildPart2();</span><br><span class="line">    void BuildPart3();</span><br><span class="line"></span><br><span class="line">    Product GetProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ConcreteBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Product1Builder:IBuilder</span><br><span class="line">&#123;</span><br><span class="line">    public void BuildPart1()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Product1 Part1 Build Success!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void BuildPart2()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Product1 Part2 Build Success!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void BuildPart3()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Product1 Part3 Build Success!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Product GetProduct()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Product(&quot;Product1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Product2Builder:IBuilder</span><br><span class="line">&#123;</span><br><span class="line">    public void BuildPart1()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Product2 Part1 Build Success!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void BuildPart2()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Product2 Part2 Build Success!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void BuildPart3()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Product2 Part3 Build Success!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Product GetProduct()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Product(&quot;Product2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Director</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Director</span><br><span class="line">&#123;</span><br><span class="line">   Product CreateProduct(IBuilder builder)</span><br><span class="line">   &#123;</span><br><span class="line">        builder.BuildPart1();</span><br><span class="line">        builder.BuildPart2();</span><br><span class="line">        builder.BuildPart3();</span><br><span class="line"></span><br><span class="line">        return builder.GetProduct();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Product</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Product</span><br><span class="line">&#123;</span><br><span class="line">    public Product(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;产品名称：&#123;name&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        IBuilder builder=new Product1Builder();</span><br><span class="line"></span><br><span class="line">        Director director=new Director();</span><br><span class="line">        Product product=director.CreateProduct(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><ul><li>RTF转换器</li><li>ASP.NET CORE的MvcWebApplicationBuilder</li></ul><h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul><li>AbstractFactory 与 Builder 相似，因为它也可以创建复杂对象。主要的区别是 Builder 模式着重于一步步构造一个复杂对象。而AbstractFactory着重于多个系列的产品对象（简单的或是复杂的）。Builder 在最后的一步返回产品，而对于 AbstractFactory 来说，产品是立即返回的。</li><li>Composite 通常是用 Builder 生成的。</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 01.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-01.ABSTRACT FACTORY（抽象工厂）— 对象创建型模式</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</url>
      <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>Kit</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>考虑一个支持多种视感（look - and - feel）标准的用户界面工具包，例如 Motif 和 Presentation Manager。不同的视感风格为诸如滚动条、窗口和按钮等用户界面“窗口组件”定义不同的外观和行为。为保证视感风格标准间的可移植性，一个应用不应该为一个特定的视感外观硬编码它的窗口组件。在整个应用中实例化特定视感风格的窗口组件类将使得以后很难改变视感风格。<br><img src="/images/posts/抽象工厂1.jpg" alt="图一"></p><a id="more"></a><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul><li>一个系统要独立于它的产品的创建、组合和表示时。</li><li>一个系统要由多个产品系列中的一个来配置时。</li><li>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</li><li>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/抽象工厂2.jpg" alt="图二"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul><li>AbstractFactory（WidgetFactory）：声明一个创建抽象产品对象的操作接口。</li><li>ConcreteFactory（MotifWidgetFactory，PMWidgetFactory）：实现创建具体产品对象的操作。</li><li>AbstractProduct（Windows，ScrollBar）：—为一类产品对象声明一个接口。</li><li>ConcreteProduct（MotifWindow，MotifScrollBar）：定义一个将被相应的具体工厂创建的产品对象，实现AbstractProduct接口。</li><li>Client：仅使用由AbstractFactory和AbstractProduct类声明的接口</li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><ul><li>通常在运行时刻创建一个 ConcreteFactroy 类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。</li><li>AbstractFactory 将产品对象的创建延迟到它的 ConcreteFactory 子类。</li></ul><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul><li><strong>它分离了具体的类（利）</strong>AbstractFactory 模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，它将客户与类的实现分离。客户通过它们的抽象接口操纵实例。产品的类名也在具体工厂的实现中被分离；它们不出现在客户代码中。</li><li><strong>它使得易于交换产品系列（利）</strong>一个具体工厂类在一个应用中仅出现一次 — 即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。</li><li><strong>它有利于产品的一致性（利）</strong>当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而 AbstractFactory 很容易实现这一点。</li><li><strong>难以支持新种类的产品（弊）</strong>难以扩展抽象工厂以生产新种类的产品。这是因为AbstractFactory 接口确定了可以被创建的产品集合。支持新种类的产品就需要扩展该工厂接口，这将涉及 AbstractFactory 类及其所有子类的改变。</li></ul><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul><li><strong>将工厂作为单件</strong>一个应用中一般每个产品系列只需一个 ConcreteFactory 的实例。因此工厂通常最好实现为一个 Singleton。</li><li><strong>创建产品</strong>AbstractFactory 仅声明一个创建产品的接口，真正创建产品是由 ConcreteProduct 子类实现的。最通常的一个办法是为每一个产品定义一个工厂方法（FactoryMethod）。一个具体的工厂将为每个产品重定义该工厂方法以指定产品。虽然这样的实现很简单，但它却要求每个产品系列都要有一个新的具体工厂子类，即使这些产品系列的差别很小。如果有多个可能的产品系列，具体工厂也可以使用 Prototype 模式来实现。具体工厂使用产品系列中每一个产品的原型实例来初始化，且它通过复制它的原型来创建新的产品。在基于原型的方法中，使得不是每个新的产品系列都需要一个新的具体工厂类。<br>-<strong>定义可扩展的工厂</strong>AbstractFactory 通常为每一种它可以生产的产品定义一个操作。产品的种类被编码在操作型构中。增加一种新的产品要求改变 AbstractFactory 的接口以及所有与它相关的类。一个更灵活但不太安全的设计是给创建对象的操作增加一个参数。该参数指定了将被创建的对象的种类。它可以是一个类标识符、一个整数、一个字符串，或其他任何可以标识这种产品的东西。实际上使用这种方法，AbstractFactory 只需要一个 “Make” 操作和一个指示要创建对象的种类的参数。</li></ul><h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul><li><p>AbstractFactory（WidgetFactory）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface WidgetFactory</span><br><span class="line">&#123;</span><br><span class="line">    void CreateWindow();</span><br><span class="line">    void CreateScrollBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ConcreteFactory（MotifWidgetFactory，PMWidgetFactory）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MotifWidgetFactory:WidgetFactory</span><br><span class="line">&#123;</span><br><span class="line">    void CreateWindow()</span><br><span class="line">    &#123;</span><br><span class="line">        Window w=new MotifWindow();        </span><br><span class="line">    &#125;</span><br><span class="line">    void CreateScrollBar()</span><br><span class="line">    &#123;</span><br><span class="line">        ScrollBar sb=new MotifScrollBar();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PMWidgetFactory:WidgetFactory</span><br><span class="line">&#123;</span><br><span class="line">    void CreateWindow()</span><br><span class="line">    &#123;</span><br><span class="line">        Window w=new PMWindow();        </span><br><span class="line">    &#125;</span><br><span class="line">    void CreateScrollBar()</span><br><span class="line">    &#123;</span><br><span class="line">        ScrollBar sb=new PMScrollBar();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AbstractProduct（Windows，ScrollBar）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface Windows&#123;&#125;</span><br><span class="line">interface ScrollBar&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>ConcreteProduct（MotifWindow，PMWindow，MotifScrollBar，PMScrollBar）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class MotifWindow:Windows</span><br><span class="line">&#123;</span><br><span class="line">    public MotifWindow()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MotifWindow&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PMWindow:Windows</span><br><span class="line">&#123;</span><br><span class="line">    public PMWindow()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;PMWindow&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MotifScrollBar:ScrollBar</span><br><span class="line">&#123;</span><br><span class="line">    public MotifScrollBar()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MotifScrollBar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PMScrollBar:ScrollBar</span><br><span class="line">&#123;</span><br><span class="line">    public PMScrollBar()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;PMScrollBar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client：仅使用由AbstractFactory和AbstractProduct类声明的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Client</span><br><span class="line">&#123;</span><br><span class="line">    WidgetFactory factory=new MotifWidgetFactory();</span><br><span class="line">    factory.CreateWindow();</span><br><span class="line">    factory.CreateScrollBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>InterView 使用 “Kit” 后缀 [Lin92] 来表示 AbstractFactory 类。它定义 WidgetKit 和 DialogKit 抽象工厂来生成与特定视感风格相关的用户界面对象。InterView 还包括一个 LayoutKit，它根据所需要的布局生成不同的组成（composition）对象。</p><h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul><li>AbstractFactory 类通常用工厂方法（FactoryMethod）实现，但它们也可以用 Prototype 实现。</li><li>一个具体的工厂通常是一个单件（Singleton）。</li></ul>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 01.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象设计原则</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h2 id="1-针对接口编程，而不是针对实现编程。"><a href="#1-针对接口编程，而不是针对实现编程。" class="headerlink" title="1.针对接口编程，而不是针对实现编程。"></a>1.针对接口编程，而不是针对实现编程。</h2><h2 id="2-优先使用对象组合，而不是类继承。"><a href="#2-优先使用对象组合，而不是类继承。" class="headerlink" title="2.优先使用对象组合，而不是类继承。"></a>2.优先使用对象组合，而不是类继承。</h2><h2 id="3-SOLID原则"><a href="#3-SOLID原则" class="headerlink" title="3.SOLID原则"></a>3.SOLID原则</h2><ul><li><strong>S（SRP，The Single Responsibility Principle，单一责任原则）</strong>：就一个类而言，应该只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，也会影响复用性。</li><li><strong>O（OCP，Open-Closed Principle，开闭原则）</strong>：一个软件实体（指的类、函数、模块等）应该对扩展开放，对修改关闭。即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。　　符合开闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。</li><li><strong>L（LSP，Liskov Substitution Principle，里氏代替原则）</strong>：指的是子类必须替换掉它们的父类型。也就是说，在软件开发过程中，子类替换父类后，程序的行为是一样的。只有当子类替换掉父类后，此时软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。</li><li><strong>I（ISP，Interface Segregation Principle，接口隔离原则）</strong>：使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。</li><li><strong>D（DIP，Dependence Inversion Principle，依赖倒置原则）</strong>： 高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象，也就是提出的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。</li></ul><h2 id="4-合成复用原则（Composite-Reuse-Principle-CRP）"><a href="#4-合成复用原则（Composite-Reuse-Principle-CRP）" class="headerlink" title="4.合成复用原则（Composite Reuse Principle, CRP）"></a>4.合成复用原则（Composite Reuse Principle, CRP）</h2><p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。</p><h2 id="5-迪米特法则（Law-of-Demeter，LoD）又名最少知识原则（Least-Knowledge-Principle，LKP）"><a href="#5-迪米特法则（Law-of-Demeter，LoD）又名最少知识原则（Least-Knowledge-Principle，LKP）" class="headerlink" title="5.迪米特法则（Law of Demeter，LoD）又名最少知识原则（Least Knowledge Principle，LKP）"></a>5.迪米特法则（Law of Demeter，LoD）又名最少知识原则（Least Knowledge Principle，LKP）</h2><p>一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。关于迪米特法则其他的一些表述有：只与你直接的朋友们通信；不要跟“陌生人”说话。外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。</p>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-总体介绍</title>
      <link href="//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-00%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D/"/>
      <url>//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-00%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1 总体介绍"></a>1 总体介绍</h2><h3 id="1-1-什么是设计模式"><a href="#1-1-什么是设计模式" class="headerlink" title="1.1 什么是设计模式"></a>1.1 什么是设计模式</h3><div class="note info"><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。- Christopher Alexander </p></div><div class="note info"><p>对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。- GoF</p></div><p>四个基本要素：</p><ol><li><strong>模式名称（pattern name）</strong> 一个助记名，它用一两个词来描述模式的问题、解决方案和效果。命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。基于一个模式词汇表，我们自己以及同事之间就可以讨论模式并在编写文档时使用它们。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果。找到恰当的模式名也是我们设计模式编目工作的难点之一。</li><li><strong>问题(problem)</strong> 描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等。也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。</li><li><strong>解决方案(solution)</strong> 描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</li><li><strong>效果(consequences)</strong> 描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</li></ol><a id="more"></a><h3 id="1-2-描述设计模式"><a href="#1-2-描述设计模式" class="headerlink" title="1.2 描述设计模式"></a>1.2 描述设计模式</h3><ul><li><strong>模式名和分类</strong>模式名简洁地描述了模式的本质。</li><li><strong>意图</strong>是回答下列问题的简单陈述：设计模式是做什么的？它的基本原理和意图是什么？它解决的是什么样的特定设计问题？</li><li><strong>别名</strong>模式的其他名称。</li><li><strong>动机</strong>用以说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景。</li><li><strong>适用性</strong>什么情况下可以使用该设计模式？该模式可用来改进哪些不良设计？你怎样识别这些情况？</li><li><strong>结构</strong>采用基于对象建模技术的表示法对模式中的类进行图形描述。</li><li><strong>参与者</strong>指设计模式中的类和/或对象以及它们各自的职责。</li><li><strong>协作</strong>模式的参与者怎样协作以实现它们的职责。</li><li><strong>效果</strong>模式怎样支持它的目标？使用模式的效果和所需做的权衡取舍？系统结构的哪些方面可以独立改变？</li><li><strong>实现</strong>实现模式时需要知道的一些提示、技术要点及应避免的缺陷，以及是否存在某些特定于实现语言的问题。</li><li><strong>代码示例</strong>实现该模式的代码片段。</li><li><strong>已知应用</strong>实际系统中发现的模式的例子。</li><li><strong>相关模式</strong>与这个模式紧密相关的模式有哪些？其间重要的不同之处是什么？这个模式应与哪些其他模式一起使用？</li></ul><h3 id="1-3-设计模式怎样解决设计问题"><a href="#1-3-设计模式怎样解决设计问题" class="headerlink" title="1.3 设计模式怎样解决设计问题"></a>1.3 设计模式怎样解决设计问题</h3><ol><li><strong>寻找合适的对象</strong></li><li><strong>决定对象的粒度</strong></li><li><strong>指定对象接口</strong></li><li><strong>描述对象的实现</strong></li><li><strong>运用复用机制</strong></li><li><strong>关联运行时刻和编译时刻</strong></li><li><strong>设计应支持变化</strong></li></ol><h3 id="1-4-导致重新设计的一般原因，以及解决这些问题的设计模式"><a href="#1-4-导致重新设计的一般原因，以及解决这些问题的设计模式" class="headerlink" title="1.4 导致重新设计的一般原因，以及解决这些问题的设计模式"></a>1.4 导致重新设计的一般原因，以及解决这些问题的设计模式</h3><ol><li><strong>通过显式地指定一个类来创建对象</strong>在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象。<br>设计模式：Abstract Factory， Factory Method，Prototype。</li><li><strong>对特殊操作的依赖</strong> 当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方法。<br>设计模式：Chain of Resposibility，Command。</li><li><strong>对硬件和软件平台的依赖</strong> 外部的操作系统接口和应用编程接口(API)在不同的软硬件平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。<br>设计模式：Abstract Factory， Bridge。</li><li><strong>对对象表示或实现的依赖</strong>知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。<br>设计模式：Abstract Factory，Bridge，Memento，Proxy</li><li><strong>算法依赖</strong> 算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。<br>设计模式：Builder，Iterator，Strategy，Template Method，Visitor</li><li><strong>紧耦合</strong> 紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。<br>设计模式：Abstract Factory，Command，Facade，Mediator，Observer，Chain of Responsibility。</li><li><strong>通过生成子类来扩充功能</strong> 通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销(初始化、终止处理等 )。定义子类还需要对父类有深入的了解。如，重定义一个操作可能需要重定义其他操作。一个被重定义的操作可能需要调用继承下来的操作。并且子类方法会导致类爆炸，因为即使对于一个简单的扩充，你也不得不引入许多新的子类。一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。另一方面，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能。<br>设计模式：Bridge，Chain of Responsibility，Composite，Decorator，Observer，Strategy。</li><li><strong>不能方便地对类进行修改</strong> 有时你不得不改变一个难以修改的类。也许你需要源代码而又没有(对于商业类库就有这种情况 )，或者可能对类的任何改变会要求修改许多已存在的其他子类。设计模式提供在这些情况下对类进行修改的方法。<br>设计模式：Adapter，Decorator，Visitor。</li></ol><h3 id="1-5-怎样选择设计模式"><a href="#1-5-怎样选择设计模式" class="headerlink" title="1.5 怎样选择设计模式"></a>1.5 怎样选择设计模式</h3><ul><li>考虑设计模式是怎样解决设计问题的</li><li>浏览模式的意图部分 </li><li>研究模式怎样互相关联 </li><li>研究目的相似的模式 </li><li>检查重新设计的原因</li><li>考虑你的设计中哪些是可变的 </li></ul><h3 id="1-6-怎样使用设计模式"><a href="#1-6-怎样使用设计模式" class="headerlink" title="1.6 怎样使用设计模式"></a>1.6 怎样使用设计模式</h3><ol><li><strong>大致浏览一遍模式</strong>特别注意其适用性部分和效果部分，确定它适合你的问题。</li><li><strong>回头研究结构部分、参与者部分和协作部分</strong>确保你理解这个模式的类和对象以及它们是怎样关联的。</li><li><strong>看代码示例部分，看看这个模式代码形式的具体例子</strong>研究代码将有助于你实现模式。</li><li><strong>选择模式参与者的名字，使它们在应用上下文中有意义</strong>设计模式参与者的名字通常过于抽象而不会直接出现在应用中。然而，将参与者的名字和应用中出现的名字合并起来是很有用的。这会帮助你在实现中更显式的体现出模式来。例如，如果你在文本组合算法中使用了 Strategy 模式，那么你可能有名为 SimpleLayout Strategy 或 TeX Layout Strategy 这样的类。</li><li><strong>定义类</strong>声明它们的接口，建立它们的继承关系，定义代表数据和对象引用的实例变量。识别模式会影响到的你的应用中存在的类，做出相应的修改。</li><li><strong>定义模式中专用于应用的操作名称</strong>这里再一次体现出，名字一般依赖于应用。使用与每一个操作相关联的责任和协作作为指导。还有，你的名字约定要一致。例如，可以使用“Create-”前缀统一标记 Factory 方法。</li><li><strong>实现执行模式中责任和协作的操作</strong>实现部分提供线索指导你进行实现。代码示例部分的例子也能提供帮助。</li></ol><h2 id="2-目录"><a href="#2-目录" class="headerlink" title="2 目录"></a>2 目录</h2><p>按目的准则（即模式是用来完成什么工作）分类：<br><em>注</em>：第二个（）表示范围准则，指定模式主要是用于类还是用于对象。类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。从某种意义上来说，几乎所有模式都使用继承机制，所以“类模式”只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。</p><h3 id="2-1-创建型"><a href="#2-1-创建型" class="headerlink" title="2.1 创建型"></a>2.1 创建型</h3><p>创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。</p><h4 id="2-1-1-抽象工厂（Abstract-Factory）（对象）"><a href="#2-1-1-抽象工厂（Abstract-Factory）（对象）" class="headerlink" title="2.1.1 抽象工厂（Abstract Factory）（对象）"></a>2.1.1 <a href="http://www.venux.cn/2017/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/#more">抽象工厂（Abstract Factory）（对象）</a></h4><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h4 id="2-1-2-建造者（Builder）（对象）"><a href="#2-1-2-建造者（Builder）（对象）" class="headerlink" title="2.1.2 建造者（Builder）（对象）"></a>2.1.2 <a href="">建造者（Builder）（对象）</a></h4><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h4 id="2-1-3-工厂方法（Factory-Method）（类）"><a href="#2-1-3-工厂方法（Factory-Method）（类）" class="headerlink" title="2.1.3 工厂方法（Factory Method）（类）"></a>2.1.3 <a href="">工厂方法（Factory Method）（类）</a></h4><p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。</p><h4 id="2-1-4-原型（Prototype）（对象）"><a href="#2-1-4-原型（Prototype）（对象）" class="headerlink" title="2.1.4 原型（Prototype）（对象）"></a>2.1.4 <a href="">原型（Prototype）（对象）</a></h4><p>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</p><h4 id="2-1-5-单例（Singleton）（对象）"><a href="#2-1-5-单例（Singleton）（对象）" class="headerlink" title="2.1.5 单例（Singleton）（对象）"></a>2.1.5 <a href="">单例（Singleton）（对象）</a></h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="2-2-结构型"><a href="#2-2-结构型" class="headerlink" title="2.2 结构型"></a>2.2 结构型</h3><p>结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。</p><h4 id="2-2-1-适配器（Adapter）（类、对象）"><a href="#2-2-1-适配器（Adapter）（类、对象）" class="headerlink" title="2.2.1 适配器（Adapter）（类、对象）"></a>2.2.1 <a href="">适配器（Adapter）（类、对象）</a></h4><p>将一个类的接口转换成客户希望的另外一个接口。 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h4 id="2-2-2-桥接（Bridge）（对象）"><a href="#2-2-2-桥接（Bridge）（对象）" class="headerlink" title="2.2.2 桥接（Bridge）（对象）"></a>2.2.2 <a href="">桥接（Bridge）（对象）</a></h4><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><h4 id="2-2-3-组合（Composite）（对象）"><a href="#2-2-3-组合（Composite）（对象）" class="headerlink" title="2.2.3 组合（Composite）（对象）"></a>2.2.3 <a href="">组合（Composite）（对象）</a></h4><p>将对象组合成树形结构以表示“部分 -整体”的层次结构。 Composite 使得客户对单个对象和复合对象的使用具有一致性。</p><h4 id="2-2-4-装饰者（Decorator）（对象）"><a href="#2-2-4-装饰者（Decorator）（对象）" class="headerlink" title="2.2.4 装饰者（Decorator）（对象）"></a>2.2.4 <a href="">装饰者（Decorator）（对象）</a></h4><p>动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator 模式比生成子类方式更为灵活。</p><h4 id="2-2-5-外观（Facade）（对象）"><a href="#2-2-5-外观（Facade）（对象）" class="headerlink" title="2.2.5 外观（Facade）（对象）"></a>2.2.5 <a href="">外观（Facade）（对象）</a></h4><p>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><h4 id="2-2-6-享元（Flyweight）（对象）"><a href="#2-2-6-享元（Flyweight）（对象）" class="headerlink" title="2.2.6 享元（Flyweight）（对象）"></a>2.2.6 <a href="">享元（Flyweight）（对象）</a></h4><p>运用共享技术有效地支持大量细粒度的对象</p><h4 id="2-2-7-代理（Proxy）（对象）"><a href="#2-2-7-代理（Proxy）（对象）" class="headerlink" title="2.2.7 代理（Proxy）（对象）"></a>2.2.7 <a href="">代理（Proxy）（对象）</a></h4><p>为其他对象提供一个代理以控制对这个对象的访问。</p><h3 id="2-3-行为型"><a href="#2-3-行为型" class="headerlink" title="2.3 行为型"></a>2.3 行为型</h3><p>行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的任务。</p><h4 id="2-3-1-责任链（Chain-of-Responsibility）（对象）"><a href="#2-3-1-责任链（Chain-of-Responsibility）（对象）" class="headerlink" title="2.3.1 责任链（Chain of Responsibility）（对象）"></a>2.3.1 <a href="">责任链（Chain of Responsibility）（对象）</a></h4><p>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</p><h4 id="2-3-2-命令（Command）（对象）"><a href="#2-3-2-命令（Command）（对象）" class="headerlink" title="2.3.2 命令（Command）（对象）"></a>2.3.2 <a href="">命令（Command）（对象）</a></h4><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</p><h4 id="2-3-3-解释器（Interpreter）（类）"><a href="#2-3-3-解释器（Interpreter）（类）" class="headerlink" title="2.3.3 解释器（Interpreter）（类）"></a>2.3.3 <a href="">解释器（Interpreter）（类）</a></h4><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p><h4 id="2-3-4-迭代器（Iterator）（对象）"><a href="#2-3-4-迭代器（Iterator）（对象）" class="headerlink" title="2.3.4 迭代器（Iterator）（对象）"></a>2.3.4 <a href="">迭代器（Iterator）（对象）</a></h4><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</p><h4 id="2-3-5-中介者（Mediator）（对象）"><a href="#2-3-5-中介者（Mediator）（对象）" class="headerlink" title="2.3.5 中介者（Mediator）（对象）"></a>2.3.5 <a href="">中介者（Mediator）（对象）</a></h4><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h4 id="2-3-6-备忘录（Memento）（对象）"><a href="#2-3-6-备忘录（Memento）（对象）" class="headerlink" title="2.3.6 备忘录（Memento）（对象）"></a>2.3.6 <a href="">备忘录（Memento）（对象）</a></h4><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态</p><h4 id="2-3-7-观察者（Observer）（对象）"><a href="#2-3-7-观察者（Observer）（对象）" class="headerlink" title="2.3.7 观察者（Observer）（对象）"></a>2.3.7 <a href="">观察者（Observer）（对象）</a></h4><p>定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</p><h4 id="2-3-8-状态（State）（对象）"><a href="#2-3-8-状态（State）（对象）" class="headerlink" title="2.3.8 状态（State）（对象）"></a>2.3.8 <a href="">状态（State）（对象）</a></h4><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</p><h4 id="2-3-9-策略（Strategy）（对象）"><a href="#2-3-9-策略（Strategy）（对象）" class="headerlink" title="2.3.9 策略（Strategy）（对象）"></a>2.3.9 <a href="">策略（Strategy）（对象）</a></h4><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</p><h4 id="2-3-10-模板方法（Template-Method）（类）"><a href="#2-3-10-模板方法（Template-Method）（类）" class="headerlink" title="2.3.10 模板方法（Template Method）（类）"></a>2.3.10 <a href="">模板方法（Template Method）（类）</a></h4><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h4 id="2-3-11-访问者（Visitor）（对象）"><a href="#2-3-11-访问者（Visitor）（对象）" class="headerlink" title="2.3.11 访问者（Visitor）（对象）"></a>2.3.11 <a href="">访问者（Visitor）（对象）</a></h4><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><h2 id="3-设计模式相关图表"><a href="#3-设计模式相关图表" class="headerlink" title="3 设计模式相关图表"></a>3 设计模式相关图表</h2><p><img src="/images/posts/设计模式关系图.jpg" alt="设计模式关系图"><br><img src="/images/posts/设计模式可变性.jpg" alt="设计模式可变性"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1 设计模式 - 可复用面向对象软件的基础（第一章：引言）</p>]]></content>
      
      <categories>
          
          <category> 05.编程思想 </category>
          
          <category> 01.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多环境工作</title>
      <link href="//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp-Environment/"/>
      <url>//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp-Environment/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>ASP.NET Core 通过多环境控制 APP 的行为，例如 development，staging 和 production。环境变量决定了运行环境，从而根据不同环境采用不同配置。</p><a id="more"></a><h2 id="2-ASPNETCORE-ENVIRONMENT-环境变量"><a href="#2-ASPNETCORE-ENVIRONMENT-环境变量" class="headerlink" title="2.ASPNETCORE_ENVIRONMENT 环境变量"></a>2.ASPNETCORE_ENVIRONMENT 环境变量</h2><ul><li>Development 开发环境</li><li>Staging 预发布、部署上线前的最终测试环境、生产环境的物理镜像</li><li>Production 生产环境（安全性、高性能、稳健性）<ul><li>开启缓存</li><li>客户端资源 <code>bundled</code>，<code>minified</code> 或 <code>CDN</code></li><li>关闭 <code>diagnostic ErrorPages</code></li><li>开启 <code>friendly error pages</code></li><li>开启 <code>production logging</code> 和 <code>monitoring</code></li><li>…</li></ul></li></ul><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h2><ul><li>Windows 不区分大小写，Linux 默认区分大小写。</li><li>设置：右键项目属性-调试-环境变量，另在 <code>~\Properties\launchSettings.json</code> 可看到具体配置。<ul><li>launchSettings.json 存储的变量可访问到，不安全，禁止存放加密信息，使用 <code>Secret Manager</code> 存放加密信息。 </li></ul></li><li>本机设置<ul><li>临时：<code>set ASPNETCORE_ENVIRONMENT=Development</code></li><li>永久：环境变量-ASPNETCORE_ENVIRONMENT=Development</li></ul></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1 <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/environments" target="_blank" rel="noopener">多环境工作</a></p>]]></content>
      
      <categories>
          
          <category> 01.编程语言 </category>
          
          <category> 01.CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown笔记</title>
      <link href="//posts/03.%E5%B7%A5%E5%85%B7/Markdown/"/>
      <url>//posts/03.%E5%B7%A5%E5%85%B7/Markdown/</url>
      <content type="html"><![CDATA[<h2 id="1-什么是Markdown"><a href="#1-什么是Markdown" class="headerlink" title="1.什么是Markdown"></a>1.什么是Markdown</h2><p>Markdown是一种在web显示带样式风格文本的方式。你能通过它控制文本的字体样式、插入图片、插入列表等。通常，Markdown使用一些特殊的非字母符号来作为语法规则，如<code>#</code>等。你能在Github上大部分地方使用Markdown。比如：</p><ul><li><a href="https://gist.github.com/" target="_blank" rel="noopener">Gists</a></li><li>Issues的评论、Pull Requests</li><li>.md或.markdown后缀名的文件</li></ul><a id="more"></a><h2 id="2-规范"><a href="#2-规范" class="headerlink" title="2.规范"></a>2.规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;anchorTest&quot;&gt;锚点测试&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">1. 这是一个文本；</span><br><span class="line">2. **粗体**；</span><br><span class="line">3. *斜体*；</span><br><span class="line">4. [我的Github](https://github.com/venux)</span><br><span class="line">5. 列表</span><br><span class="line">    * 无序列表1</span><br><span class="line">    - 无序列表2</span><br><span class="line">        - 无序列表21</span><br><span class="line">        - 无序列表22</span><br><span class="line">6. 图片![Image](https://avatars2.githubusercontent.com/u/7089227?v=3&amp;s=460)</span><br><span class="line">7. 引用</span><br><span class="line"></span><br><span class="line">&gt;Hello,World!-Coder</span><br><span class="line"></span><br><span class="line"># H1</span><br><span class="line">## H2</span><br><span class="line">### H3</span><br><span class="line">#### H4</span><br><span class="line">##### H5</span><br><span class="line">###### H6</span><br><span class="line"></span><br><span class="line">I think you should use an `&lt;addr&gt;` element here instead.</span><br></pre></td></tr></table></figure><h2 id="3-Github特殊风格"><a href="#3-Github特殊风格" class="headerlink" title="3.Github特殊风格"></a>3.Github特殊风格</h2><h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(args)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Hello,World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><ul><li style="list-style: none"><input type="checkbox" checked> 1. 已完成任务，支持列表，@mentions, #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported</li><li style="list-style: none"><input type="checkbox"> 2. 未完成任务</li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th>表头一</th><th>表头2</th></tr></thead><tbody><tr><td>11</td><td>12</td></tr><tr><td>21</td><td>22</td></tr></tbody></table><h3 id="SHA引用"><a href="#SHA引用" class="headerlink" title="SHA引用"></a>SHA引用</h3><p>5e0b770018f87bd7fafecb7b3920cda8a30d4740</p><h3 id="Issue引用"><a href="#Issue引用" class="headerlink" title="Issue引用"></a>Issue引用</h3><p>#1</p><h3 id="圈人"><a href="#圈人" class="headerlink" title="圈人"></a>圈人</h3><p>@venux @CDLL</p><h3 id="自动识别网址"><a href="#自动识别网址" class="headerlink" title="自动识别网址"></a>自动识别网址</h3><p><a href="http://www.cnblogs.com" target="_blank" rel="noopener">http://www.cnblogs.com</a></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><del>删除</del></p><h3 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h3><p>:+1:</p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p><a href="#anchorTest">锚点测试</a></p>]]></content>
      
      <categories>
          
          <category> 03.工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git笔记</title>
      <link href="//posts/03.%E5%B7%A5%E5%85%B7/Git/"/>
      <url>//posts/03.%E5%B7%A5%E5%85%B7/Git/</url>
      <content type="html"><![CDATA[<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><p>git init</p><h2 id="2-添加到仓库"><a href="#2-添加到仓库" class="headerlink" title="2.添加到仓库"></a>2.添加到仓库</h2><p>git add $filename</p><h2 id="3-提交到仓库"><a href="#3-提交到仓库" class="headerlink" title="3.提交到仓库"></a>3.提交到仓库</h2><p>git commit -m “$comment”</p><h2 id="4-查看状态"><a href="#4-查看状态" class="headerlink" title="4.查看状态"></a>4.查看状态</h2><p>git status</p><a id="more"></a><h2 id="5-对比修改记录"><a href="#5-对比修改记录" class="headerlink" title="5.对比修改记录"></a>5.对比修改记录</h2><p>git diff</p><h2 id="6-查看提交日志"><a href="#6-查看提交日志" class="headerlink" title="6.查看提交日志"></a>6.查看提交日志</h2><p>git log </p><ul><li><code>--pretty=oneline</code>:单行显示</li><li><code>--graph</code>：图像显示</li><li><code>--abbrev-commit</code>：缩写CommitID</li></ul><h2 id="7-版本回退"><a href="#7-版本回退" class="headerlink" title="7.版本回退"></a>7.版本回退</h2><p>git reset –hard</p><ul><li><code>HEAD</code>表示当前版本</li><li><code>HEAD^</code>表示上个版本，<code>HEAD^^</code>上上个版本<ul><li>git reset –hard HEAD^</li><li><strong>注意：^在CMD中需要用双引号括起来</strong></li></ul></li><li><code>HEAD~100</code>上100个版本</li><li><code>versionId</code>版本号（可只写前几位）：<ul><li>git reset –hard cfab68213adec8795db301414287dfccadb30499</li></ul></li></ul><h2 id="8-查看命令历史"><a href="#8-查看命令历史" class="headerlink" title="8.查看命令历史"></a>8.查看命令历史</h2><p>git reflog</p><h2 id="9-撤销修改"><a href="#9-撤销修改" class="headerlink" title="9.撤销修改"></a>9.撤销修改</h2><ul><li>未添加到暂存区：git checkout – $filename</li><li>已添加到暂存区：git reset HEAD $filename</li></ul><h2 id="10-删除文件"><a href="#10-删除文件" class="headerlink" title="10.删除文件"></a>10.删除文件</h2><p>git rm $filename</p><h2 id="11-添加远程库"><a href="#11-添加远程库" class="headerlink" title="11.添加远程库"></a>11.添加远程库</h2><p>git remote add origin $giturl</p><ul><li>远程库默认名为<code>origin</code></li></ul><h2 id="12-推送当前分支master到远程库origin"><a href="#12-推送当前分支master到远程库origin" class="headerlink" title="12.推送当前分支master到远程库origin"></a>12.推送当前分支master到远程库origin</h2><p>git push -u origin master</p><ul><li><code>-u</code>：由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</li><li>第二次后就可去掉<code>-u</code>参数直接推送。</li></ul><h2 id="13-克隆"><a href="#13-克隆" class="headerlink" title="13.克隆"></a>13.克隆</h2><p>git clone $giturl</p><h2 id="14-创建分支"><a href="#14-创建分支" class="headerlink" title="14.创建分支"></a>14.创建分支</h2><p>git branch $branchname</p><h2 id="15-切换分支"><a href="#15-切换分支" class="headerlink" title="15.切换分支"></a>15.切换分支</h2><p>git checkout $branchname</p><h2 id="16-创建并切换分支"><a href="#16-创建并切换分支" class="headerlink" title="16.创建并切换分支"></a>16.创建并切换分支</h2><p>git checkout -b $branchname</p><ul><li><code>-b</code>：表示创建并切换，相当于创建<code>git branch $branchname</code>和切换<code>git checkout $branchname</code>两个命令。</li></ul><h2 id="17-查看分支"><a href="#17-查看分支" class="headerlink" title="17.查看分支"></a>17.查看分支</h2><p>git branch</p><h2 id="18-合并分支"><a href="#18-合并分支" class="headerlink" title="18.合并分支"></a>18.合并分支</h2><p>git merge $branchname</p><ul><li>合并指定分支到当前分支</li><li>合并结果中的<code>Fast-forward</code>表示快进模式，即直接将当前分支的指针指向指定分支的最新提交位置，故非常快。</li><li><code>--no-ff</code>：禁用<code>Fast-forward</code>模式，这样会在merge时生成新的commit信息。合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</li></ul><h2 id="19-删除分支"><a href="#19-删除分支" class="headerlink" title="19.删除分支"></a>19.删除分支</h2><p>git branch -d $branchname</p><ul><li><code>-d</code>：删除已合并的分支；</li><li><code>-D</code>：强制删除未合并的分支（<strong>注意：分支代码无法找回</strong>）。</li></ul><h2 id="20-解决冲突"><a href="#20-解决冲突" class="headerlink" title="20.解决冲突"></a>20.解决冲突</h2><p>1 多分支同时修改同一个文件后add并commit；<br>2 merge分支时提示冲突；<br>3 修改冲突文件后再次add并commit即可。</p><h2 id="21-分支策略"><a href="#21-分支策略" class="headerlink" title="21.分支策略"></a>21.分支策略</h2><p>1 master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>2 dev分支干活，不稳定的.每个人都有自己的分支，时不时地往dev分支上合并就可以了。到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；<br>3 所以，团队合作的分支看起来就像这样：<br><img src="/images/posts/git分支.png" alt="图1"></p><h2 id="22-储藏"><a href="#22-储藏" class="headerlink" title="22.储藏"></a>22.储藏</h2><ul><li>git stash：可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</li><li>git stash list：查看储藏列表</li><li>git stash apply [stash@{n}]：恢复储藏，可选指定储藏</li><li>git stash drop [stash@{n}]：删除储藏，可选指定储藏</li><li>git stash pop [stash@{n}]：恢复并删除储藏，可选指定储藏</li></ul><h2 id="23-查看远程分支"><a href="#23-查看远程分支" class="headerlink" title="23.查看远程分支"></a>23.查看远程分支</h2><p>git remote</p><ul><li><code>-v</code>：显示详细信息</li></ul><h2 id="24-推送分支"><a href="#24-推送分支" class="headerlink" title="24.推送分支"></a>24.推送分支</h2><p>git push origin $branchname</p><ul><li>master分支是主分支，因此要时刻与远程同步；</li><li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h2 id="25-标签"><a href="#25-标签" class="headerlink" title="25.标签"></a>25.标签</h2><ul><li>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</li><li>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</li><li>增强版本识别，不用通过版本ID判断版本。</li></ul><h2 id="26-创建标签"><a href="#26-创建标签" class="headerlink" title="26.创建标签"></a>26.创建标签</h2><p>git tag $tagname [$commitid]</p><ul><li>$commitid：指定给对应的提交记录打上标签，如无则给最新提交的记录加标签。</li></ul><h2 id="27-查看标签"><a href="#27-查看标签" class="headerlink" title="27.查看标签"></a>27.查看标签</h2><p>git tag [$tagname]</p><ul><li>$tagname：查看指定标签，如无则查看所有标签。</li><li><code>-a</code>：指定标签名，如<code>git tag -a v1.0</code>。</li><li><code>-m</code>：指定说明，如<code>git tag -a v1.0 -m &quot;这是第一个发布版本&quot;</code>。</li></ul><h2 id="28-推送标签"><a href="#28-推送标签" class="headerlink" title="28.推送标签"></a>28.推送标签</h2><p>git push origin $tagname</p><h2 id="29-推送所有标签"><a href="#29-推送所有标签" class="headerlink" title="29.推送所有标签"></a>29.推送所有标签</h2><p>git push origin –tags</p><h2 id="30-删除标签"><a href="#30-删除标签" class="headerlink" title="30.删除标签"></a>30.删除标签</h2><p>git tag -d $tagname</p><h2 id="31-删除远程标签"><a href="#31-删除远程标签" class="headerlink" title="31.删除远程标签"></a>31.删除远程标签</h2><p>git push origin :refs/tags/$tagname</p><ul><li>要求先删除本地标签</li></ul><h2 id="32-忽略文件"><a href="#32-忽略文件" class="headerlink" title="32.忽略文件"></a>32.忽略文件</h2><ul><li>.gitignore文件<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">github</a></li><li>原则是：<ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul></li></ul><h2 id="33-查看忽略文件"><a href="#33-查看忽略文件" class="headerlink" title="33.查看忽略文件"></a>33.查看忽略文件</h2><p>git check-ignore</p><ul><li><code>-v</code>：查看忽略规则的详细行数</li></ul><h2 id="34-命令别名"><a href="#34-命令别名" class="headerlink" title="34.命令别名"></a>34.命令别名</h2><p>git config –global alias.$shortname $name<br><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></p><h2 id="35-配置"><a href="#35-配置" class="headerlink" title="35.配置"></a>35.配置</h2><ul><li>全局配置文件位置：<code>C:\Users\$username\.gitconfig</code></li><li>git config –global user.name <code>value</code></li><li>git config –global user.email <code>value</code> </li></ul><h2 id="36-拉取"><a href="#36-拉取" class="headerlink" title="36.拉取"></a>36.拉取</h2><p>git pull origin master</p><ul><li>若提示refusing to merge unrelated histories则需添加参数<code>--allow-unrelated-histories</code></li></ul><h2 id="37-更新fork的repo"><a href="#37-更新fork的repo" class="headerlink" title="37.更新fork的repo"></a>37.更新fork的repo</h2><p>1 <strong>git remote -v</strong><br>查看当前Fork项目已配置的远程仓库（List the current configured remote repository for your fork）<br>2 <strong>git remote add upstream <code>url</code></strong><br>指定将要同步Fork项目的一个远程上游仓库（Specify a new remote upstream repository that will be synced with the fork.）<br>3 <strong>git remote -v</strong><br>再次查看<br>4 <strong>git fetch upstream</strong><br>拉取上游仓库的所有分支和更改记录，mater分支提交记录会在本地分支中保存。（Fetch the branches and their respective commits from the upstream repository. Commits to master will be stored in a local branch, upstream/master.）<br>5 <strong>git checkout master</strong><br>迁出本地master分支（Check out your fork’s local master branch.）<br>6 <strong>git merge upstream/master</strong><br>将上游仓库的master分支更改记录合并到本地master分支中，即同步且不会丢失本地更改记录。（Merge the changes from upstream/master into your local master branch. This brings your fork’s master branch into sync with the upstream repository, without losing your local changes.）</p><h2 id="38-添加SSH至Github"><a href="#38-添加SSH至Github" class="headerlink" title="38.添加SSH至Github"></a>38.添加SSH至Github</h2><p>1 <strong>生成</strong><br>ssh-keygen -t rsa -b 4096 -C “<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>“<br>2 <strong>拷贝</strong><br>将<code>C:\Users\Administrator\.ssh\id_rsa.pub</code>的值添加到Github个人设置的SSH中。<br>3 <strong>检验</strong><br>ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><h2 id="39-关联远程分支"><a href="#39-关联远程分支" class="headerlink" title="39.关联远程分支"></a>39.关联远程分支</h2><p>git branch –set-upstream-to=origin/$branchame release</p><p>在本地新建分支后，需要关联远程分支，否则提示 <code>There is no tracking information for the current branch.</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰git教程</a><br>2 <a href="https://help.github.com/articles/syncing-a-fork/" target="_blank" rel="noopener">syncing-a-fork</a></p>]]></content>
      
      <categories>
          
          <category> 03.工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
