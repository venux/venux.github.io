<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>祥_venux</title>
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.venux.cn/"/>
  <updated>2018-05-14T02:53:19.401Z</updated>
  <id>http://www.venux.cn/</id>
  
  <author>
    <name>祥_venux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java-Tomcat</title>
    <link href="http://www.venux.cn/2018/04/18/java-Tomcat/"/>
    <id>http://www.venux.cn/2018/04/18/java-Tomcat/</id>
    <published>2018-04-18T14:13:30.000Z</published>
    <updated>2018-05-14T02:53:19.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>Apache 基金会下的一款开源的 web 服务器。</p>
<h2 id="2-下载"><a href="#2-下载" class="headerlink" title="2.下载"></a>2.下载</h2><p><a href="http://tomcat.apache.org/download-90.cgi" target="_blank" rel="external">Tomcat下载</a></p>
<h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><p>解压缩到指定目录</p>
<h3 id="3-1-目录结构"><a href="#3-1-目录结构" class="headerlink" title="3.1 目录结构"></a>3.1 目录结构</h3><ul>
<li>bin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。</li>
<li>conf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。</li>
<li>lib：库文件。tomcat运行时需要的jar包所在的目录</li>
<li>logs：日志</li>
<li>temp：临时产生的文件，即缓存</li>
<li>webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问</li>
<li>work：编译以后的class文件。</li>
</ul>
<h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><h3 id="4-1-环境变量配置"><a href="#4-1-环境变量配置" class="headerlink" title="4.1 环境变量配置"></a>4.1 环境变量配置</h3><ol>
<li><strong>CATALINA_HOME</strong>：C:\Program Files\Tomcat 8.5（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%CATALINA_HOME%\bin;</li>
<li><strong>CLASS_PATH</strong>:%CATALINA_HOME%\lib;</li>
</ol>
<h3 id="4-2-配置文件"><a href="#4-2-配置文件" class="headerlink" title="4.2 配置文件"></a>4.2 配置文件</h3><p>$CATALINA_HOME 目录下的 conf 目录，核心配置文件 server.xml。</p>
<h2 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h2><p>进入 $CATALINA_HOME 目录下的 bin 目录，运行 startup.bat 即可。</p>
<h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h3><ul>
<li><strong>localhost:8080</strong>:Tomcat默认主页</li>
</ul>
<h3 id="7-Eclipse集成"><a href="#7-Eclipse集成" class="headerlink" title="7 Eclipse集成"></a>7 Eclipse集成</h3><ul>
<li>“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。</li>
</ul>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;p&gt;Apache 基金会下的一款开源的 web 服务器。&lt;/p&gt;
&lt;h2 id=&quot;2-下载&quot;&gt;&lt;a href=&quot;#2-下载&quot; class=&quot;headerlink&quot; title=&quot;2.下载&quot;&gt;&lt;/a&gt;2.下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://tomcat.apache.org/download-90.cgi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tomcat下载&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-安装&quot;&gt;&lt;a href=&quot;#3-安装&quot; class=&quot;headerlink&quot; title=&quot;3. 安装&quot;&gt;&lt;/a&gt;3. 安装&lt;/h2&gt;&lt;p&gt;解压缩到指定目录&lt;/p&gt;
&lt;h3 id=&quot;3-1-目录结构&quot;&gt;&lt;a href=&quot;#3-1-目录结构&quot; class=&quot;headerlink&quot; title=&quot;3.1 目录结构&quot;&gt;&lt;/a&gt;3.1 目录结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;bin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。&lt;/li&gt;
&lt;li&gt;conf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。&lt;/li&gt;
&lt;li&gt;lib：库文件。tomcat运行时需要的jar包所在的目录&lt;/li&gt;
&lt;li&gt;logs：日志&lt;/li&gt;
&lt;li&gt;temp：临时产生的文件，即缓存&lt;/li&gt;
&lt;li&gt;webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问&lt;/li&gt;
&lt;li&gt;work：编译以后的class文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-配置&quot;&gt;&lt;a href=&quot;#4-配置&quot; class=&quot;headerlink&quot; title=&quot;4. 配置&quot;&gt;&lt;/a&gt;4. 配置&lt;/h2&gt;&lt;h3 id=&quot;4-1-环境变量配置&quot;&gt;&lt;a href=&quot;#4-1-环境变量配置&quot; class=&quot;headerlink&quot; title=&quot;4.1 环境变量配置&quot;&gt;&lt;/a&gt;4.1 环境变量配置&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CATALINA_HOME&lt;/strong&gt;：C:\Program Files\Tomcat 8.5（注：结尾不加分号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PATH&lt;/strong&gt;:%CATALINA_HOME%\bin;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLASS_PATH&lt;/strong&gt;:%CATALINA_HOME%\lib;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;4-2-配置文件&quot;&gt;&lt;a href=&quot;#4-2-配置文件&quot; class=&quot;headerlink&quot; title=&quot;4.2 配置文件&quot;&gt;&lt;/a&gt;4.2 配置文件&lt;/h3&gt;&lt;p&gt;$CATALINA_HOME 目录下的 conf 目录，核心配置文件 server.xml。&lt;/p&gt;
&lt;h2 id=&quot;5-启动&quot;&gt;&lt;a href=&quot;#5-启动&quot; class=&quot;headerlink&quot; title=&quot;5. 启动&quot;&gt;&lt;/a&gt;5. 启动&lt;/h2&gt;&lt;p&gt;进入 $CATALINA_HOME 目录下的 bin 目录，运行 startup.bat 即可。&lt;/p&gt;
&lt;h3 id=&quot;6-测试&quot;&gt;&lt;a href=&quot;#6-测试&quot; class=&quot;headerlink&quot; title=&quot;6. 测试&quot;&gt;&lt;/a&gt;6. 测试&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;localhost:8080&lt;/strong&gt;:Tomcat默认主页&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;7-Eclipse集成&quot;&gt;&lt;a href=&quot;#7-Eclipse集成&quot; class=&quot;headerlink&quot; title=&quot;7 Eclipse集成&quot;&gt;&lt;/a&gt;7 Eclipse集成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-JSP</title>
    <link href="http://www.venux.cn/2018/04/18/java-JSP/"/>
    <id>http://www.venux.cn/2018/04/18/java-JSP/</id>
    <published>2018-04-18T14:05:19.000Z</published>
    <updated>2018-05-14T02:53:19.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>JSP（Java Server Pages），一种动态网页开发技术，类似于 ASP。通常以<code>&lt;%</code>开头，以<code>%&gt;</code>结尾。</p>
<a id="more"></a>
<h2 id="2-特点（与CGI对比）"><a href="#2-特点（与CGI对比）" class="headerlink" title="2 特点（与CGI对比）"></a>2 特点（与CGI对比）</h2><ul>
<li>性能更加优越，因为JSP可以直接在HTML网页中动态嵌入元素而不需要单独引用CGI文件。</li>
<li>服务器调用的是已经编译好的JSP文件，而不像CGI/Perl那样必须先载入解释器和目标脚本。</li>
<li>JSP 基于Java Servlet API，因此，JSP拥有各种强大的企业级Java API，包括JDBC，JNDI，EJB，JAXP等等。</li>
<li>JSP页面可以与处理业务逻辑的 Servlet 一起使用，这种模式被Java servlet 模板引擎所支持。</li>
</ul>
<h2 id="3-JSP-流程"><a href="#3-JSP-流程" class="headerlink" title="3 JSP 流程"></a>3 JSP 流程</h2><p><img src="/images/posts/jsp-arch.jpg" alt="JSP 位置"><br><img src="/images/posts/jsp-processing.jpg" alt="JSP 流程"></p>
<ul>
<li>浏览器发送一个 HTTP 请求给服务器。</li>
<li>Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成。</li>
<li>JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码。</li>
<li>JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎。</li>
<li>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。</li>
<li>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。</li>
<li>Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样。</li>
</ul>
<h2 id="4-JSP-生命周期"><a href="#4-JSP-生命周期" class="headerlink" title="4 JSP 生命周期"></a>4 JSP 生命周期</h2><p><img src="/images/posts/jsp_life_cycle.jpg" alt="JSP 生命周期"></p>
<ul>
<li><strong>编译阶段</strong>：servlet容器编译servlet源文件，生成servlet类。若未修改，则跳过。<ul>
<li>解析JSP文件。</li>
<li>将JSP文件转为servlet。</li>
<li>编译servlet。</li>
</ul>
</li>
<li><p><strong>初始化阶段</strong>：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspInit</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="comment">//JSP初始化代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>执行阶段</strong>：调用与JSP对应的servlet实例的服务方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</div><div class="line">  <span class="comment">//服务端处理代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>销毁阶段</strong>：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspDestroy</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="comment">//清理代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-JSP-语法"><a href="#5-JSP-语法" class="headerlink" title="5 JSP 语法"></a>5 JSP 语法</h2><h3 id="5-1-脚本程序"><a href="#5-1-脚本程序" class="headerlink" title="5.1 脚本程序"></a>5.1 脚本程序</h3><p>可包含任意量的Java语句、变量、方法或表达式。格式：<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;% 代码片段 %&gt;</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;jsp:scriptlet&gt;</div><div class="line">  代码片段</div><div class="line">&lt;/jsp:scriptlet&gt;</div></pre></td></tr></table></figure></p>
<h3 id="5-2-头部支持中文"><a href="#5-2-头部支持中文" class="headerlink" title="5.2 头部支持中文"></a>5.2 头部支持中文</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html;charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</div></pre></td></tr></table></figure>
<h3 id="5-3-声明"><a href="#5-3-声明" class="headerlink" title="5.3 声明"></a>5.3 声明</h3><p>一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%! declaration;[ declaration;]+ ... %&gt;</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;jsp:declaration&gt;</div><div class="line">  代码片段</div><div class="line">&lt;/jsp:declaration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="5-4-表达式"><a href="#5-4-表达式" class="headerlink" title="5.4 表达式"></a>5.4 表达式</h3><p>一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。<br><code>注意：</code>不能以分号来结束。</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%= 表达式 %&gt;</div></pre></td></tr></table></figure>
<p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;jsp:expression&gt;</div><div class="line">   表达式</div><div class="line">&lt;/jsp:expression&gt;</div></pre></td></tr></table></figure></p>
<h3 id="5-5-注释"><a href="#5-5-注释" class="headerlink" title="5.5 注释"></a>5.5 注释</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%--注释--%&gt;</div></pre></td></tr></table></figure>
<h3 id="5-6-指令"><a href="#5-6-指令" class="headerlink" title="5.6 指令"></a>5.6 指令</h3><p>设置与整个JSP页面相关的属性。</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%@ directive attribute=<span class="string">"value"</span> %&gt;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;%@ page … %&gt;</td>
<td>定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td>
</tr>
<tr>
<td>&lt;%@ include … %&gt;</td>
<td>包含其他文件</td>
</tr>
<tr>
<td>&lt;%@ taglib … %&gt;</td>
<td>引入标签库的定义，可以是自定义标签</td>
</tr>
</tbody>
</table>
<h3 id="5-7-行为"><a href="#5-7-行为" class="headerlink" title="5.7 行为"></a>5.7 行为</h3><p>使用XML语法结构来控制servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。<br>行为标签只有一种语法格式，它严格遵守XML标准。</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;jsp:action_name attribute=<span class="string">"value"</span> /&gt;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>jsp:include</td>
<td>用于在当前页面中包含静态或动态资源</td>
</tr>
<tr>
<td>jsp:useBean</td>
<td>寻找和初始化一个JavaBean组件</td>
</tr>
<tr>
<td>jsp:setProperty</td>
<td>设置 JavaBean组件的值</td>
</tr>
<tr>
<td>jsp:getProperty</td>
<td>将 JavaBean组件的值插入到 output中</td>
</tr>
<tr>
<td>jsp:forward</td>
<td>从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td>
</tr>
<tr>
<td>jsp:plugin</td>
<td>用于在生成的HTML页面中包含Applet和JavaBean对象</td>
</tr>
<tr>
<td>jsp:element</td>
<td>动态创建一个XML元素</td>
</tr>
<tr>
<td>jsp:attribute</td>
<td>定义动态创建的XML元素的属性</td>
</tr>
<tr>
<td>jsp:body</td>
<td>定义动态创建的XML元素的主体</td>
</tr>
<tr>
<td>jsp:text</td>
<td>用于封装模板数据</td>
</tr>
</tbody>
</table>
<h3 id="5-8-隐含对象"><a href="#5-8-隐含对象" class="headerlink" title="5.8 隐含对象"></a>5.8 隐含对象</h3><table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>HttpServletRequest类的实例</td>
</tr>
<tr>
<td>response</td>
<td>HttpServletResponse类的实例</td>
</tr>
<tr>
<td>out</td>
<td>PrintWriter类的实例，用于把结果输出至网页上</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession类的实例</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext类的实例，与应用上下文有关</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig类的实例</td>
</tr>
<tr>
<td>pageContext</td>
<td>PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问</td>
</tr>
<tr>
<td>page</td>
<td>类似于Java类中的this关键字</td>
</tr>
<tr>
<td>Exception</td>
<td>Exception类的对象，代表发生错误的JSP页面中对应的异常对象</td>
</tr>
</tbody>
</table>
<h3 id="5-9-控制流语句"><a href="#5-9-控制流语句" class="headerlink" title="5.9 控制流语句"></a>5.9 控制流语句</h3><h4 id="5-9-1-判断语句"><a href="#5-9-1-判断语句" class="headerlink" title="5.9.1 判断语句"></a>5.9.1 判断语句</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;% <span class="keyword">if</span>(flag)&#123; %&gt;</div><div class="line">  &lt;p&gt;True&lt;/p&gt;</div><div class="line">&lt;% &#125;<span class="keyword">else</span>&#123; %&gt;</div><div class="line">  &lt;p&gt;False&lt;/p&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>
<h4 id="5-9-2-循环语句"><a href="#5-9-2-循环语句" class="headerlink" title="5.9.2 循环语句"></a>5.9.2 循环语句</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;% <span class="keyword">for</span> ( index = <span class="number">1</span>; index &lt;= <span class="number">3</span>; index++)&#123; %&gt;</div><div class="line">  &lt;p&gt;</div><div class="line">    &lt;%= index %&gt; </div><div class="line">  &lt;/p&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>
<h3 id="5-10-运算符"><a href="#5-10-运算符" class="headerlink" title="5.10 运算符"></a>5.10 运算符</h3><p>JSP支持所有Java逻辑和算术运算符。</p>
<h3 id="5-11-字面量"><a href="#5-11-字面量" class="headerlink" title="5.11 字面量"></a>5.11 字面量</h3><ul>
<li>布尔值(boolean)：true 和 false;</li>
<li>整型(int)：与 Java 中的一样;</li>
<li>浮点型(float)：与 Java 中的一样;</li>
<li>字符串(string)：以单引号或双引号开始和结束;</li>
<li>Null：null。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;p&gt;JSP（Java Server Pages），一种动态网页开发技术，类似于 ASP。通常以&lt;code&gt;&amp;lt;%&lt;/code&gt;开头，以&lt;code&gt;%&amp;gt;&lt;/code&gt;结尾。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-名词解释</title>
    <link href="http://www.venux.cn/2018/04/15/java-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    <id>http://www.venux.cn/2018/04/15/java-名词解释/</id>
    <published>2018-04-15T14:19:21.000Z</published>
    <updated>2018-05-14T02:53:19.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1 名词解释"></a>1 名词解释</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>详细信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>POJOs</td>
<td>Plain Old Java Objects</td>
<td>普通的 Java对象</td>
</tr>
<tr>
<td>DAO</td>
<td>Data Access Objects</td>
<td>数据访问对象</td>
</tr>
<tr>
<td>CGI</td>
<td>Common Gateway Interfa e</td>
<td>公共网关接口</td>
</tr>
<tr>
<td>JSP</td>
<td>Java Server Pages</td>
<td>Java服务页面（动态网页开发技术）</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-名词解释&quot;&gt;&lt;a href=&quot;#1-名词解释&quot; class=&quot;headerlink&quot; title=&quot;1 名词解释&quot;&gt;&lt;/a&gt;1 名词解释&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;th&gt;全称&lt;/th&gt;
&lt;th&gt;详细信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;POJOs&lt;/td&gt;
&lt;td&gt;Plain Old Java Objects&lt;/td&gt;
&lt;td&gt;普通的 Java对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DAO&lt;/td&gt;
&lt;td&gt;Data Access Objects&lt;/td&gt;
&lt;td&gt;数据访问对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CGI&lt;/td&gt;
&lt;td&gt;Common Gateway Interfa e&lt;/td&gt;
&lt;td&gt;公共网关接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JSP&lt;/td&gt;
&lt;td&gt;Java Server Pages&lt;/td&gt;
&lt;td&gt;Java服务页面（动态网页开发技术）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-MyBatis</title>
    <link href="http://www.venux.cn/2018/04/15/java-MyBatis/"/>
    <id>http://www.venux.cn/2018/04/15/java-MyBatis/</id>
    <published>2018-04-15T14:17:04.000Z</published>
    <updated>2018-05-14T02:53:19.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>MyBatis 是一款<strong>持久层框架</strong>，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;p&gt;MyBatis 是一款&lt;strong&gt;持久层框架&lt;/strong&gt;，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-Maven</title>
    <link href="http://www.venux.cn/2018/04/15/java-Maven/"/>
    <id>http://www.venux.cn/2018/04/15/java-Maven/</id>
    <published>2018-04-15T09:36:50.000Z</published>
    <updated>2018-05-14T02:53:19.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>Maven 是一个项目构建和管理的自动化工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。</p>
<p>Maven 使用惯例优于配置的原则 。它要求在没有定制之前，所有的项目都有如下的结构：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>${basedir}</td>
<td>存放 pom.xml和所有的子目录</td>
</tr>
<tr>
<td>${basedir}/src/main/java</td>
<td>项目的 java源代码</td>
</tr>
<tr>
<td>${basedir}/src/main/resources</td>
<td>项目的资源，比如说 property文件</td>
</tr>
<tr>
<td>${basedir}/src/test/java</td>
<td>项目的测试类，比如说 JUnit代码</td>
</tr>
<tr>
<td>${basedir}/src/test/resources</td>
<td>测试使用的资源</td>
</tr>
</tbody>
</table>
<p>一个 maven 项目在默认情况下会产生 JAR 文件，另外 ，编译后 的 classes 会放在 ${basedir}/target/classes 下面， JAR 文件会放在 ${basedir}/target 下面。<br><a id="more"></a></p>
<h2 id="2-下载-amp-安装-amp-配置"><a href="#2-下载-amp-安装-amp-配置" class="headerlink" title="2 下载&amp;安装&amp;配置"></a>2 下载&amp;安装&amp;配置</h2><h3 id="2-1-前提"><a href="#2-1-前提" class="headerlink" title="2.1 前提"></a>2.1 前提</h3><p>需安装配置 java 开发环境</p>
<h3 id="2-2-下载地址"><a href="#2-2-下载地址" class="headerlink" title="2.2 下载地址"></a>2.2 下载地址</h3><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="external">Maven下载</a></p>
<h3 id="2-3-安装"><a href="#2-3-安装" class="headerlink" title="2.3 安装"></a>2.3 安装</h3><p>直接解压缩到指定目录</p>
<h3 id="2-4-配置"><a href="#2-4-配置" class="headerlink" title="2.4 配置"></a>2.4 配置</h3><p>配置文件：<code>‪C:\Program Files\apache-maven-3.5.0\conf\settings.xml</code></p>
<ol>
<li><strong>MAVEN_HOME</strong>:C:\Program Files\apache-maven-3.5.0（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%MAVEN_HOME%\bin;</li>
<li><strong>MAVEN_OPTS</strong>: -Xms128m -Xmx512m;(设置Maven可用内存大小)</li>
<li>修改本地仓库路径：setting.xml 中的 localRepository。</li>
</ol>
<h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><ul>
<li><strong>maven -v</strong>:版本号</li>
</ul>
<h3 id="2-6-集成IDE"><a href="#2-6-集成IDE" class="headerlink" title="2.6 集成IDE"></a>2.6 集成IDE</h3><ul>
<li>Eclipse IDE：<a href="https://www.eclipse.org/m2e/" target="_blank" rel="external">M2Eclipse</a>，直接搜索 Maven 即可。<ul>
<li>Launching Maven builds from within Eclipse</li>
<li>Dependency management for Eclipse build path based on Maven’s pom.xml</li>
<li>Resolving Maven dependencies from the Eclipse workspace without installing to local Maven repository</li>
<li>Automatic downloading of the required dependencies and sources from the remote Maven repositories</li>
<li>Wizards for creating new Maven projects, pom.xml and to enable Maven support on existing projects</li>
<li>Quick search for dependencies in remote Maven repositories</li>
<li>Quick fixes in the Java editor for looking up required dependencies/jars by the class or package name</li>
<li>Integration with other Eclipse tools, such as WTP, AJDT, Mylyn, Subclipse and others.</li>
</ul>
</li>
<li>Intellij IDEA:<a href="https://www.jetbrains.com/help/idea/maven.html" target="_blank" rel="external">Intellij IDEA-Maven</a></li>
</ul>
<h2 id="3-核心概念"><a href="#3-核心概念" class="headerlink" title="3 核心概念"></a>3 核心概念</h2><h3 id="3-1-POM（Project-Object-Model）-ps-个人理解为类似于VS的csproj文件，用于管理项目"><a href="#3-1-POM（Project-Object-Model）-ps-个人理解为类似于VS的csproj文件，用于管理项目" class="headerlink" title="3.1 POM（Project Object Model）[ps:个人理解为类似于VS的csproj文件，用于管理项目]"></a>3.1 POM（Project Object Model）[ps:个人理解为类似于VS的csproj文件，用于管理项目]</h3><p>pom 是一个 xml，是maven工作的基础，在执行 task 或者 goal 时，maven 会去项目根目录下读取 pom.xml 获得需要的配置信息。该文件包括项目的信息和 maven build 项目所需的配置信息，通常有项目信息(如版本、成员)、项目的依赖、插件和 goal 、build 选项等等。<br>pom 是可继承的，大型项目中，子模块的 pom 需指定父模块的 pom。<br>节点定义：</p>
<ul>
<li>project：pom文件的顶级元素</li>
<li>modelVersion：所使用的object model版本，为了确保稳定的使用，这个元素是强制性的。除非maven开发者升级模板，否则不需要修改</li>
<li>groupId：是项目创建团体或组织的唯一标志符，通常是域名倒写，如groupId  org.apache.maven.plugins就是为所有maven插件预留的</li>
<li>artifactId：是项目artifact唯一的基地址名</li>
<li>packaging：artifact打包的方式，如jar、war、ear等等。默认为jar。这个不仅表示项目最终产生何种后缀的文件，也表示build过程使用什么样的lifecycle。</li>
<li>version：artifact的版本，通常能看见为类似0.0.1-SNAPSHOT，其中SNAPSHOT表示项目开发中，为开发版本</li>
<li>name：表示项目的展现名，在maven生成的文档中使用</li>
<li>url：表示项目的地址，在maven生成的文档中使用</li>
<li>description：表示项目的描述，在maven生成的文档中使用</li>
<li>dependencies：表示依赖，在子节点dependencies中添加具体依赖的groupId - artifactId和version</li>
<li>build：表示build配置</li>
<li>parent：表示父pom</li>
</ul>
<h3 id="3-2-Artifact（类似于-nuget-中的包）"><a href="#3-2-Artifact（类似于-nuget-中的包）" class="headerlink" title="3.2 Artifact（类似于 nuget 中的包）"></a>3.2 Artifact（类似于 nuget 中的包）</h3><ul>
<li>需指定项目要产生的文件，如 jar，源文件，二进制，war，pom 等，类似于 VS 中的项目类型。</li>
<li>groupId:artifactId:version 组成的标识符唯一识别，唯一确定了一个 artifact。</li>
<li>需要被使用(依赖)的 artifact 都要放在仓库(见Repository)中。</li>
</ul>
<h3 id="3-3-Repositories（仓储）"><a href="#3-3-Repositories（仓储）" class="headerlink" title="3.3 Repositories（仓储）"></a>3.3 Repositories（仓储）</h3><ul>
<li>主要用来存储 Artifact。</li>
<li>可分为本地和远程。<ul>
<li>本地对 Windows 系统存放于<code>用户/.m2/repository</code>，可修改。</li>
</ul>
</li>
</ul>
<h3 id="3-4-Build-Lifecycle（构建生存周期）"><a href="#3-4-Build-Lifecycle（构建生存周期）" class="headerlink" title="3.4 Build Lifecycle（构建生存周期）"></a>3.4 Build Lifecycle（构建生存周期）</h3><p>指一个项目的构建过程，由 phase（片段） 构成。分三种：</p>
<ul>
<li>default：处理项目的部署，大致流程：<ol>
<li>validate 验证项目是否正确以及必须的信息是否可用</li>
<li>compile 编译源代码</li>
<li>test 测试编译后的代码，即执行单元测试代码</li>
<li>package 打包编译后的代码，在target目录下生成package文件</li>
<li>integration-test 处理package以便需要时可以部署到集成测试环境</li>
<li>verify 检验package是否有效并且达到质量标准</li>
<li>install 安装package到本地仓库，方便本地其它项目使用</li>
<li>deploy 部署，拷贝最终的package到远程仓库和替他开发这或项目共享，在集成或发布环境完成</li>
</ol>
</li>
<li>clean：处理项目的清理</li>
<li>site：处理项目的文档生成</li>
</ul>
<p>注意：phase 是有序的，执行指定的 phase 时，会先执行完之前的 phase。</p>
<h3 id="3-5-Goal（任务）"><a href="#3-5-Goal（任务）" class="headerlink" title="3.5 Goal（任务）"></a>3.5 Goal（任务）</h3><p>表示一个特定的任务，区别于 build。</p>
<ul>
<li>mvn compile：编译</li>
<li>mvn package：打包</li>
<li>mvn deploy：部署</li>
<li>mvn clean install：先执行 clean 之前的 phase，在执行 clean，install。</li>
<li>mvn install：安装到本地</li>
</ul>
<h3 id="3-6-Archetype（原型）"><a href="#3-6-Archetype（原型）" class="headerlink" title="3.6 Archetype（原型）"></a>3.6 Archetype（原型）</h3><p>类似于 .net core 的项目模板</p>
<h2 id="4-常用参数"><a href="#4-常用参数" class="headerlink" title="4 常用参数"></a>4 常用参数</h2><ul>
<li>mvn -e：显示详细错误</li>
<li>mvn -U：强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖）</li>
<li>mvn -o：运行offline模式，不联网更新依赖</li>
<li>mvn -N：仅在当前项目模块执行命令，关闭reactor</li>
<li>mvn -pl：module_name在指定模块上执行命令</li>
<li>mvn -ff：在递归执行命令过程中，一旦发生错误就直接退出</li>
<li>mvn -Dxxx=yyy：指定java全局属性</li>
<li>mvn -Pxxx：引用profile xxx</li>
<li>mvn test-compile：编译测试代码</li>
<li>mvn test：运行程序中的单元测试</li>
<li>mvn compile：编译项目</li>
<li>mvn package：打包，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件</li>
<li>mvn install：打包并安装到本地仓库，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。每个phase都可以作为goal，也可以联合，如之前介绍的mvn clean install</li>
<li>mvn archetype:generate：创建maven项目</li>
<li>mvn package：打包，上面已经介绍过了</li>
<li>mvn package：-Prelease打包，并生成部署用的包，比如deploy/*.tgz</li>
<li>mvn install：打包并安装到本地库</li>
<li>mvn eclipse:eclipse：生成eclipse项目文件</li>
<li>mvn eclipse:clean：清除eclipse项目文件</li>
<li>mvn site：生成项目相关信息的网站</li>
<li>mvn -Dwtpversion=2.0：指定maven版本</li>
<li>mvn -Dmaven.test.skip=true：如果命令包含了test phase，则忽略单元测试</li>
<li>mvn -DuserProp=filePath：指定用户自定义配置文件位置</li>
<li>mvn -DdownloadSources=true -Declipse.addVersionToProjectName=true eclipse:eclipse：生成eclipse项目文件，尝试从仓库下载源代码，并且生成的项目包含模块版本（注意如果使用公用POM，上述的开关缺省已打开）</li>
<li>mvn -Dsurefire.useFile=false：如果执行单元测试出错，用该命令可以在console输出失败的单元测试及相关信息</li>
<li>set MAVEN_OPTS=-Xmx512m -XX:MaxPermSize=256m：调大jvm内存和持久代，maven/jvm out of memory error</li>
<li>mvn -X：maven log level设定为debug在运行</li>
<li>mvn debug：运行jpda允许remote debug</li>
<li>mvn –help 帮助</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://maven.apache.org/index.html" target="_blank" rel="external">Maven官网</a><br>2 <a href="http://blog.csdn.net/column/details/maven-it.html" target="_blank" rel="external">Maven入门</a><br>3 <a href="http://www.trinea.cn/android/maven/" target="_blank" rel="external">Maven介绍，包括作用、核心概念、用法、常用命令、扩展及配置</a><br>4 <a href="http://www.oracle.com/technetwork/cn/community/java/apache-maven-getting-started-1-406235-zhs.html" target="_blank" rel="external">Maven入门介绍</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;p&gt;Maven 是一个项目构建和管理的自动化工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。&lt;/p&gt;
&lt;p&gt;Maven 使用惯例优于配置的原则 。它要求在没有定制之前，所有的项目都有如下的结构：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;目的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;${basedir}&lt;/td&gt;
&lt;td&gt;存放 pom.xml和所有的子目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;${basedir}/src/main/java&lt;/td&gt;
&lt;td&gt;项目的 java源代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;${basedir}/src/main/resources&lt;/td&gt;
&lt;td&gt;项目的资源，比如说 property文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;${basedir}/src/test/java&lt;/td&gt;
&lt;td&gt;项目的测试类，比如说 JUnit代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;${basedir}/src/test/resources&lt;/td&gt;
&lt;td&gt;测试使用的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个 maven 项目在默认情况下会产生 JAR 文件，另外 ，编译后 的 classes 会放在 ${basedir}/target/classes 下面， JAR 文件会放在 ${basedir}/target 下面。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
      <category term="Maven" scheme="http://www.venux.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>java-反射</title>
    <link href="http://www.venux.cn/2018/04/09/java-%E5%8F%8D%E5%B0%84/"/>
    <id>http://www.venux.cn/2018/04/09/java-反射/</id>
    <published>2018-04-09T15:36:43.000Z</published>
    <updated>2018-05-14T02:53:19.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Class（java-lang-Class）"><a href="#1-Class（java-lang-Class）" class="headerlink" title="1 Class（java.lang.Class）"></a>1 Class（java.lang.Class）</h2><p>该类是反射的核心，获取类的Class对象引用方式：</p>
<ul>
<li>使用类文字，如Test.class、double.class（等价于Doubel.TYPE）和void.class；</li>
<li>使用Object类的getClass()方法</li>
<li>使用Class类的forName()静态方法</li>
</ul>
<a id="more"></a>
<h2 id="2-字段"><a href="#2-字段" class="headerlink" title="2 字段"></a>2 字段</h2><ul>
<li>getFields()方法返回所有可访问的公共字段在类中声明或继承自超类。</li>
<li>getDeclaredFields()方法返回所有字段只出现在类的声明中(不是从继承的字段)。</li>
<li>getField(String name)和 getDeclaredField(String name)通过字段名获取 Field 对象。</li>
</ul>
<h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h2><ul>
<li>java.lang.reflect.Method（继承自抽象类Executable） 类的实例表示一个方法。</li>
<li>java.lang.reflect.Constructor（继承自抽象类Executable） 类的实例表示一个构造函数。</li>
<li>Parameter 类：可执行文件中的参数。默认情况，参数名称不存储在类文件中，而类似于arg0,arg1。</li>
<li>TypeVariable：通用方法或构造函数的类型参数。</li>
<li>Executable类（抽象）：可执行。<ul>
<li>getParameters()：获取参数数组；</li>
<li>getExceptionTypes()：获取异常数组；</li>
<li>getTypeParameters()：获取类型参数数组；</li>
<li>getModifiers()：获取修饰符</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Method[]  getMethods()</div><div class="line">Method[]  getDeclaredMethods()：返回当前类的所有声明的构造函数。</div><div class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name,  Class...  parameterTypes)</span></span></div><div class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name,  Class...  parameterTypes)</span></span></div></pre></td></tr></table></figure>
<h2 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4 构造函数"></a>4 构造函数</h2><ul>
<li>Constructor[] getConstructors()：返回当前和超类的所有公共构造函数。</li>
<li>Constructor[]  getDeclaredConstructors()</li>
<li>Constructor<t> getConstructor(Class…  parameterTypes)</t></li>
<li>Constructor<t> getDeclaredConstructor(Class…  parameterTypes)</t></li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Class（java-lang-Class）&quot;&gt;&lt;a href=&quot;#1-Class（java-lang-Class）&quot; class=&quot;headerlink&quot; title=&quot;1 Class（java.lang.Class）&quot;&gt;&lt;/a&gt;1 Class（java.lang.Class）&lt;/h2&gt;&lt;p&gt;该类是反射的核心，获取类的Class对象引用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用类文字，如Test.class、double.class（等价于Doubel.TYPE）和void.class；&lt;/li&gt;
&lt;li&gt;使用Object类的getClass()方法&lt;/li&gt;
&lt;li&gt;使用Class类的forName()静态方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-集合</title>
    <link href="http://www.venux.cn/2018/04/09/java-%E9%9B%86%E5%90%88/"/>
    <id>http://www.venux.cn/2018/04/09/java-集合/</id>
    <published>2018-04-09T13:43:16.000Z</published>
    <updated>2018-05-14T02:53:19.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-集合遍历"><a href="#1-集合遍历" class="headerlink" title="1 集合遍历"></a>1 集合遍历</h2><h3 id="1-1-迭代器（实现-Iterator-接口的实例）"><a href="#1-1-迭代器（实现-Iterator-接口的实例）" class="headerlink" title="1.1 迭代器（实现 Iterator 接口的实例）"></a>1.1 迭代器（实现 Iterator<e> 接口的实例）</e></h3><ul>
<li>检查是否有尚未访问的元素。</li>
<li>访问集合中的下一个元素。</li>
<li>删除集合的最后访问元素。</li>
</ul>
<h3 id="1-2-for-each循环"><a href="#1-2-for-each循环" class="headerlink" title="1.2 for-each循环"></a>1.2 for-each循环</h3><ul>
<li>for-each循环遍历任何实现类实现Iterable接口的集合。</li>
</ul>
<p><code>ps:</code>不能使用for-each循环从集合中删除元素，将抛出ConcurrentModificationException异常。</p>
<h3 id="1-3-forEach-方法"><a href="#1-3-forEach-方法" class="headerlink" title="1.3 forEach()方法"></a>1.3 forEach()方法</h3><ul>
<li>Iterable接口包含一个新的 forEach(Consumer action)方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// Create a list of strings</span></div><div class="line">    List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    names.add(<span class="string">"A"</span>);</div><div class="line">    names.add(<span class="string">"B"</span>);</div><div class="line">    names.add(<span class="string">"C"</span>);</div><div class="line"></div><div class="line">    names.forEach(System.out::println);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-集合（Set接口）（唯一对象的集合）"><a href="#2-集合（Set接口）（唯一对象的集合）" class="headerlink" title="2 集合（Set接口）（唯一对象的集合）"></a>2 集合（Set接口）（唯一对象的集合）</h3><ul>
<li>集合是唯一元素的集合。当向集合添加重复元素时，它们将被忽略。</li>
<li>Java最多允许一个Set中的一个空元素。 </li>
<li>Set 中元素的排序并不重要。Java不保证 Set 中元素的排序。</li>
</ul>
<h3 id="2-1-数学集"><a href="#2-1-数学集" class="headerlink" title="2.1 数学集"></a>2.1 数学集</h3><ul>
<li>HashSet 类：不保证顺序元素</li>
<li>LinkedHashSet 类：保证插入元素顺序</li>
</ul>
<h3 id="2-2-排序集"><a href="#2-2-排序集" class="headerlink" title="2.2 排序集"></a>2.2 排序集</h3><p>SortedSet 接口表示Java集合中的排序集合框架。</p>
<ul>
<li>元素实现Comparable接口，将使用compareTo()方法排序，称之为自然排序；</li>
<li>传递一个比较器自定义排序；</li>
<li>若指定Comparator，则用Comparator排序而忽略Comparable。</li>
<li>TreeSet是SortedSet接口的一个实现。</li>
</ul>
<h3 id="2-3-导航集（有序集）"><a href="#2-3-导航集（有序集）" class="headerlink" title="2.3 导航集（有序集）"></a>2.3 导航集（有序集）</h3><p>NavigableSet 表示Java集合中的可导航集合框架。NavigableSet 接口继承了SortedSet接口和扩展 SortedSet 。</p>
<ul>
<li>TreeSet 类是 NavigableSet 接口的实现类之一。</li>
</ul>
<h2 id="3-列表（List接口）（有序、可重复）"><a href="#3-列表（List接口）（有序、可重复）" class="headerlink" title="3 列表（List接口）（有序、可重复）"></a>3 列表（List接口）（有序、可重复）</h2><ul>
<li>ArrayList：访问快，添加删除慢</li>
<li>LinkedList：访问慢，添加删除快</li>
<li>LinkIterator接口（继承Iterator接口）遍历列表</li>
</ul>
<h2 id="4-队列（Queue接口）（先进先出FIFO）"><a href="#4-队列（Queue接口）（先进先出FIFO）" class="headerlink" title="4 队列（Queue接口）（先进先出FIFO）"></a>4 队列（Queue接口）（先进先出FIFO）</h2><ul>
<li>LinkedList：简单的队列允许在尾部插入和从头部移除。</li>
<li>PriorityQueue：优先级队列为每个元素分配优先级，并允许从队列中删除具有最高优先级的元素。</li>
<li>DelayQueue：延迟队列向每个元素添加延迟，并仅在其延迟已过去时删除该元素。</li>
<li>Deque、ArrayDeque、LinkedList（FIFO或LIFO）：双端队列允许其元件从头部和尾部插入和移除。</li>
<li>BlockingQueue接口（线程安全、适用于生产者/消费者）、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue：阻塞队列阻塞线程，当线程已满时向其添加元素，当线程为空时，它阻止线程从中删除元素。</li>
<li>TransferQueue：传输队列是阻塞队列，其中对象的切换发生在生产者线程和消费者线程之间。</li>
<li>阻塞双端队列是双端队列和阻塞队列的组合。</li>
</ul>
<h2 id="5-映射（Map接口）-（键不能重复）"><a href="#5-映射（Map接口）-（键不能重复）" class="headerlink" title="5 映射（Map接口） （键不能重复）"></a>5 映射（Map<k,v>接口） （键不能重复）</k,v></h2><ul>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>WeakHashMap</li>
</ul>
<h2 id="6-Collection-类"><a href="#6-Collection-类" class="headerlink" title="6 Collection 类"></a>6 Collection 类</h2><p>该类中包含许多静态的辅助方法用于处理集合，如排序、搜索等。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-集合遍历&quot;&gt;&lt;a href=&quot;#1-集合遍历&quot; class=&quot;headerlink&quot; title=&quot;1 集合遍历&quot;&gt;&lt;/a&gt;1 集合遍历&lt;/h2&gt;&lt;h3 id=&quot;1-1-迭代器（实现-Iterator-接口的实例）&quot;&gt;&lt;a href=&quot;#1-1-迭代器（实现-Iterator-接口的实例）&quot; class=&quot;headerlink&quot; title=&quot;1.1 迭代器（实现 Iterator 接口的实例）&quot;&gt;&lt;/a&gt;1.1 迭代器（实现 Iterator&lt;e&gt; 接口的实例）&lt;/e&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;检查是否有尚未访问的元素。&lt;/li&gt;
&lt;li&gt;访问集合中的下一个元素。&lt;/li&gt;
&lt;li&gt;删除集合的最后访问元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-for-each循环&quot;&gt;&lt;a href=&quot;#1-2-for-each循环&quot; class=&quot;headerlink&quot; title=&quot;1.2 for-each循环&quot;&gt;&lt;/a&gt;1.2 for-each循环&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;for-each循环遍历任何实现类实现Iterable接口的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ps:&lt;/code&gt;不能使用for-each循环从集合中删除元素，将抛出ConcurrentModificationException异常。&lt;/p&gt;
&lt;h3 id=&quot;1-3-forEach-方法&quot;&gt;&lt;a href=&quot;#1-3-forEach-方法&quot; class=&quot;headerlink&quot; title=&quot;1.3 forEach()方法&quot;&gt;&lt;/a&gt;1.3 forEach()方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Iterable接口包含一个新的 forEach(Consumer action)方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Create a list of strings&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    List&amp;lt;String&amp;gt; names = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    names.add(&lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    names.add(&lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    names.add(&lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    names.forEach(System.out::println);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java各版本新特性</title>
    <link href="http://www.venux.cn/2018/04/01/Java%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://www.venux.cn/2018/04/01/Java各版本新特性/</id>
    <published>2018-04-01T14:45:48.000Z</published>
    <updated>2018-05-14T02:53:19.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java8-新特性（2014-3-18）"><a href="#1-Java8-新特性（2014-3-18）" class="headerlink" title="1 Java8 新特性（2014/3/18）"></a>1 Java8 新特性（2014/3/18）</h2><ul>
<li><p><strong>Lambda 表达式</strong> − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 java 7 排序</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortUsingJava7</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;   </div><div class="line">  Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> s1.compareTo(s2);</div><div class="line">      &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用 java 8 排序</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortUsingJava8</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;</div><div class="line">  Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
</li>
<li><p><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">      Vehicle vehicle = <span class="keyword">new</span> Car();</div><div class="line">      vehicle.print();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blowHorn</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"按喇叭!!!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FourWheeler</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"我是一辆四轮车!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span>, <span class="title">FourWheeler</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">      Vehicle.<span class="keyword">super</span>.print();</div><div class="line">      FourWheeler.<span class="keyword">super</span>.print();</div><div class="line">      Vehicle.blowHorn();</div><div class="line">      System.out.println(<span class="string">"我是一辆汽车!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</p>
</li>
<li><p><strong>Stream API（链式编程）</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。  </li>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</div><div class="line">List&lt;String&gt; filtered = strings.stream()</div><div class="line">                                .filter(string -&gt; !string.isEmpty())</div><div class="line">                                .collect(Collectors.toList());</div><div class="line"> </div><div class="line">System.out.println(<span class="string">"筛选列表: "</span> + filtered);</div><div class="line">String mergedString = strings.stream()</div><div class="line">                              .filter(string -&gt; !string.isEmpty())</div><div class="line">                              .collect(Collectors.joining(<span class="string">", "</span>));</div><div class="line">System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Date Time API − 加强对日期与时间的处理。</p>
</li>
<li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
<a id="more"></a>
<h1 id="2-Java9-新特性（）"><a href="#2-Java9-新特性（）" class="headerlink" title="2 Java9 新特性（）"></a>2 Java9 新特性（）</h1><h1 id="3-Java10-新特性（2018-3-20）"><a href="#3-Java10-新特性（2018-3-20）" class="headerlink" title="3 Java10 新特性（2018/3/20）"></a>3 Java10 新特性（2018/3/20）</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Java8-新特性（2014-3-18）&quot;&gt;&lt;a href=&quot;#1-Java8-新特性（2014-3-18）&quot; class=&quot;headerlink&quot; title=&quot;1 Java8 新特性（2014/3/18）&quot;&gt;&lt;/a&gt;1 Java8 新特性（2014/3/18）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Lambda 表达式&lt;/strong&gt; − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 java 7 排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sortUsingJava7&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;String&amp;gt; names)&lt;/span&gt;&lt;/span&gt;&amp;#123;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Collections.sort(names, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Comparator&amp;lt;String&amp;gt;() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String s1, String s2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s1.compareTo(s2);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 java 8 排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sortUsingJava8&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;String&amp;gt; names)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Collections.sort(names, (s1, s2) -&amp;gt; s1.compareTo(s2));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;方法引用&lt;/strong&gt; − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;默认方法&lt;/strong&gt; − 默认方法就是一个在接口里面有了一个实现的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Java8Tester&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String args[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      Vehicle vehicle = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Car();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      vehicle.print();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Vehicle&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;我是一辆车!&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;blowHorn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;按喇叭!!!&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FourWheeler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;我是一辆四轮车!&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Vehicle&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;FourWheeler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      Vehicle.&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.print();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      FourWheeler.&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.print();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      Vehicle.blowHorn();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;我是一辆汽车!&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Stream API（链式编程）&lt;/strong&gt; −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。&lt;/li&gt;
&lt;li&gt;数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。&lt;/li&gt;
&lt;li&gt;聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。  &lt;/li&gt;
&lt;li&gt;Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。&lt;/li&gt;
&lt;li&gt;内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt;strings = Arrays.asList(&lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bc&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;efg&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;abcd&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;jkl&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; filtered = strings.stream()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                .filter(string -&amp;gt; !string.isEmpty())&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                .collect(Collectors.toList());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;筛选列表: &quot;&lt;/span&gt; + filtered);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String mergedString = strings.stream()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                              .filter(string -&amp;gt; !string.isEmpty())&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                              .collect(Collectors.joining(&lt;span class=&quot;string&quot;&gt;&quot;, &quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;合并字符串: &quot;&lt;/span&gt; + mergedString);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Date Time API − 加强对日期与时间的处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。&lt;/li&gt;
&lt;li&gt;Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识02</title>
    <link href="http://www.venux.cn/2018/03/29/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8602/"/>
    <id>http://www.venux.cn/2018/03/29/Java基础知识02/</id>
    <published>2018-03-29T14:01:27.000Z</published>
    <updated>2018-05-14T02:53:19.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-枚举（Enumeration）"><a href="#1-1-枚举（Enumeration）" class="headerlink" title="1.1 枚举（Enumeration）"></a>1.1 枚举（Enumeration）</h3><p>定义了一种从数据结构中取回连续元素的方式，已被迭代器取代。</p>
<h3 id="1-2-位集合（BitSet）"><a href="#1-2-位集合（BitSet）" class="headerlink" title="1.2 位集合（BitSet）"></a>1.2 位集合（BitSet）</h3><p>实现了一组可以单独设置和清除的位或标志。该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</p>
<h3 id="1-3-向量（Vector）"><a href="#1-3-向量（Vector）" class="headerlink" title="1.3 向量（Vector）"></a>1.3 向量（Vector）</h3><ul>
<li>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。</li>
<li>和数组一样，Vector对象的元素也能通过索引访问。</li>
<li>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</li>
</ul>
<h3 id="1-4-栈（Stack）"><a href="#1-4-栈（Stack）" class="headerlink" title="1.4 栈（Stack）"></a>1.4 栈（Stack）</h3><p>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</p>
<h3 id="1-5-字典（Dictionary）（已过时，使用Map接口替代）"><a href="#1-5-字典（Dictionary）（已过时，使用Map接口替代）" class="headerlink" title="1.5 字典（Dictionary）（已过时，使用Map接口替代）"></a>1.5 字典（Dictionary）（已过时，使用Map接口替代）</h3><p>字典（Dictionary） 类是一个<strong>抽象类</strong>，它定义了键映射到值的数据结构。</p>
<h3 id="1-6-哈希表（Hashtable）"><a href="#1-6-哈希表（Hashtable）" class="headerlink" title="1.6 哈希表（Hashtable）"></a>1.6 哈希表（Hashtable）</h3><p>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。</p>
<h3 id="1-7-属性（Properties）"><a href="#1-7-属性（Properties）" class="headerlink" title="1.7 属性（Properties）"></a>1.7 属性（Properties）</h3><p>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</p>
<a id="more"></a>
<h2 id="2-集合框架"><a href="#2-集合框架" class="headerlink" title="2 集合框架"></a>2 <strong>集合框架</strong></h2><p>集合框架是一个用来代表和操纵集合的统一架构。</p>
<h3 id="2-1-设计目标"><a href="#2-1-设计目标" class="headerlink" title="2.1 设计目标"></a>2.1 设计目标</h3><ul>
<li>高性能,基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。</li>
</ul>
<h3 id="2-2-内容"><a href="#2-2-内容" class="headerlink" title="2.2 内容"></a>2.2 内容</h3><ul>
<li>接口：是代表集合的抽象数据类型。接口允许集合独立操纵其代表的细节。在面向对象的语言，接口通常形成一个层次。</li>
<li>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。</li>
<li>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li>
</ul>
<h3 id="2-3-集合接口"><a href="#2-3-集合接口" class="headerlink" title="2.3 集合接口"></a>2.3 集合接口</h3><table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Collection 接口</td>
<td>允许你使用一组对象，是Collection层次结构的根接口。</td>
</tr>
<tr>
<td>List 接口</td>
<td>继承于Collection和一个 List实例存储一个有序集合的元素。</td>
</tr>
<tr>
<td>Set</td>
<td>继承于 Collection，是一个不包含重复元素的集合。</td>
</tr>
<tr>
<td>SortedSet</td>
<td>继承于Set保存有序的集合。</td>
</tr>
<tr>
<td>Map</td>
<td>将唯一的键映射到值。</td>
</tr>
<tr>
<td>Map.Entry</td>
<td>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</td>
</tr>
<tr>
<td>SortedMap</td>
<td>继承于Map，使Key保持在升序排列。</td>
</tr>
<tr>
<td>Enumeration</td>
<td>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</td>
</tr>
</tbody>
</table>
<h3 id="2-4-集合类"><a href="#2-4-集合类" class="headerlink" title="2.4 集合类"></a>2.4 集合类</h3><table>
<thead>
<tr>
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbstractCollection</td>
<td>实现了大部分的集合接口。</td>
</tr>
<tr>
<td>AbstractList</td>
<td>继承于AbstractCollection 并且实现了大部分List接口。</td>
</tr>
<tr>
<td>AbstractSequentialList</td>
<td>继承于AbstractList，提供了对数据元素的链式访问而不是随机访问。</td>
</tr>
<tr>
<td>LinkedList</td>
<td>继承于 AbstractSequentialList，实现了一个链表。</td>
</tr>
<tr>
<td>ArrayList</td>
<td>通过继承AbstractList，实现动态数组。</td>
</tr>
<tr>
<td>AbstractSet</td>
<td>继承于AbstractCollection 并且实现了大部分Set接口。</td>
</tr>
<tr>
<td>HashSet</td>
<td>继承了AbstractSet，并且使用一个哈希表。</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。</td>
</tr>
<tr>
<td>TreeSet</td>
<td>继承于AbstractSet，使用元素的自然顺序对元素进行排序.</td>
</tr>
<tr>
<td>AbstractMap</td>
<td>实现了大部分的Map接口。</td>
</tr>
<tr>
<td>HashMap</td>
<td>继承了HashMap，并且使用一个哈希表。</td>
</tr>
<tr>
<td>TreeMap</td>
<td>继承了AbstractMap，并且使用一颗树。</td>
</tr>
<tr>
<td>WeakHashMap</td>
<td>继承AbstractMap类，使用弱密钥的哈希表。</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>继承于HashMap，使用元素的自然顺序对元素进行排序.</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>继承AbstractMap类，比较文档时使用引用相等。</td>
</tr>
</tbody>
</table>
<h2 id="3-序列化"><a href="#3-序列化" class="headerlink" title="3 序列化"></a>3 序列化</h2><ul>
<li>一个类的对象要想序列化成功，必须满足两个条件：<ul>
<li>该类必须实现 java.io.Serializable 对象。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的（transient ）。</li>
</ul>
</li>
<li><p>ObjectOutputStream（writeObject）—：序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException</span></div></pre></td></tr></table></figure>
</li>
<li><p>ObjectInputStream（readObject）：反序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4 网络编程"></a>4 网络编程</h2><h3 id="4-1-网络协议（java-net）"><a href="#4-1-网络协议（java-net）" class="headerlink" title="4.1 网络协议（java.net）"></a>4.1 网络协议（java.net）</h3><ul>
<li>TCP： TCP是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称TCP / IP。</li>
<li>UDP:UDP是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。</li>
</ul>
<h3 id="4-2-Socket（java-net-Socket）"><a href="#4-2-Socket（java-net-Socket）" class="headerlink" title="4.2 Socket（java.net.Socket）"></a>4.2 Socket（java.net.Socket）</h3><p>主要使用ServerSocket和Socket类</p>
<ul>
<li><ol>
<li>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</li>
</ol>
</li>
<li><ol>
<li>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li>
</ol>
</li>
<li><ol>
<li>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</li>
</ol>
</li>
<li><ol>
<li>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</li>
</ol>
</li>
<li><ol>
<li>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</li>
</ol>
</li>
</ul>
<h2 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5 多线程"></a>5 多线程</h2><h3 id="5-1-线程的生命周期"><a href="#5-1-线程的生命周期" class="headerlink" title="5.1 线程的生命周期"></a>5.1 线程的生命周期</h3><p><img src="/images/posts/Java_Thread.jpg" alt="Thread"></p>
<ul>
<li>新建状态:使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</li>
<li>就绪状态:当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</li>
<li>运行状态:如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</li>
<li>阻塞状态:如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
</li>
<li>死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</li>
</ul>
<h3 id="5-2-线程的优先级"><a href="#5-2-线程的优先级" class="headerlink" title="5.2 线程的优先级"></a>5.2 线程的优先级</h3><ul>
<li>线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</li>
<li>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</li>
</ul>
<h3 id="5-3-创建线程"><a href="#5-3-创建线程" class="headerlink" title="5.3 创建线程"></a>5.3 创建线程</h3><ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<h2 id="6-文档注释"><a href="#6-文档注释" class="headerlink" title="6 文档注释"></a>6 文档注释</h2><h3 id="6-1-javadoc-标签"><a href="#6-1-javadoc-标签" class="headerlink" title="6.1 javadoc 标签"></a>6.1 javadoc 标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>@author</td>
<td>标识一个类的作者</td>
<td>@author description</td>
</tr>
<tr>
<td>@deprecated</td>
<td>指名一个过期的类或成员</td>
<td>@deprecated description</td>
</tr>
<tr>
<td>{@docRoot}</td>
<td>指明当前文档根目录的路径</td>
<td>Directory Path</td>
</tr>
<tr>
<td>@exception</td>
<td>标志一个类抛出的异常</td>
<td>@exception exception-name explanation</td>
</tr>
<tr>
<td>{@inheritDoc}</td>
<td>从直接父类继承的注释</td>
<td>Inherits a comment from the immediate surperclass.</td>
</tr>
<tr>
<td>{@link}</td>
<td>插入一个到另一个主题的链接</td>
<td>{@link name text}</td>
</tr>
<tr>
<td>{@linkplain}</td>
<td>插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td>Inserts an in-line link to another topic.</td>
</tr>
<tr>
<td>@param</td>
<td>说明一个方法的参数</td>
<td>@param parameter-name explanation</td>
</tr>
<tr>
<td>@return</td>
<td>说明返回值类型</td>
<td>@return explanation</td>
</tr>
<tr>
<td>@see</td>
<td>指定一个到另一个主题的链接</td>
<td>@see anchor</td>
</tr>
<tr>
<td>@serial</td>
<td>说明一个序列化属性</td>
<td>@serial description</td>
</tr>
<tr>
<td>@serialData</td>
<td>说明通过writeObject( ) 和 writeExternal( )方法写的数据</td>
<td>@serialData description</td>
</tr>
<tr>
<td>@serialField</td>
<td>说明一个ObjectStreamField组件</td>
<td>@serialField name type description</td>
</tr>
<tr>
<td>@since</td>
<td>标记当引入一个特定的变化时</td>
<td>@since release</td>
</tr>
<tr>
<td>@throws</td>
<td>和 @exception标签一样.</td>
<td>The @throws tag has the same meaning as the @exception tag.</td>
</tr>
<tr>
<td>{@value}</td>
<td>显示常量的值，该常量必须是static属性。</td>
<td>Displays the value of a constant, which must be a static field.</td>
</tr>
<tr>
<td>@version</td>
<td>指定类的版本</td>
<td>@version info</td>
</tr>
</tbody>
</table>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-数据结构&quot;&gt;&lt;a href=&quot;#1-数据结构&quot; class=&quot;headerlink&quot; title=&quot;1 数据结构&quot;&gt;&lt;/a&gt;1 数据结构&lt;/h2&gt;&lt;h3 id=&quot;1-1-枚举（Enumeration）&quot;&gt;&lt;a href=&quot;#1-1-枚举（Enumeration）&quot; class=&quot;headerlink&quot; title=&quot;1.1 枚举（Enumeration）&quot;&gt;&lt;/a&gt;1.1 枚举（Enumeration）&lt;/h3&gt;&lt;p&gt;定义了一种从数据结构中取回连续元素的方式，已被迭代器取代。&lt;/p&gt;
&lt;h3 id=&quot;1-2-位集合（BitSet）&quot;&gt;&lt;a href=&quot;#1-2-位集合（BitSet）&quot; class=&quot;headerlink&quot; title=&quot;1.2 位集合（BitSet）&quot;&gt;&lt;/a&gt;1.2 位集合（BitSet）&lt;/h3&gt;&lt;p&gt;实现了一组可以单独设置和清除的位或标志。该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。&lt;/p&gt;
&lt;h3 id=&quot;1-3-向量（Vector）&quot;&gt;&lt;a href=&quot;#1-3-向量（Vector）&quot; class=&quot;headerlink&quot; title=&quot;1.3 向量（Vector）&quot;&gt;&lt;/a&gt;1.3 向量（Vector）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。&lt;/li&gt;
&lt;li&gt;和数组一样，Vector对象的元素也能通过索引访问。&lt;/li&gt;
&lt;li&gt;使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-4-栈（Stack）&quot;&gt;&lt;a href=&quot;#1-4-栈（Stack）&quot; class=&quot;headerlink&quot; title=&quot;1.4 栈（Stack）&quot;&gt;&lt;/a&gt;1.4 栈（Stack）&lt;/h3&gt;&lt;p&gt;栈（Stack）实现了一个后进先出（LIFO）的数据结构。&lt;/p&gt;
&lt;h3 id=&quot;1-5-字典（Dictionary）（已过时，使用Map接口替代）&quot;&gt;&lt;a href=&quot;#1-5-字典（Dictionary）（已过时，使用Map接口替代）&quot; class=&quot;headerlink&quot; title=&quot;1.5 字典（Dictionary）（已过时，使用Map接口替代）&quot;&gt;&lt;/a&gt;1.5 字典（Dictionary）（已过时，使用Map接口替代）&lt;/h3&gt;&lt;p&gt;字典（Dictionary） 类是一个&lt;strong&gt;抽象类&lt;/strong&gt;，它定义了键映射到值的数据结构。&lt;/p&gt;
&lt;h3 id=&quot;1-6-哈希表（Hashtable）&quot;&gt;&lt;a href=&quot;#1-6-哈希表（Hashtable）&quot; class=&quot;headerlink&quot; title=&quot;1.6 哈希表（Hashtable）&quot;&gt;&lt;/a&gt;1.6 哈希表（Hashtable）&lt;/h3&gt;&lt;p&gt;Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。&lt;/p&gt;
&lt;h3 id=&quot;1-7-属性（Properties）&quot;&gt;&lt;a href=&quot;#1-7-属性（Properties）&quot; class=&quot;headerlink&quot; title=&quot;1.7 属性（Properties）&quot;&gt;&lt;/a&gt;1.7 属性（Properties）&lt;/h3&gt;&lt;p&gt;Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java环境变量配置</title>
    <link href="http://www.venux.cn/2018/03/25/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.venux.cn/2018/03/25/Java环境变量配置/</id>
    <published>2018-03-25T14:42:39.000Z</published>
    <updated>2018-05-14T02:53:19.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java下载"><a href="#1-Java下载" class="headerlink" title="1 Java下载"></a>1 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">Java下载</a></h2><h2 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2 环境变量配置"></a>2 环境变量配置</h2><ol>
<li><strong>JAVA_HOME</strong>:C:\Program Files\Java\jdk1.8.0_144（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%JAVA_HOME%\bin;</li>
<li><strong>CLASS_PATH</strong>:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</li>
</ol>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h2><ul>
<li><strong>java-version</strong>:版本号</li>
<li><strong>java</strong>:Java环境</li>
<li><strong>javac</strong>:Java编译器</li>
</ul>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Java下载&quot;&gt;&lt;a href=&quot;#1-Java下载&quot; class=&quot;headerlink&quot; title=&quot;1 Java下载&quot;&gt;&lt;/a&gt;1 &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java下载&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;2-环境变量配置&quot;&gt;&lt;a href=&quot;#2-环境变量配置&quot; class=&quot;headerlink&quot; title=&quot;2 环境变量配置&quot;&gt;&lt;/a&gt;2 环境变量配置&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JAVA_HOME&lt;/strong&gt;:C:\Program Files\Java\jdk1.8.0_144（注：结尾不加分号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PATH&lt;/strong&gt;:%JAVA_HOME%\bin;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLASS_PATH&lt;/strong&gt;:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;3-测试&quot;&gt;&lt;a href=&quot;#3-测试&quot; class=&quot;headerlink&quot; title=&quot;3 测试&quot;&gt;&lt;/a&gt;3 测试&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;java-version&lt;/strong&gt;:版本号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;java&lt;/strong&gt;:Java环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;javac&lt;/strong&gt;:Java编译器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识01</title>
    <link href="http://www.venux.cn/2018/03/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/"/>
    <id>http://www.venux.cn/2018/03/25/Java基础知识01/</id>
    <published>2018-03-25T14:41:06.000Z</published>
    <updated>2018-05-14T02:53:19.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Hello-World-示例"><a href="#1-Hello-World-示例" class="headerlink" title="1 Hello World 示例"></a>1 Hello World 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello World"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ps:</code></p>
<ul>
<li>Java 中类名（CamelCase 风格）要与文件名保持一致；</li>
<li>Java 中方法名 camelCase 风格；</li>
<li>main 主函数参数默认为 String []；</li>
</ul>
<a id="more"></a>
<h2 id="2-Java-标识符"><a href="#2-Java-标识符" class="headerlink" title="2 Java 标识符"></a>2 Java 标识符</h2><ul>
<li>所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始</li>
</ul>
<h2 id="3-Java-变量"><a href="#3-Java-变量" class="headerlink" title="3 Java 变量"></a>3 Java 变量</h2><ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<h2 id="4-Java-关键字"><a href="#4-Java-关键字" class="headerlink" title="4 Java 关键字"></a>4 Java 关键字</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract</td>
<td>抽象方法，抽象类的修饰符</td>
</tr>
<tr>
<td>assert</td>
<td>断言条件是否满足</td>
</tr>
<tr>
<td>boolean</td>
<td>布尔数据类型</td>
</tr>
<tr>
<td>break</td>
<td>跳出循环或者label代码段</td>
</tr>
<tr>
<td>byte</td>
<td>8-bit 有符号数据类型</td>
</tr>
<tr>
<td>case</td>
<td>switch语句的一个条件</td>
</tr>
<tr>
<td>catch</td>
<td>try搭配捕捉异常信息</td>
</tr>
<tr>
<td>char</td>
<td>16-bit Unicode字符数据类型</td>
</tr>
<tr>
<td>class</td>
<td>定义类</td>
</tr>
<tr>
<td>const</td>
<td>未使用</td>
</tr>
<tr>
<td>continue</td>
<td>不执行循环体剩余部分</td>
</tr>
<tr>
<td>default</td>
<td>switch语句中的默认分支</td>
</tr>
<tr>
<td>do</td>
<td>循环语句，循环体至少会执行一次</td>
</tr>
<tr>
<td>double</td>
<td>64-bit双精度浮点数</td>
</tr>
<tr>
<td>else</td>
<td>if条件不成立时执行的分支</td>
</tr>
<tr>
<td>enum</td>
<td>枚举类型</td>
</tr>
<tr>
<td>extends</td>
<td>表示一个类是另一个类的子类</td>
</tr>
<tr>
<td>final</td>
<td>表示一个值在初始化之后就不能再改变了或表示方法不能被重写，或者一个类不能有子类</td>
</tr>
<tr>
<td>finally</td>
<td>为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。</td>
</tr>
<tr>
<td>float</td>
<td>32-bit单精度浮点数</td>
</tr>
<tr>
<td>for</td>
<td>for循环语句</td>
</tr>
<tr>
<td>goto</td>
<td>未使用</td>
</tr>
<tr>
<td>if</td>
<td>条件语句</td>
</tr>
<tr>
<td>implements</td>
<td>表示一个类实现了接口</td>
</tr>
<tr>
<td>import</td>
<td>导入类</td>
</tr>
<tr>
<td><strong>instanceof</strong></td>
<td>测试一个对象是否是某个类的实例</td>
</tr>
<tr>
<td>int</td>
<td>32位整型数</td>
</tr>
<tr>
<td>interface</td>
<td>接口，一种抽象的类型，仅有方法和常量的定义</td>
</tr>
<tr>
<td>long</td>
<td>64位整型数</td>
</tr>
<tr>
<td><strong>native</strong></td>
<td>表示方法用非java代码实现</td>
</tr>
<tr>
<td>new</td>
<td>分配新的类实例</td>
</tr>
<tr>
<td>package</td>
<td>一系列相关类组成一个包</td>
</tr>
<tr>
<td>private</td>
<td>表示私有字段，或者方法等，只能从类内部访问</td>
</tr>
<tr>
<td>protected</td>
<td>表示字段只能通过类或者其子类访问子类或者在同一个包内的其他类</td>
</tr>
<tr>
<td>public</td>
<td>表示共有属性或者方法</td>
</tr>
<tr>
<td>return</td>
<td>方法返回值</td>
</tr>
<tr>
<td>short</td>
<td>16位数字</td>
</tr>
<tr>
<td>static</td>
<td>表示在类级别定义，所有实例共享的</td>
</tr>
<tr>
<td><strong>strictfp</strong></td>
<td>浮点数比较使用严格的规则</td>
</tr>
<tr>
<td>super</td>
<td>表示基类</td>
</tr>
<tr>
<td>switch</td>
<td>选择语句</td>
</tr>
<tr>
<td><strong>synchronized</strong></td>
<td>表示同一时间只能由一个线程访问的代码块</td>
</tr>
<tr>
<td>this</td>
<td>表示调用当前实例或者调用另一个构造函数</td>
</tr>
<tr>
<td>throw</td>
<td>抛出异常</td>
</tr>
<tr>
<td><strong>throws</strong></td>
<td>定义方法可能抛出的异常</td>
</tr>
<tr>
<td><strong>transient</strong></td>
<td>修饰不要序列化的字段</td>
</tr>
<tr>
<td>try</td>
<td>表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码</td>
</tr>
<tr>
<td>void</td>
<td>标记方法不返回任何值</td>
</tr>
<tr>
<td><strong>volatile</strong></td>
<td>标记字段可能会被多个线程同时访问，而不做同步</td>
</tr>
<tr>
<td>while</td>
<td>while循环</td>
</tr>
</tbody>
</table>
<h2 id="5-类-amp-对象"><a href="#5-类-amp-对象" class="headerlink" title="5 类&amp;对象"></a>5 类&amp;对象</h2><ul>
<li>对象：对象是类的一个实例，有状态和行为。</li>
<li>类：类是一个模板，它描述一类对象的行为和状态。</li>
<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li>
</ul>
<h2 id="6-源文件"><a href="#6-源文件" class="headerlink" title="6 源文件"></a>6 源文件</h2><ul>
<li>一个源文件中只能有一个 public 类</li>
<li>一个源文件可以有多个非 public 类</li>
<li>源文件的名称应该和 public 类的类名保持一致</li>
<li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li>
<li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li>
<li>import 语句和 package 语句对源文件中定义的所有类都有效。</li>
</ul>
<h2 id="7-基本数据类型"><a href="#7-基本数据类型" class="headerlink" title="7 基本数据类型"></a>7 基本数据类型</h2><p>八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br><em>PS:</em>字符串不属于基本类型。</p>
<h3 id="7-1-byte（java-lang-Byte）"><a href="#7-1-byte（java-lang-Byte）" class="headerlink" title="7.1 byte（java.lang.Byte）"></a>7.1 byte（java.lang.Byte）</h3><ul>
<li>byte数据类型是8位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是-128（-2^7）；</li>
<li>最大值是127（2^7-1）；</li>
<li>默认值是0；</li>
<li>byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；</li>
</ul>
<h3 id="7-2-short（java-lang-Short）"><a href="#7-2-short（java-lang-Short）" class="headerlink" title="7.2 short（java.lang.Short）"></a>7.2 short（java.lang.Short）</h3><ul>
<li>short数据类型是16位、有符号的以二进制补码表示的整数</li>
<li>最小值是-32768（-2^15）；</li>
<li>最大值是32767（2^15 - 1）；</li>
<li>Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
<li>默认值是0；</li>
</ul>
<h3 id="7-3-int（java-lang-Integer）"><a href="#7-3-int（java-lang-Integer）" class="headerlink" title="7.3 int（java.lang.Integer）"></a>7.3 int（java.lang.Integer）</h3><ul>
<li>int数据类型是32位、有符号的以二进制补码表示的整数；</li>
<li>最小值是-2,147,483,648（-2^31）；</li>
<li>最大值是2,147,483,647（2^31 - 1）；</li>
<li>一般地整型变量默认为int类型；</li>
<li>默认值是0；</li>
</ul>
<h3 id="7-4-long（java-lang-Long）"><a href="#7-4-long（java-lang-Long）" class="headerlink" title="7.4 long（java.lang.Long）"></a>7.4 long（java.lang.Long）</h3><ul>
<li>long数据类型是64位、有符号的以二进制补码表示的整数；</li>
<li>最小值是-9,223,372,036,854,775,808（-2^63）；</li>
<li>最大值是9,223,372,036,854,775,807（2^63 -1）；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是0L；</li>
</ul>
<h3 id="7-5-float（java-lang-Float）"><a href="#7-5-float（java-lang-Float）" class="headerlink" title="7.5 float（java.lang.Float）"></a>7.5 float（java.lang.Float）</h3><ul>
<li>float数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
<li>float在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是0.0f；</li>
<li><strong>浮点数不能用来表示精确的值</strong>，如货币；</li>
</ul>
<h3 id="7-6-double（java-lang-Double）"><a href="#7-6-double（java-lang-Double）" class="headerlink" title="7.6 double（java.lang.Double）"></a>7.6 double（java.lang.Double）</h3><ul>
<li>double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</li>
<li>浮点数的默认类型为double类型；</li>
<li><strong>double类型同样不能表示精确的值</strong>，如货币；</li>
</ul>
<h3 id="7-7-boolean"><a href="#7-7-boolean" class="headerlink" title="7.7 boolean"></a>7.7 boolean</h3><ul>
<li>boolean数据类型表示一位的信息；</li>
<li>只有两个取值：true和false；</li>
<li>这种类型只作为一种标志来记录true/false情况；</li>
<li>默认值是false；</li>
</ul>
<h3 id="7-8-char（java-lang-Character）"><a href="#7-8-char（java-lang-Character）" class="headerlink" title="7.8 char（java.lang.Character）"></a>7.8 char（java.lang.Character）</h3><ul>
<li>char类型是一个单一的16位Unicode字符；</li>
<li>最小值是’\u0000’（即为0）；</li>
<li>最大值是’\uffff’（即为65,535）；</li>
<li>char数据类型可以储存任何字符；</li>
</ul>
<h3 id="7-9-void（java-lang-Void）"><a href="#7-9-void（java-lang-Void）" class="headerlink" title="7.9 void（java.lang.Void）"></a>7.9 void（java.lang.Void）</h3><p>实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<h2 id="8-引用类型"><a href="#8-引用类型" class="headerlink" title="8 引用类型"></a>8 引用类型</h2><ul>
<li>引用类型变量由类的构造函数创建，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。</li>
<li>对象、<strong>数组</strong>、<strong>字符串</strong>都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用与任何与之兼容的类型。</li>
</ul>
<h2 id="9-常量（final）"><a href="#9-常量（final）" class="headerlink" title="9 常量（final）"></a>9 常量（final）</h2><ul>
<li>常量就是一个固定值。</li>
<li>通常使用大写字母表示常量。</li>
<li><strong>字符串</strong>是常量。</li>
</ul>
<h2 id="10-局部变量"><a href="#10-局部变量" class="headerlink" title="10 局部变量"></a>10 局部变量</h2><ul>
<li>局部变量声明在方法、构造方法或者语句块中；</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以<strong>局部变量被声明后，必须经过初始化，才可以使用</strong>。</li>
</ul>
<h2 id="11-实例变量"><a href="#11-实例变量" class="headerlink" title="11 实例变量"></a>11 实例变量</h2><ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
</ul>
<h2 id="12-类变量（静态变量）"><a href="#12-类变量（静态变量）" class="headerlink" title="12 类变量（静态变量）"></a>12 类变量（静态变量）</h2><ul>
<li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法、构造方法和语句块之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。<strong>常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</strong></li>
<li><strong>静态变量储存在静态存储区</strong>。经常被声明为常量，很少单独使用static声明变量。</li>
<li><strong>静态变量在程序开始时创建，在程序结束时销毁</strong>。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li>
<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以- 在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：ClassName.VariableName的方式访问。</li>
<li><strong>类变量被声明为public static final类型时，类变量名称必须使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</strong></li>
</ul>
<h2 id="13-访问控制修饰符"><a href="#13-访问控制修饰符" class="headerlink" title="13 访问控制修饰符"></a>13 访问控制修饰符</h2><ul>
<li>default：默认的，在同一包内可见，不使用任何修饰符。<ul>
<li>接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为public。</li>
</ul>
</li>
<li>private：私有的，在同一类内可见。</li>
<li>public：共有的，对所有类可见。</li>
<li>protected 受保护的，对<strong>同一包内的类和所有子类</strong>可见（<strong>注意</strong>：此处对应C#的protected internal，而C#中protected仅仅对所有程序集的子类可见，而对包内的类不可见）。<ul>
<li>Protected访问修饰符不能修饰类和接口，方法和成员变量能够声明为protected，但是接口的成员变量和成员方法不能声明为protected。</li>
</ul>
</li>
</ul>
<h2 id="14-访问控制和继承"><a href="#14-访问控制和继承" class="headerlink" title="14 访问控制和继承"></a>14 访问控制和继承</h2><ul>
<li>父类中声明为public的方法在子类中也必须为public。</li>
<li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。</li>
<li>父类中声明为private的方法，不能够被继承。</li>
</ul>
<h2 id="15-非访问修饰符"><a href="#15-非访问修饰符" class="headerlink" title="15 非访问修饰符"></a>15 非访问修饰符</h2><ul>
<li>static<ul>
<li>用来创建类方法和类变量。</li>
</ul>
</li>
<li>final<ul>
<li>用来修饰类、方法和变量，<strong>final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的</strong>。</li>
<li>final变量能被显式地初始化并且只能初始化一次。<strong>被声明为final的对象的引用不能指向不同的对象。但是final对象里的数据可以被改变。</strong>也就是说final对象的引用不能改变，但是里面的值可以改变。</li>
<li>final修饰符通常和static修饰符一起使用来创建类常量。</li>
<li>类中的Final方法可以被子类继承，但是不能被子类修改。声明final方法的主要目的是防止该方法的内容被修改。</li>
<li>final类不能被继承，没有类能够继承final类的任何特性。（即C#的sealed）</li>
</ul>
</li>
<li>abstract<ul>
<li>用来创建抽象类和抽象方法。</li>
<li>一个类不能同时被abstract和final修饰。</li>
<li>抽象类可以包含抽象方法和非抽象方法。</li>
<li>抽象方法不能被声明成final和static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li>
</ul>
</li>
<li>synchronized<ul>
<li>synchronized关键字声明的方法同一时间只能被一个线程访问。synchronized修饰符可以应用于四个访问修饰符。</li>
</ul>
</li>
<li>Transient<ul>
<li>序列化的对象包含被transient修饰的实例变量时，java虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</li>
</ul>
</li>
<li>volatile<ul>
<li>volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。</li>
</ul>
</li>
</ul>
<h2 id="16-位运算符"><a href="#16-位运算符" class="headerlink" title="16 位运算符"></a>16 位运算符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>&amp;</strong></td>
<td>按位与操作符，当且仅当两个操作数的某一位都非0时候结果的该位才为1。</td>
</tr>
<tr>
<td><strong>&#124;</strong></td>
<td>按位或操作符，只要两个操作数的某一位有一个非0时候结果的该位就为1。</td>
</tr>
<tr>
<td><strong>^</strong></td>
<td>按位异或操作符，两个操作数的某一位不相同时候结果的该位就为1。    </td>
</tr>
<tr>
<td><strong>〜</strong></td>
<td>按位补运算符翻转操作数的每一位。    </td>
</tr>
<tr>
<td><strong>&lt;&lt;</strong></td>
<td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td>
</tr>
<tr>
<td><strong>&gt;&gt;</strong></td>
<td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td>
</tr>
<tr>
<td><strong>&gt;&gt;&gt;</strong></td>
<td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td>
</tr>
</tbody>
</table>
<h2 id="17-instanceOf"><a href="#17-instanceOf" class="headerlink" title="17 instanceOf"></a>17 instanceOf</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String name = <span class="string">'James'</span>;</div><div class="line"><span class="keyword">boolean</span> result = name instanceOf String; <span class="comment">// 由于name是Strine类型，所以返回true</span></div></pre></td></tr></table></figure></p>
<h2 id="18-for增强（即C-的foreach）"><a href="#18-for增强（即C-的foreach）" class="headerlink" title="18 for增强（即C#的foreach）"></a>18 for增强（即C#的foreach）</h2><p><code>·</code>要用于数组(Java5，之后不清楚是否有扩展，待确认)`</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : numbers )&#123;</div><div class="line">  System.out.print( x );</div><div class="line">  System.out.print(<span class="string">","</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="19-switch"><a href="#19-switch" class="headerlink" title="19 switch"></a>19 switch</h2><ul>
<li>switch语句中的变量类型只能为byte、short、int或者char。<code>(不清楚后续版本是否有扩展，待确认)</code></li>
<li>case语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li>
<li>switch语句可以包含一个default分支，<strong>该分支必须是switch语句的最后一个分支</strong>（C#中不一定是最后一个）。</li>
</ul>
<h2 id="20-Number类（java-lang）"><a href="#20-Number类（java-lang）" class="headerlink" title="20 Number类（java.lang）"></a>20 Number类（java.lang）</h2><p><img src="/images/posts/Java_Number.jpg" alt="图一"></p>
<h2 id="21-String类"><a href="#21-String类" class="headerlink" title="21 String类"></a>21 String类</h2><ul>
<li><strong>字符串属于对象</strong></li>
<li><strong>和C#不同的是，Java中只有String，而没有string！！！</strong></li>
<li><strong>String类是不可改变的，所以你一旦创建了String对象，那它的值就无法改变了。</strong></li>
<li><strong>字符串长度使用length(),即方法而不是C#的属性length。</strong></li>
</ul>
<h2 id="22-StringBuffer和StringBuilder"><a href="#22-StringBuffer和StringBuilder" class="headerlink" title="22 StringBuffer和StringBuilder"></a>22 StringBuffer和StringBuilder</h2><ul>
<li>StringBuilder的方法不是线程安全的（不能同步访问）,而StringBuffer是。</li>
<li>StringBuilder相较于StringBuffer有速度优势，多数情况下建议使用StringBuilder类。</li>
<li>在应用程序要求线程安全的情况下，则必须使用StringBuffer类。</li>
</ul>
<h2 id="23-数组"><a href="#23-数组" class="headerlink" title="23 数组"></a>23 数组</h2><h3 id="23-1-数组"><a href="#23-1-数组" class="headerlink" title="23.1 数组"></a>23.1 数组</h3><p><img src="/images/posts/Java_Array.jpg" alt="图一"></p>
<h3 id="23-2-Arrays-类-java-util-Arrays"><a href="#23-2-Arrays-类-java-util-Arrays" class="headerlink" title="23.2 Arrays 类(java.util.Arrays)"></a>23.2 Arrays 类(java.util.Arrays)</h3><ul>
<li>所有方法都是静态的</li>
<li>给数组赋值：通过fill方法。</li>
<li>对数组排序：通过sort方法,按升序。</li>
<li>比较数组：通过equals方法比较数组中<strong>元素值</strong>是否相等。</li>
<li>查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找法操作</li>
</ul>
<h2 id="24-时间"><a href="#24-时间" class="headerlink" title="24 时间"></a>24 时间</h2><h3 id="24-1-Date-类-java-util-Date"><a href="#24-1-Date-类-java-util-Date" class="headerlink" title="24.1 Date 类(java.util.Date)"></a>24.1 Date 类(java.util.Date)</h3><p>System.currentTimeMillis()计算时间</p>
<h3 id="24-2-SimpleDateFormat：格式化日期"><a href="#24-2-SimpleDateFormat：格式化日期" class="headerlink" title="24.2 SimpleDateFormat：格式化日期"></a>24.2 SimpleDateFormat：格式化日期</h3><table>
<thead>
<tr>
<th>字母</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>纪元标记</td>
<td>AD</td>
</tr>
<tr>
<td>y</td>
<td>四位年份</td>
<td>2001</td>
</tr>
<tr>
<td>M</td>
<td>月份</td>
<td>July or 07</td>
</tr>
<tr>
<td>d</td>
<td>一个月的日期</td>
<td>10</td>
</tr>
<tr>
<td>h</td>
<td>A.M./P.M.(1~12)格式小时</td>
<td>12</td>
</tr>
<tr>
<td>H</td>
<td>一天中的小时(0~23)</td>
<td>22</td>
</tr>
<tr>
<td>m</td>
<td>分钟数</td>
<td>30</td>
</tr>
<tr>
<td>s</td>
<td>秒数</td>
<td>55</td>
</tr>
<tr>
<td>S</td>
<td>微妙数</td>
<td>234</td>
</tr>
<tr>
<td>E</td>
<td>星期几</td>
<td>Tuesday</td>
</tr>
<tr>
<td>D</td>
<td>一年中的日子</td>
<td>360</td>
</tr>
<tr>
<td>F</td>
<td>一个月中第几周的周几</td>
<td>2 (second Wed. in July)</td>
</tr>
<tr>
<td>w</td>
<td>一年中第几周</td>
<td>40</td>
</tr>
<tr>
<td>W</td>
<td>一个月中第几周</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>A.M./P.M. 标记</td>
<td>PM</td>
</tr>
<tr>
<td>k</td>
<td>一天中的小时(1~24)</td>
<td>24</td>
</tr>
<tr>
<td>K</td>
<td>A.M./P.M. (0~11)格式小时</td>
<td>10</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
<td>Eastern Standard Time</td>
</tr>
<tr>
<td>‘</td>
<td>文字定界符</td>
<td>Delimiter</td>
</tr>
<tr>
<td>“</td>
<td>单引号</td>
<td>`</td>
</tr>
</tbody>
</table>
<h3 id="24-3-Calendar"><a href="#24-3-Calendar" class="headerlink" title="24.3 Calendar"></a>24.3 Calendar</h3><ul>
<li>抽象类</li>
<li>getInstance()获取实例</li>
</ul>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Calendar.YEAR</td>
<td>年份</td>
</tr>
<tr>
<td>Calendar.MONTH</td>
<td>月份</td>
</tr>
<tr>
<td>Calendar.DATE</td>
<td>日期</td>
</tr>
<tr>
<td>Calendar.DAY_OF_MONTH</td>
<td>日期，和上面的字段意义完全相同</td>
</tr>
<tr>
<td>Calendar.HOUR</td>
<td>12小时制的小时</td>
</tr>
<tr>
<td>Calendar.HOUR_OF_DAY</td>
<td>24小时制的小时</td>
</tr>
<tr>
<td>Calendar.MINUTE</td>
<td>分钟</td>
</tr>
<tr>
<td>Calendar.SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>Calendar.DAY_OF_WEEK</td>
<td>星期几</td>
</tr>
</tbody>
</table>
<h3 id="24-4-GregorianCalendar"><a href="#24-4-GregorianCalendar" class="headerlink" title="24.4 GregorianCalendar"></a>24.4 GregorianCalendar</h3><h2 id="25-正则（java-util-regex包）"><a href="#25-正则（java-util-regex包）" class="headerlink" title="25 正则（java.util.regex包）"></a>25 正则（java.util.regex包）</h2><ul>
<li>Pattern类：pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。</li>
<li>Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。</li>
<li>PatternSyntaxException：PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td><code>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，&quot;n&quot;匹配字符&quot;n&quot;。&quot;\n&quot;匹配换行符。序列&quot;\\&quot;匹配&quot;\&quot;，&quot;\(&quot;匹配&quot;(&quot;。</code></td>
</tr>
<tr>
<td>^</td>
<td><code>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与&quot;\n&quot;或&quot;\r&quot;之后的位置匹配。</code></td>
</tr>
<tr>
<td>$</td>
<td><code>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与&quot;\n&quot;或&quot;\r&quot;之前的位置匹配。</code></td>
</tr>
<tr>
<td>*</td>
<td><code>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配&quot;z&quot;和&quot;zoo&quot;。* 等效于 {0,}。</code></td>
</tr>
<tr>
<td>+</td>
<td><code>一次或多次匹配前面的字符或子表达式。例如，&quot;zo+&quot;与&quot;zo&quot;和&quot;zoo&quot;匹配，但与&quot;z&quot;不匹配。+ 等效于 {1,}。</code></td>
</tr>
<tr>
<td>?</td>
<td><code>零次或一次匹配前面的字符或子表达式。例如，&quot;do(es)?&quot;匹配&quot;do&quot;或&quot;does&quot;中的&quot;do&quot;。? 等效于 {0,1}。</code></td>
</tr>
<tr>
<td>{n}</td>
<td><code>n 是非负整数。正好匹配 n 次。例如，&quot;o{2}&quot;与&quot;Bob&quot;中的&quot;o&quot;不匹配，但与&quot;food&quot;中的两个&quot;o&quot;匹配。</code></td>
</tr>
<tr>
<td>{n,}</td>
<td><code>n 是非负整数。至少匹配 n 次。例如，&quot;o{2,}&quot;不匹配&quot;Bob&quot;中的&quot;o&quot;，而匹配&quot;foooood&quot;中的所有 o。&quot;o{1,}&quot;等效于&quot;o+&quot;。&quot;o{0,}&quot;等效于&quot;o*&quot;。</code></td>
</tr>
<tr>
<td>{n,m}</td>
<td><code>M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，&quot;o{1,3}&quot;匹配&quot;fooooood&quot;中的头三个 o。&#39;o{0,1}&#39; 等效于 &#39;o?&#39;。注意：您不能将空格插入逗号和数字之间。</code></td>
</tr>
<tr>
<td>?</td>
<td><code>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是&quot;非贪心的&quot;。&quot;非贪心的&quot;模式匹配搜索到的、尽可能短的字符串，而默认的&quot;贪心的&quot;模式匹配搜索到的、尽可能长的字符串。例如，在字符串&quot;oooo&quot;中，&quot;o+?&quot;只匹配单个&quot;o&quot;，而&quot;o+&quot;匹配所有&quot;o&quot;。</code></td>
</tr>
<tr>
<td>.</td>
<td><code>匹配除&quot;\r\n&quot;之外的任何单个字符。若要匹配包括&quot;\r\n&quot;在内的任意字符，请使用诸如&quot;[\s\S]&quot;之类的模式。</code></td>
</tr>
<tr>
<td>(pattern)</td>
<td><code>匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果&quot;匹配&quot;集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用&quot;\(&quot;或者&quot;\)&quot;。</code></td>
</tr>
<tr>
<td>(?:pattern)</td>
<td><code>匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用&quot;or&quot;字符 (&amp;#124;) 组合模式部件的情况很有用。例如，&#39;industr(?:y&amp;#124;ies) 是比 &#39;industry&amp;#124;industries&#39; 更经济的表达式。</code></td>
</tr>
<tr>
<td>(?=pattern)</td>
<td><code>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#39;Windows (?=95&amp;#124;98&amp;#124;NT&amp;#124;2000)&#39; 匹配&quot;Windows 2000&quot;中的&quot;Windows&quot;，但不匹配&quot;Windows 3.1&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</code></td>
</tr>
<tr>
<td>(?!pattern)</td>
<td><code>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#39;Windows (?!95&amp;#124;98&amp;#124;NT&amp;#124;2000)&#39; 匹配&quot;Windows 3.1&quot;中的 &quot;Windows&quot;，但不匹配&quot;Windows 2000&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</code></td>
</tr>
<tr>
<td>x&#124;y</td>
<td><code>匹配 x 或 y。例如，&#39;z&amp;#124;food&#39; 匹配&quot;z&quot;或&quot;food&quot;。&#39;(z&amp;#124;f)ood&#39; 匹配&quot;zood&quot;或&quot;food&quot;。</code></td>
</tr>
<tr>
<td>[xyz]</td>
<td><code>字符集。匹配包含的任一字符。例如，&quot;[abc]&quot;匹配&quot;plain&quot;中的&quot;a&quot;。</code></td>
</tr>
<tr>
<td>[^xyz]</td>
<td><code>反向字符集。匹配未包含的任何字符。例如，&quot;[^abc]&quot;匹配&quot;plain&quot;中&quot;p&quot;，&quot;l&quot;，&quot;i&quot;，&quot;n&quot;。</code></td>
</tr>
<tr>
<td>[a-z]</td>
<td><code>字符范围。匹配指定范围内的任何字符。例如，&quot;[a-z]&quot;匹配&quot;a&quot;到&quot;z&quot;范围内的任何小写字母。</code></td>
</tr>
<tr>
<td>[^a-z]</td>
<td><code>反向范围字符。匹配不在指定的范围内的任何字符。例如，&quot;[^a-z]&quot;匹配任何不在&quot;a&quot;到&quot;z&quot;范围内的任何字符。</code></td>
</tr>
<tr>
<td>\b</td>
<td><code>匹配一个字边界，即字与空格间的位置。例如，&quot;er\b&quot;匹配&quot;never&quot;中的&quot;er&quot;，但不匹配&quot;verb&quot;中的&quot;er&quot;。</code></td>
</tr>
<tr>
<td>\B</td>
<td><code>非字边界匹配。&quot;er\B&quot;匹配&quot;verb&quot;中的&quot;er&quot;，但不匹配&quot;never&quot;中的&quot;er&quot;。</code></td>
</tr>
<tr>
<td>\cx</td>
<td><code>匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是&quot;c&quot;字符本身。</code></td>
</tr>
<tr>
<td>\d</td>
<td><code>数字字符匹配。等效于 [0-9]。</code></td>
</tr>
<tr>
<td>\D</td>
<td><code>非数字字符匹配。等效于 [^0-9]。</code></td>
</tr>
<tr>
<td>\f</td>
<td><code>换页符匹配。等效于 \x0c 和 \cL。</code></td>
</tr>
<tr>
<td>\n</td>
<td><code>换行符匹配。等效于 \x0a 和 \cJ。</code></td>
</tr>
<tr>
<td>\r</td>
<td><code>匹配一个回车符。等效于 \x0d 和 \cM。</code></td>
</tr>
<tr>
<td>\s</td>
<td><code>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</code></td>
</tr>
<tr>
<td>\S</td>
<td><code>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</code></td>
</tr>
<tr>
<td>\t</td>
<td><code>制表符匹配。与 \x09 和 \cI 等效。</code></td>
</tr>
<tr>
<td>\v</td>
<td><code>垂直制表符匹配。与 \x0b 和 \cK 等效。</code></td>
</tr>
<tr>
<td>\w</td>
<td><code>匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效。</code></td>
</tr>
<tr>
<td>\W</td>
<td><code>与任何非单词字符匹配。与&quot;[^A-Za-z0-9_]&quot;等效。</code></td>
</tr>
<tr>
<td>\xn</td>
<td><code>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，&quot;\x41&quot;匹配&quot;A&quot;。&quot;\x041&quot;与&quot;\x04&quot;&amp;&quot;1&quot;等效。允许在正则表达式中使用 ASCII 代码。</code></td>
</tr>
<tr>
<td>\num</td>
<td><code>匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，&quot;(.)\1&quot;匹配两个连续的相同字符。</code></td>
</tr>
<tr>
<td>\n</td>
<td><code>标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</code></td>
</tr>
<tr>
<td>\nm</td>
<td><code>标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</code></td>
</tr>
<tr>
<td>\nml</td>
<td><code>当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</code></td>
</tr>
<tr>
<td>\un</td>
<td><code>匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</code></td>
</tr>
</tbody>
</table>
<h2 id="26-方法"><a href="#26-方法" class="headerlink" title="26 方法"></a>26 方法</h2><ul>
<li><strong>方法是通过值传递参数</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPassByValue</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> num1 = <span class="number">1</span>;</div><div class="line">      <span class="keyword">int</span> num2 = <span class="number">2</span>;</div><div class="line"></div><div class="line">      System.out.println(<span class="string">"Before swap method, num1 is "</span> + num1 + <span class="string">" and num2 is "</span> + num2);</div><div class="line"></div><div class="line">      <span class="comment">// 调用swap方法</span></div><div class="line">      swap(num1, num2);</div><div class="line">      System.out.println(<span class="string">"After swap method, num1 is "</span> + num1 + <span class="string">" and num2 is "</span> + num2);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">/** 交换两个变量的方法 */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"\tInside the swap method"</span>);</div><div class="line">      System.out.println(<span class="string">"\t\tBefore swapping n1 is "</span> + n1 + <span class="string">" n2 is "</span> + n2);</div><div class="line">      <span class="comment">// 交换 n1 与 n2的值</span></div><div class="line">      <span class="keyword">int</span> temp = n1;</div><div class="line">      n1 = n2;</div><div class="line">      n2 = temp;</div><div class="line"></div><div class="line">      System.out.println(<span class="string">"\t\tAfter swapping n1 is "</span> + n1 + <span class="string">" n2 is "</span> + n2);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>结果如下：</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Before swap method, num1 is 1 and num2 is 2</div><div class="line">Inside the swap method</div><div class="line">Before swapping n1 is 1 n2 is 2</div><div class="line">After swapping n1 is 2 n2 is 1</div><div class="line">After swap method, num1 is 1 and num2 is 2</div></pre></td></tr></table></figure></p>
<h2 id="27-可变参数"><a href="#27-可变参数" class="headerlink" title="27 可变参数"></a>27 可变参数</h2><p>typeName… parameterName，必须放置在最后一个（即C#的param int arr）</p>
<h2 id="28-finalize方法（即C-的析构函数）"><a href="#28-finalize方法（即C-的析构函数）" class="headerlink" title="28 finalize方法（即C#的析构函数）"></a>28 finalize方法（即C#的析构函数）</h2><ul>
<li>在对象被垃圾收集器析构(回收)之前调用，它用来清除回收对象。</li>
<li>System.gc(); //调用Java垃圾收集器</li>
</ul>
<h2 id="29-流（java-io包）"><a href="#29-流（java-io包）" class="headerlink" title="29 流（java.io包）"></a>29 流（java.io包）</h2><p><img src="/images/posts/Java_Stream.jpg" alt="Stream"></p>
<h3 id="29-1-读取控制台输入"><a href="#29-1-读取控制台输入" class="headerlink" title="29.1 读取控制台输入"></a>29.1 读取控制台输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div></pre></td></tr></table></figure>
<h3 id="29-2-获取或设置JVM当前工作目录"><a href="#29-2-获取或设置JVM当前工作目录" class="headerlink" title="29.2 获取或设置JVM当前工作目录"></a>29.2 获取或设置JVM当前工作目录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.getProperty(<span class="string">"user.dir"</span>);</div><div class="line">System.setProperty(<span class="string">"user.dir"</span>, <span class="string">"C:\\myDir"</span>);</div></pre></td></tr></table></figure>
<h3 id="29-3-文件分隔符"><a href="#29-3-文件分隔符" class="headerlink" title="29.3 文件分隔符"></a>29.3 文件分隔符</h3><p>常量<strong>File.separator</strong>，用于解决Windows在路径名中使用反斜杠（\）作为名称分隔符，而UNIX使用正斜杠（/）的问题。</p>
<h2 id="30-Scan-java-util-SCanner"><a href="#30-Scan-java-util-SCanner" class="headerlink" title="30 Scan(java.util.SCanner)"></a>30 Scan(java.util.SCanner)</h2><p>主要用于获取用户的输入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</div></pre></td></tr></table></figure></p>
<h2 id="31-异常"><a href="#31-异常" class="headerlink" title="31 异常"></a>31 异常</h2><h3 id="31-1-异常类型"><a href="#31-1-异常类型" class="headerlink" title="31.1 异常类型"></a>31.1 异常类型</h3><ul>
<li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li>错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<h3 id="31-2-异常层次"><a href="#31-2-异常层次" class="headerlink" title="31.2 异常层次"></a>31.2 异常层次</h3><ul>
<li>所有的异常类是从java.lang.Exception类继承的子类。</li>
<li>Exception类是Throwable类的子类。除了Exception类外，Throwable还有一个子类Error 。</li>
</ul>
<p><img src="/images/posts/Java_Exception.jpg" alt="Exception"></p>
<h3 id="31-3-非检查性异常"><a href="#31-3-非检查性异常" class="headerlink" title="31.3 非检查性异常"></a>31.3 非检查性异常</h3><table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArithmeticException</td>
<td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundsException</td>
<td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td>
</tr>
<tr>
<td>ArrayStoreException</td>
<td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td>
</tr>
<tr>
<td>ClassCastException</td>
<td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td>
</tr>
<tr>
<td>IllegalMonitorStateException</td>
<td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td>
</tr>
<tr>
<td>IllegalThreadStateException</td>
<td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td>
</tr>
<tr>
<td>NegativeArraySizeException</td>
<td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</td>
</tr>
<tr>
<td>NumberFormatException</td>
<td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td>
</tr>
<tr>
<td>SecurityException</td>
<td>由安全管理器抛出的异常，指示存在安全侵犯。</td>
</tr>
<tr>
<td>StringIndexOutOfBoundsException</td>
<td>此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>当不支持请求的操作时，抛出该异常。</td>
</tr>
</tbody>
</table>
<h3 id="31-4-检查性异常类"><a href="#31-4-检查性异常类" class="headerlink" title="31.4 检查性异常类"></a>31.4 检查性异常类</h3><table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClassNotFoundException</td>
<td>应用程序试图加载类时，找不到相应的类，抛出该异常。</td>
</tr>
<tr>
<td>CloneNotSupportedException</td>
<td>当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</td>
</tr>
<tr>
<td>IllegalAccessException</td>
<td>拒绝访问一个类的时候，抛出该异常。</td>
</tr>
<tr>
<td>InstantiationException</td>
<td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td>
</tr>
<tr>
<td>InterruptedException</td>
<td>一个线程被另一个线程中断，抛出该异常。</td>
</tr>
<tr>
<td>NoSuchFieldException</td>
<td>请求的变量不存在</td>
</tr>
<tr>
<td>NoSuchMethodException</td>
<td>请求的方法不存在</td>
</tr>
</tbody>
</table>
<h3 id="31-5-throws-throw关键字"><a href="#31-5-throws-throw关键字" class="headerlink" title="31.5 throws/throw关键字"></a>31.5 throws/throw关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></div><div class="line"><span class="function">   </span>&#123;</div><div class="line">      <span class="comment">// Method implementation</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//Remainder of class definition</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="31-6-自定义异常"><a href="#31-6-自定义异常" class="headerlink" title="31.6 自定义异常"></a>31.6 自定义异常</h3><ul>
<li>所有异常都必须是Throwable的子类。</li>
<li>检查性异常：继承Exception类。</li>
<li>运行时异常：继承RuntimeException 类。</li>
</ul>
<h3 id="31-7-异常和错误"><a href="#31-7-异常和错误" class="headerlink" title="31.7 异常和错误"></a>31.7 异常和错误</h3><ul>
<li>JVM(Java虚拟机)异常：由JVM抛出的异常或错误。例如：NullPointerException类，ArrayIndexOutOfBoundsException类，ClassCastException类。</li>
<li>程序级异常：由程序或者API程序抛出的异常。例如IllegalArgumentException类，IllegalStateException类。</li>
</ul>
<h2 id="38-继承-is-a"><a href="#38-继承-is-a" class="headerlink" title="38 继承(is-a)"></a>38 继承(is-a)</h2><p>可用<code>a instanceof b</code>校验。 </p>
<ul>
<li>extends：继承类</li>
<li>implements：继承接口</li>
</ul>
<h2 id="39-重写（override）-amp-重载（overload）"><a href="#39-重写（override）-amp-重载（overload）" class="headerlink" title="39 重写（override）&amp;重载（overload）"></a>39 重写（override）&amp;重载（overload）</h2><table>
<thead>
<tr>
<th>区别点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody>
</table>
<h2 id="40-多态（is-a）"><a href="#40-多态（is-a）" class="headerlink" title="40 多态（is-a）"></a>40 多态（is-a）</h2><ul>
<li>同一个行为具有多个不同表现形式或形态的能力。</li>
<li>多态性是对象多种表现形式的体现。</li>
</ul>
<h2 id="41-接口（interface）"><a href="#41-接口（interface）" class="headerlink" title="41 接口（interface）"></a>41 接口（interface）</h2><ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。</li>
<li>接口中的方法都是公有的。</li>
<li>标识接口：没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</li>
</ul>
<h2 id="42-包"><a href="#42-包" class="headerlink" title="42 包"></a>42 包</h2><h3 id="42-1-package"><a href="#42-1-package" class="headerlink" title="42.1 package"></a>42.1 package</h3><ul>
<li>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。</li>
<li>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</li>
</ul>
<h3 id="42-2-import"><a href="#42-2-import" class="headerlink" title="42.2 import"></a>42.2 import</h3><ul>
<li>文件中可以包含任意数量的import声明。import声明必须在包声明之后，类声明之前。</li>
<li>静态导入<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="42-3-CLASSPATH"><a href="#42-3-CLASSPATH" class="headerlink" title="42.3 CLASSPATH"></a>42.3 CLASSPATH</h3><p>类目录的绝对路径叫做class path。设置在系统变量CLASSPATH中。编译器和java虚拟机通过将package名字加到class path后来构造.class文件的路径。<path- two="">\classes是class path，package名字是com.apple.computers,而编译器和JVM会在 <path-two>\classes\com\apple\compters中找.class文件。<br>一个class path可能会包含好几个路径。多路径应该用分隔符分开。默认情况下，编译器和JVM查找当前目录。JAR文件按包含Java平台相关的类，所以他们的目录默认放在了class path中。</path-two></path-></p>
<h2 id="43-Object"><a href="#43-Object" class="headerlink" title="43 Object"></a>43 Object</h2><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String toString()</td>
<td>它是实现在Object类中，我们可以自定义它。它返回对象的字符串表示形式。通常，它用于调试目的。</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>它在Object类中实现，我们可以自定义它。它用于比较两个对象的相等性。</td>
</tr>
<tr>
<td>public int hashCode()</td>
<td>它在Object类中实现，我们可以自定义它。它返回对象的哈希码（整数）值。</td>
</tr>
<tr>
<td>protected Object clone() throws CloneNotSupportedException</td>
<td>它不在Object类中实现，我们可以通过覆盖克隆方法来自定义它。它用于创建对象的副本。</td>
</tr>
<tr>
<td>protected void finalize() throws Throwable</td>
<td>它不是在Object类中实现，我们可以自定义它。它在对象被销毁之前被垃圾收集器调用。</td>
</tr>
<tr>
<td>public final Class getClass()</td>
<td>它在Object类中实现，我们不能自定义它。它返回对对象的Class对象的引用。</td>
</tr>
<tr>
<td>public final void notify()</td>
<td>它是在Object类中实现的，我们不能自定义它。此方法通知对象的等待队列中的一个线程。</td>
</tr>
<tr>
<td>public final void notifyAll()</td>
<td>它是在Object类中实现的，我们不能自定义它。此方法通知对象的等待队列中的所有线程。</td>
</tr>
<tr>
<td>public final void wait() throws InterruptedException<br>public final void wait(long timeout) throws InterruptedException<br>public final void wait (long timeout, int nanos) throws InterruptedException</td>
<td>它是在Object类中实现的，我们不能自定义它。使对象的等待队列中的线程等待，无论是否超时。</td>
</tr>
</tbody>
</table>
<h3 id="43-1-hashCode"><a href="#43-1-hashCode" class="headerlink" title="43.1 hashCode"></a>43.1 hashCode</h3><ul>
<li>如果两个对象使用equals()方法相等，则它们必须具有相同的哈希码。</li>
<li>如果x.hashCode()等于y.hashCode()，则x.equals(y)不必返回true。</li>
</ul>
<h3 id="43-2-equals"><a href="#43-2-equals" class="headerlink" title="43.2 equals"></a>43.2 equals</h3><p>这里是equals()方法的实现的规范。假设x，y和z是三个对象的非空引用。</p>
<ul>
<li>自反性。表达式x.equals(x)应该返回true。</li>
<li>对称性。如果x.equals(y)返回true，y.equals(x)必须返回true。</li>
<li>传递性。如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)必须返回true。</li>
<li>一致性。如果x.equals(y)返回true，它应该保持返回true，直到x或y的状态被修改。如果x.equals(y)返回false，它应该保持返回false，直到x或y的状态被修改。</li>
<li>与空引用的比较：任何类的对象不应等于空引用。表达式x.equals(null)应始终返回false。</li>
<li>与hashCode()方法的关系：如果x.equals(y)返回true，x.hashCode()必须返回与y.hashCode()相同的值。</li>
</ul>
<h3 id="43-3-toString"><a href="#43-3-toString" class="headerlink" title="43.3 toString"></a>43.3 toString</h3><p>当需要对象的字符串表示时，Java会自动调用toString()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"Hello"</span> + <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</div></pre></td></tr></table></figure></p>
<p>等同于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"Hello"</span> + <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>).toString();</div></pre></td></tr></table></figure></p>
<h3 id="43-4-clone（浅拷贝）"><a href="#43-4-clone（浅拷贝）" class="headerlink" title="43.4 clone（浅拷贝）"></a>43.4 clone（浅拷贝）</h3><p>Java不提供克隆(复制)对象的自动机制。克隆对象意味着逐位复制对象的内容。要支持克隆操作，请在类中实现clone()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">  MyClass copy = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    copy = (MyClass) <span class="keyword">super</span>.clone();</div><div class="line">  &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="43-5-finalize"><a href="#43-5-finalize" class="headerlink" title="43.5 finalize"></a>43.5 finalize</h3><p>finalize()方法将在类的对象销毁之前由垃圾回收器调用。</p>
<h3 id="Immutables-不可变"><a href="#Immutables-不可变" class="headerlink" title="Immutables(不可变)"></a>Immutables(不可变)</h3><p>在创建状态后无法更改其状态的对象称为不可变对象。一个对象不可变的类称为不可变类。不变的对象可以由程序的不同区域共享而不用担心其状态改变。不可变对象本质上是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">IntWrapper</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntWrapper</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="43-7-Objects类-实用程序类"><a href="#43-7-Objects类-实用程序类" class="headerlink" title="43.7 Objects类(实用程序类)"></a>43.7 Objects类(实用程序类)</h3><p>主要用于处理对象。由静态方法组成。 Objects类中的大多数方法都会优雅地处理空值。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int compare(T a, T b, Comparator c)</td>
<td>如果参数相同，则返回0，否则返回c.compare(a，b)。因此，如果两个参数都为null，则返回0。</td>
</tr>
<tr>
<td>boolean deepEquals(Object a, Object b)</td>
<td>检查两个对象是否相等。如果两个参数都相等，则返回true。否则，它返回false。如果两个参数都为null，则返回true。</td>
</tr>
<tr>
<td>boolean equals(Object a, Object b)</td>
<td>比较两个对象是否相等。如果两个参数相等，则返回true。否则，它返回false。如果两个参数都为null，则返回true。</td>
</tr>
<tr>
<td>int hash(Object… values)</td>
<td>为所有指定的对象生成哈希码。它可以用于计算对象的哈希码，该哈希码基于多个实例字段。</td>
</tr>
<tr>
<td>int hashCode(Object o)</td>
<td>返回指定对象的哈希码值。如果参数为null，则返回0。</td>
</tr>
<tr>
<td>boolean isNull(Object obj)</td>
<td>如果指定的对象为null，isNull()方法返回true。否则，它返回false。您还可以使用比较运算符==检查对象是否为null，例如，obj == null返回obj的true为null。</td>
</tr>
<tr>
<td>boolean nonNull(Object obj)</td>
<td>执行与isNull()方法相反的检查。</td>
</tr>
<tr>
<td>T requireNonNull(T obj)</td>
<td>检查参数是否为null。如果参数为null，它会抛出一个NullPointerException异常。此方法设计用于验证方法和构造函数的参数。</td>
</tr>
<tr>
<td>T requireNonNull(T obj, String message)</td>
<td>第二个版本可以指定当参数为null时抛出的NullPointerException的消息。</td>
</tr>
<tr>
<td>T requireNonNull(T obj, Supplier messageSupplier)</td>
<td>第三个版本的方法将一个Supplier作为第二个参数。</td>
</tr>
<tr>
<td>String toString(Object o)<br>String toString(Object o, String nullDefault)</td>
<td>如果参数为null，则toString()方法返回一个“null”字符串。对于非空参数，它返回通过调用参数的toString()方法返回的值。</td>
</tr>
</tbody>
</table>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Hello-World-示例&quot;&gt;&lt;a href=&quot;#1-Hello-World-示例&quot; class=&quot;headerlink&quot; title=&quot;1 Hello World 示例&quot;&gt;&lt;/a&gt;1 Hello World 示例&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloWorld&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;ps:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 中类名（CamelCase 风格）要与文件名保持一致；&lt;/li&gt;
&lt;li&gt;Java 中方法名 camelCase 风格；&lt;/li&gt;
&lt;li&gt;main 主函数参数默认为 String []；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
      <category term="JavaSE" scheme="http://www.venux.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>CLR-21垃圾回收</title>
    <link href="http://www.venux.cn/2017/12/27/CLR-21%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://www.venux.cn/2017/12/27/CLR-21垃圾回收/</id>
    <published>2017-12-27T06:50:37.000Z</published>
    <updated>2018-05-14T02:53:19.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-访问资源步骤"><a href="#1-访问资源步骤" class="headerlink" title="1 访问资源步骤"></a>1 访问资源步骤</h2><ol>
<li>调用 IL 指令 newobj，为代表资源的类型分配内存（C# 一般使用 new）；</li>
<li>初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态；</li>
<li>访问类型的成员来使用资源（有必要可重复）；</li>
<li>摧毁资源的状态以便清理；</li>
<li>释放内存（垃圾回收）。<a id="more"></a>
</li>
</ol>
<h2 id="2-无GC存在的问题"><a href="#2-无GC存在的问题" class="headerlink" title="2 无GC存在的问题"></a>2 无GC存在的问题</h2><ul>
<li>忘记释放内存而造成的<strong>内存泄露</strong></li>
<li><strong>访问已释放的内存</strong>引起的 bug</li>
</ul>
<h2 id="3-托管堆分配资源"><a href="#3-托管堆分配资源" class="headerlink" title="3 托管堆分配资源"></a>3 托管堆分配资源</h2><p>CLR 要求所有<strong>对象</strong>都从<strong>托管堆</strong>分配，进程初始化时，CLR 划出一个地址空间区域作为托管堆，并维护一指针（NextOjbPtr），NextObjPtr 最初指向基地址，主要作用指向下一个对象在堆中的分配位置。一个区域被<strong>非垃圾对象</strong>填满后，CLR 会分配更多区域，重复直至整个进程地址空间填满，故应用程序的内存受进程的虚拟空间限制。32 位进程最多分配 1.5 GB，64 位进程为 8 TB。</p>
<h2 id="4-new-操作符"><a href="#4-new-操作符" class="headerlink" title="4 new 操作符"></a>4 new 操作符</h2><ol>
<li>计算类型的字段（及从基类型继承的字段）所需的字节数；</li>
<li>加上对象的开销所需字节数（每个对象 2 个开销字段：<strong>类型对象指针</strong>、<strong>同步块索引</strong>，32 位应用程序一个字段需要 32 位即 4 字节，64 位应用程序一个字段需要 64 位即 8 字节）；</li>
<li>CLR 检查区域中是否有分配对象所需的字节数，有则在 NextOjbPtr 指针指向的地址存放对象，为对象分配的字节会被清零。调用类型的构造器，new 操作符返回对象引用，并在此之前移动 NextOjbPtr 指针指向下一个对象存放的地址。无则先进行垃圾回收（第 0 代已满情况下），若还没空间分配则抛出 OutOfMemoryException。</li>
</ol>
<h2 id="5-垃圾回收算法"><a href="#5-垃圾回收算法" class="headerlink" title="5 垃圾回收算法"></a>5 垃圾回收算法</h2><h3 id="5-1-引用计数算法（未采用）"><a href="#5-1-引用计数算法（未采用）" class="headerlink" title="5.1 引用计数算法（未采用）"></a>5.1 引用计数算法（未采用）</h3><p>堆上每个对象都维护一个内存字段来统计程序中多少“部分”正在使用对象，若“部分”不再需要对象时，则计数递减，直至为零后可删除对象。<br><strong>存在的问题：</strong>循环引用导致对象永远不会删除。</p>
<h3 id="5-2-引用跟踪算法（CLR采用）"><a href="#5-2-引用跟踪算法（CLR采用）" class="headerlink" title="5.2 引用跟踪算法（CLR采用）"></a>5.2 引用跟踪算法（CLR采用）</h3><p>引用跟踪算法只计算引用类型的变量，因为只有这种变量（统称为根：类的静态字段、实例字段、方法参数、局部变量）才能引用堆上的对象，值类型直接包含值类型实例。</p>
<h2 id="6-GC流程"><a href="#6-GC流程" class="headerlink" title="6 GC流程"></a>6 GC流程</h2><ol>
<li>暂停所有线程，防止线程在 GC 检查期间访问对象并更改状态；</li>
<li>CLR 进入 GC 标记阶段：<br>2.1. CLR 遍历堆中的所有对象，并将同步块索引字段中的一位设为 0，表明所有对象都应删除；<br>2.2. CLR 检查所有活动根，查看它们引用了哪些对象，若为 null 则忽略继续检查下一个根；<br>2.3. 任何根若引用堆上对象，则标记那个对象（同步块索引中的一位设为1），若对象被标记，则检查对象的根，标记它们引用的对象，若对象已标记则不检查该对象字段，从而避免循环引用产生的死循环；</li>
<li>标记阶段结束后，堆中的对象要么已标记（可达 reachable），要么未标记（不可达 unreachable），开始进入 GC 的 压缩（compact，实际上应该称为碎片整理）阶段：<br>3.1. CLR 移动堆中已标记对象，使它们占用连续内存空间，恢复引用的“局部化”，减少应用程序工作集，从而提升性能。另外可用空间也是连续的，解决了空间碎片化问题。<strong>注意：</strong>大对象堆中的对象不会压缩，故还是可能发生地址空间碎片化。<br>3.2. CLR 从每个根减去引用对象在内存中便宜的字节数，保证每个根引用的还是之前的对象。</li>
<li>移动 NextObjPtr 指针指向最后一个幸存对象之后的位置，下一个分配的对象将放到这位置。</li>
<li>CLR 恢复应用程序的所有线程。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>静态字段引用的对象一直存在，直至用于加载类型的 AppDomain 卸载为止。</li>
<li>内存泄露一个常见原因就是静态字段引用了一个集合对象，然后不停向集合添加数据项，导致一直存活。</li>
<li><strong>尽量</strong>避免使用静态字段。</li>
</ul>
<h2 id="7-基于代的垃圾回收器（generational-garbage-collector）"><a href="#7-基于代的垃圾回收器（generational-garbage-collector）" class="headerlink" title="7 基于代的垃圾回收器（generational garbage collector）"></a>7 基于代的垃圾回收器（generational garbage collector）</h2><ul>
<li>对象越新，生存期越短。</li>
<li>对象越老，生存期越长。</li>
<li>回收堆的一部分，速度快于回收整个堆。</li>
</ul>
<p>托管堆只支持三代（System.GC.MaxGenerationa() 返回 2）：第 0 代、第 1 代和第 2 代。</p>
<p>详细见P454</p>
<h2 id="8-垃圾回收触发条件"><a href="#8-垃圾回收触发条件" class="headerlink" title="8 垃圾回收触发条件"></a>8 垃圾回收触发条件</h2><ul>
<li>CLR 检测第 0 代超过预算（最常见）；</li>
<li>代码显示调用 System.GC.Collect();</li>
<li>Windows 报告低内存情况；</li>
<li>CLR 正在卸载 AppDomain；</li>
<li>CLR 正在关闭（此时 CLR 不会试图压缩或释放内存，Windows 直接回收进程的全部内存）。</li>
</ul>
<h2 id="9-大对象"><a href="#9-大对象" class="headerlink" title="9 大对象"></a>9 大对象</h2><p>CLR 将对象分为大对象和小对象，目前认为 85000 字节或更大的对象为大对象。</p>
<ul>
<li>大对象不是在小对象的地址空间分配，而是在进程地址空间的其他地方分配；</li>
<li>目前版本的 GC 不压缩大对象，因为在内存中移动它们代价过高，故在进程中大对象之间造成地址空间的碎片化，可能抛出 OutOfMemoryException；</li>
<li>大对象总是第 2 代，绝不可能是第 0 代或第 1 代，所以只能为需要长时间存活的资源创建大对象，否则会频繁回收第 2 代，损害性能。</li>
</ul>
<h2 id="10-GC模式"><a href="#10-GC模式" class="headerlink" title="10 GC模式"></a>10 GC模式</h2><p>CLR 启动时会选择一个 GC 模式，进程终止前该模式不会改变。</p>
<ul>
<li><strong>工作站（默认）：</strong>该模式针对客户端应用程序优化GC。</li>
<li><strong>服务器：</strong>该模式针对服务器端应用程序优化 GC。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>若计算机为单处理器，则总是使用“工作站” GC 模式；</li>
</ul>
<p>除两种主要模式外，还支持两种子模式：并发（默认）或非并发。</p>
<h2 id="11-特殊清理（Finalize）"><a href="#11-特殊清理（Finalize）" class="headerlink" title="11 特殊清理（Finalize）"></a>11 特殊清理（Finalize）</h2><ul>
<li>包含本机资源（文件、网络连接、套接字、互斥体）的类型被 GC 时，GC 会回收对象在托管堆中使用的内存，但会造成本机资源的泄露，故 CLR 提供了终结（finalization）的机制，允许对象在被判定为垃圾之后，但在对象内存被回收之前执行一些代码。任何包装了本机资源（文件、网络连接、套接字、互斥体）的类型都支持终结。CLR 判定一个对象不可达时，对象将终结它自己，释放它包装的本机资源。之后，GC 会从托管堆回收对象。</li>
<li>Object基类定义了受保护的虚方法 Finalize，语法<strong>~ClassName</strong>。</li>
<li>Finalize 是为<strong>释放本机资源</strong>而设计的。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>被视为垃圾的对象在垃圾回收<strong>完毕</strong>后才调用 Finalize 方法，所以这些对象的内存不是马上被回收，造成它被提升为另一代，而这些对象引用的对象也会被提升，导致对象存活时间延长。故<strong>尽量</strong>避免为引用类型的字段定义可终结对象。</li>
<li>Finalize 方法执行时间不可控，且 GC 不保证多个 Finalize 的调用顺序，故在 Finalize 方法中不要访问其他定义了 Finalize 的类型对象。</li>
</ul>
<h2 id="12-dispose"><a href="#12-dispose" class="headerlink" title="12 dispose"></a>12 dispose</h2><ul>
<li>dispose 模式：实现了 IDisposable 接口即实现了 dispose 模式；</li>
<li>若类定义的一个字段的类型实现了 dispose 模式，则类本身也应实现。如果才能在类上调用 Dispose 来释放对象自身使用的资源。</li>
<li><strong>强烈建议</strong>将显式调用 Dispose 方法的代码放到 finally 块中或使用 using 语句块。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>CLR via C# 第21章</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-访问资源步骤&quot;&gt;&lt;a href=&quot;#1-访问资源步骤&quot; class=&quot;headerlink&quot; title=&quot;1 访问资源步骤&quot;&gt;&lt;/a&gt;1 访问资源步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;调用 IL 指令 newobj，为代表资源的类型分配内存（C# 一般使用 new）；&lt;/li&gt;
&lt;li&gt;初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态；&lt;/li&gt;
&lt;li&gt;访问类型的成员来使用资源（有必要可重复）；&lt;/li&gt;
&lt;li&gt;摧毁资源的状态以便清理；&lt;/li&gt;
&lt;li&gt;释放内存（垃圾回收）。
    
    </summary>
    
      <category term="CLR" scheme="http://www.venux.cn/categories/CLR/"/>
    
    
      <category term="C#" scheme="http://www.venux.cn/tags/C/"/>
    
      <category term="CLR" scheme="http://www.venux.cn/tags/CLR/"/>
    
  </entry>
  
  <entry>
    <title>收藏</title>
    <link href="http://www.venux.cn/2017/10/18/%E6%94%B6%E8%97%8F/"/>
    <id>http://www.venux.cn/2017/10/18/收藏/</id>
    <published>2017-10-18T12:20:39.000Z</published>
    <updated>2018-05-14T02:53:19.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><ul>
<li><a href="https://martinfowler.com/articles/injection.html" target="_blank" rel="external">Inversion of Control Containers and the Dependency Injection pattern by Martin Fowler</a></li>
<li><a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/" target="_blank" rel="external">Service Locator is an Anti-Pattern by Mark Seemann</a></li>
</ul>
<h2 id="前端网站"><a href="#前端网站" class="headerlink" title="前端网站"></a>前端网站</h2><ul>
<li><a href="https://modernizr.com/" target="_blank" rel="external">Modernizr</a></li>
<li><a href="https://caniuse.com/" target="_blank" rel="external">Can I Use</a></li>
<li><a href="https://www.w3.org/" target="_blank" rel="external">w3c</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">Mozilla开发者网络</a></li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li><a href="http://www.cnblogs.com/WeiGe/p/5658175.html" target="_blank" rel="external">QPS从0到4000请求每秒，谈达达后台架构演化之路</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编程思想&quot;&gt;&lt;a href=&quot;#编程思想&quot; class=&quot;headerlink&quot; title=&quot;编程思想&quot;&gt;&lt;/a&gt;编程思想&lt;/h2&gt;&lt;h3 id=&quot;依赖注入（DI）&quot;&gt;&lt;a href=&quot;#依赖注入（DI）&quot; class=&quot;headerlink&quot; title=&quot;依
    
    </summary>
    
      <category term="其他" scheme="http://www.venux.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="http://www.venux.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="http://www.venux.cn/2017/10/15/UML%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.venux.cn/2017/10/15/UML笔记/</id>
    <published>2017-10-15T08:36:32.000Z</published>
    <updated>2018-05-14T02:53:19.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-UML介绍"><a href="#1-UML介绍" class="headerlink" title="1 UML介绍"></a>1 UML介绍</h2><p>UML(Unified Modeling Language)又称统一建模语言或标准建模语言，一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，包括由需求分析到规格，到构造和配置。 </p>
<a id="more"></a>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h2><ul>
<li>用例图（use case diagrams）：描述用户需求，从用户的角度描述系统的功能</li>
<li>静态图<ul>
<li>类图（class  diagrams）：显示系统的静态结构</li>
<li>对象图（object diagrams）</li>
</ul>
</li>
<li>交互图<ul>
<li>序列图：描述对象之间的交互顺序，着重体现对象间消息传递的时间顺序</li>
<li>协作图（Collaboration diagrams）：描述对象之间的合作关系，侧重对象之间的消息传递 </li>
</ul>
</li>
<li>行为图<ul>
<li>状态图（Statechart diagrams）：描述对象的所有状态以及事件发生而引起的状态之间的转移</li>
<li>活动图（Activity diagrams）：描述满足用例要求所要进行的活动以及活动时间的约束关系</li>
</ul>
</li>
<li>实现图  <ul>
<li>构件图（Component diagrams）：描述代码构件的物理结构以及各构件之间的依赖关系</li>
<li>部署图（Deployment diagrams）：系统中硬件的物理体系结构</li>
</ul>
</li>
</ul>
<h2 id="3-类图"><a href="#3-类图" class="headerlink" title="3 类图"></a>3 类图</h2><h3 id="3-1-类"><a href="#3-1-类" class="headerlink" title="3.1 类"></a>3.1 类</h3><p>1 类(Class)封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。<br>2 在系统中，每个类具有一定的职责，职责指的是类所担任的任务，即类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类一般只有一种职责，在定义类的时候，将类的职责分解成为类的属性和操作（即方法）。<br>3 类的属性即类的数据职责，类的操作即类的行为职责。</p>
<p><img src="/images/posts/UML1.jpg" alt="类的UML图示"></p>
<ul>
<li>类名，斜体表示抽象类</li>
<li>属性，表示方式：<code>可见性 名称:类型 [= 缺省值]</code>，可见性又分为 +（公有）、-（私有）、#（受保护），缺省值可选项。</li>
<li>操作：类的行为，即成员方法。表示方式：<code>可见性 名称(参数列表) [:返回类型]</code>，返回类型可选项。</li>
</ul>
<h3 id="3-2-接口"><a href="#3-2-接口" class="headerlink" title="3.2 接口"></a>3.2 接口</h3><p><img src="http://www.uml.org.cn/oobject/images/20121123113.jpg" alt="接口的UML图示"></p>
<h3 id="3-3-关系"><a href="#3-3-关系" class="headerlink" title="3.3 关系"></a>3.3 关系</h3><ul>
<li><strong>关联关系</strong>：表示一类对象与另一类对象之间有联系（如将一个类的对象作为另一个类的成员变量）<br><img src="http://www.uml.org.cn/oobject/images/2012112314.jpg" alt="关联关系"><ul>
<li><strong>双向关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112315.jpg" alt="双向关联"></li>
<li><strong>单向关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112316.jpg" alt="单项关联"></li>
<li><strong>自关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112317.jpg" alt="自关联"></li>
<li><strong>多重关联</strong><br><img src="http://www.uml.org.cn/oobject/images/2012112318.jpg" alt="多重关联"><ul>
<li>1..1: 表示另一个类的一个对象只与该类的一个对象有关系</li>
<li>0..*：表示另一个类的一个对象与该类的零个或多个对象有关系</li>
<li>1..*：表示另一个类的一个对象与该类的一个或多个对象有关系</li>
<li>0..1：表示另一个类的一个对象没有或只与该类的一个对象有关系</li>
<li>m..n：表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n)</li>
</ul>
</li>
</ul>
</li>
<li><strong>聚合（Aggregation）关系</strong>：表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。<br><img src="http://www.uml.org.cn/oobject/images/2012112319.jpg" alt="聚合关系"></li>
<li><strong>组合（Composition）关系</strong>：也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123110.jpg" alt="组合关系"></li>
<li><strong>依赖（Dependency）关系</strong>：一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。用带箭头的虚线表示，由依赖的一方指向被依赖的一方。<br><img src="http://www.uml.org.cn/oobject/images/20121123111.jpg" alt="依赖关系"></li>
<li><strong>泛化（Generalization）关系</strong>：用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123112.jpg" alt="泛化关系"></li>
<li><strong>实现（Implementation）关系</strong>：是用来规定接口和实现接口的类或者构建结构的关系，接口是操作的集合，而这些操作就用于规定类或者构建的一种服务。接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系(Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123114.jpg" alt="实现关系"></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/3160571?fr=aladdin&amp;fromid=446747&amp;fromtitle=UML" target="_blank" rel="external">统一建模语音百科</a></li>
<li><a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="external">深入浅出UML类图</a></li>
<li><a href="http://blog.csdn.net/jiuqiyuliang/article/details/8552956/" target="_blank" rel="external">浅谈UML的概念和模型之UML九种图</a></li>
<li><a href="http://blog.csdn.net/fatherican/article/details/44966891" target="_blank" rel="external">UML的9种图例解析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-UML介绍&quot;&gt;&lt;a href=&quot;#1-UML介绍&quot; class=&quot;headerlink&quot; title=&quot;1 UML介绍&quot;&gt;&lt;/a&gt;1 UML介绍&lt;/h2&gt;&lt;p&gt;UML(Unified Modeling Language)又称统一建模语言或标准建模语言，一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，包括由需求分析到规格，到构造和配置。 &lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.venux.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="UML" scheme="http://www.venux.cn/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>缓存解决方案</title>
    <link href="http://www.venux.cn/2017/10/15/%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://www.venux.cn/2017/10/15/缓存解决方案/</id>
    <published>2017-10-15T05:31:10.000Z</published>
    <updated>2018-05-14T02:53:19.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-NoSQL总览"><a href="#1-NoSQL总览" class="headerlink" title="1 NoSQL总览"></a>1 NoSQL总览</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>NoSQL（Not Only SQL）,意即“不仅仅是SQL”，非关系型的数据库</p>
<h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><ul>
<li>键值（key-value）存储数据库</li>
<li>列存储数据库</li>
<li>文档型数据库</li>
<li>图形（Graph)数据库</li>
</ul>
<a id="more"></a>
<h2 id="2-Memcached"><a href="#2-Memcached" class="headerlink" title="2 Memcached"></a>2 Memcached</h2><p>一个自由开源的，高性能，分布式内存对象缓存系统。</p>
<ul>
<li>类型：key-value 存储数据库</li>
<li>优点<ul>
<li>内存</li>
<li>多核，支持多线程操作</li>
</ul>
</li>
<li>缺点<ul>
<li>不支持持久化</li>
<li>本身不支持分布式，只能在客户端通过像一致性哈希类的分布式算法实现</li>
<li>单个 key-value 大小有限，一个value最大只支持 1MB</li>
</ul>
</li>
</ul>
<h2 id="3-Redis"><a href="#3-Redis" class="headerlink" title="3 Redis"></a>3 Redis</h2><p>一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。</p>
<ul>
<li>类型：key-value 存储数据库</li>
<li>优点<ul>
<li>内存</li>
<li>支持持久化（快照，AOF等）</li>
<li>支持服务器端分布式（主从复制方案）</li>
<li>支持多种数据结构</li>
<li>单个 key-value 大小有限，一个 value 最大只支持 512MB</li>
<li>支持pub/sub消息订阅机制</li>
</ul>
</li>
<li>缺点<ul>
<li>单核，不支持多核心多线程操作</li>
</ul>
</li>
</ul>
<h2 id="4-MongoDB"><a href="#4-MongoDB" class="headerlink" title="4 MongoDB"></a>4 MongoDB</h2><p>一个基于分布式文件存储的数据库,文档型的非关系型数据库，与上面两者不同。</p>
<ul>
<li>类型：文档存储数据库</li>
<li>优点<ul>
<li>支持持久化（binlog）</li>
</ul>
</li>
<li>缺点   <ul>
<li>不支持事务</li>
</ul>
</li>
</ul>
<h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5 应用场景"></a>5 应用场景</h2><p>需要根据使用的具体场景分析：</p>
<ul>
<li>需要数据持久化或主从复制，只能采用 Redis。</li>
<li>需要缓存的数据只是 key-value 这样简单的结构，采用 memcache；若涉及不同数据结构，排序等选用 Redis。</li>
</ul>
<h3 id="5-1-推荐"><a href="#5-1-推荐" class="headerlink" title="5.1 推荐"></a>5.1 推荐</h3><ul>
<li>Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息等）。</li>
<li>Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。</li>
<li>MongoDB:主要解决海量数据的访问效率问题。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cnblogs.com/EE-NovRain/p/3268476.html" target="_blank" rel="external">Redis和Memcache对比及选择</a></li>
<li><a href="http://www.cnblogs.com/EE-NovRain/p/3268465.html" target="_blank" rel="external">NoSQL发展简史、粗略分类及选择</a></li>
<li><a href="http://www.cnblogs.com/cac2020/category/906633.html" target="_blank" rel="external">分布式缓存学习之一：Memcached, Redis, MongoDB区别</a></li>
<li><a href="https://yq.aliyun.com/articles/38224" target="_blank" rel="external">Redis、Memcache和MongoDB的区别</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-NoSQL总览&quot;&gt;&lt;a href=&quot;#1-NoSQL总览&quot; class=&quot;headerlink&quot; title=&quot;1 NoSQL总览&quot;&gt;&lt;/a&gt;1 NoSQL总览&lt;/h2&gt;&lt;h3 id=&quot;1-1-介绍&quot;&gt;&lt;a href=&quot;#1-1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 介绍&quot;&gt;&lt;/a&gt;1.1 介绍&lt;/h3&gt;&lt;p&gt;NoSQL（Not Only SQL）,意即“不仅仅是SQL”，非关系型的数据库&lt;/p&gt;
&lt;h3 id=&quot;1-2-分类&quot;&gt;&lt;a href=&quot;#1-2-分类&quot; class=&quot;headerlink&quot; title=&quot;1.2 分类&quot;&gt;&lt;/a&gt;1.2 分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;键值（key-value）存储数据库&lt;/li&gt;
&lt;li&gt;列存储数据库&lt;/li&gt;
&lt;li&gt;文档型数据库&lt;/li&gt;
&lt;li&gt;图形（Graph)数据库&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="架构" scheme="http://www.venux.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://www.venux.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="解决方案" scheme="http://www.venux.cn/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="缓存" scheme="http://www.venux.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>高并发网站解决方案</title>
    <link href="http://www.venux.cn/2017/10/15/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://www.venux.cn/2017/10/15/高并发网站解决方案/</id>
    <published>2017-10-15T03:56:20.000Z</published>
    <updated>2018-05-14T02:53:19.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1 服务器"></a>1 服务器</h2><ul>
<li>使用高性能CPU主机</li>
<li>数据库使用物理机，避免虚拟机，提升IO性能</li>
<li>使用SSD磁盘，提升IO性能</li>
<li>提升带宽</li>
</ul>
<h2 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2 数据库"></a>2 数据库</h2><h3 id="2-1-读写分离"><a href="#2-1-读写分离" class="headerlink" title="2.1 读写分离"></a>2.1 读写分离</h3><p>主从同步，实时将主库的数据增量复制到从库，而且一个主库可以连接多个从库同步。</p>
<ul>
<li>减轻主库（写）压力</li>
<li>从库（读）可水平扩展（加从库机器）</li>
<li>避免主从同步延迟<ul>
<li>优化MySQL参数，比如增大<code>innodb_buffer_pool-size</code>，让更多操作在内存中完成，减少磁盘操作</li>
<li>硬件推荐的方案</li>
<li>业务代码优化，将实时性要求高的某些操作，使用主库做读操作</li>
</ul>
</li>
</ul>
<h3 id="2-2-垂直分库"><a href="#2-2-垂直分库" class="headerlink" title="2.2 垂直分库"></a>2.2 垂直分库</h3><p>按业务拆分成不同的业务数据库，每个系统仅访问对应业务的数据库，避免或减少跨库访问。</p>
<ul>
<li>禁用或少用<code>join</code>操作，应在程序中组装数据，让SQL更简单，一方面为以后进一步拆分业务做准备，另一方面也避免了 MySQL 中 join 的性能较低问题。</li>
</ul>
<h3 id="2-3-水平分库（sharding）"><a href="#2-3-水平分库（sharding）" class="headerlink" title="2.3 水平分库（sharding）"></a>2.3 水平分库（sharding）</h3><p>单表数据量过大影响读写性能，而又不能进一步垂直拆分时，考虑将数据按字段分类（如 ID，城市）拆分为多个表，即水平分库，拆分时需要考虑数据分布是否均匀、数据聚合度是否较高、冗余表等。</p>
<h2 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3 缓存"></a>3 缓存</h2><p><a href="">参见缓存解决方案</a></p>
<h2 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4 消息队列"></a>4 消息队列</h2><h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5 代码"></a>5 代码</h2><h3 id="5-1-异步编程（async-await）"><a href="#5-1-异步编程（async-await）" class="headerlink" title="5.1 异步编程（async/await）"></a>5.1 异步编程（async/await）</h3><h2 id="6-前端"><a href="#6-前端" class="headerlink" title="6 前端"></a>6 前端</h2><h3 id="6-1-HTML静态化"><a href="#6-1-HTML静态化" class="headerlink" title="6.1 HTML静态化"></a>6.1 HTML静态化</h3><h2 id="7-负载均衡、反向代理（nginx）"><a href="#7-负载均衡、反向代理（nginx）" class="headerlink" title="7 负载均衡、反向代理（nginx）"></a>7 负载均衡、反向代理（nginx）</h2><h2 id="8-内容分发网络（CDN）"><a href="#8-内容分发网络（CDN）" class="headerlink" title="8 内容分发网络（CDN）"></a>8 内容分发网络（CDN）</h2><p>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。</p>
<h2 id="9-分布式集群"><a href="#9-分布式集群" class="headerlink" title="9 分布式集群"></a>9 分布式集群</h2><ul>
<li>服务器按功能划分：Web服务器（集群）、数据库服务器（集群）、缓存服务器（集群）、附件服务器（集群）等。</li>
</ul>
<h2 id="10-镜像"><a href="#10-镜像" class="headerlink" title="10 镜像"></a>10 镜像</h2><p>CDN的实现分为三类：镜像、高速缓存、专线。</p>
<ul>
<li>镜像站点（Mirror Site），是最常见的，它让内容直接发布，适用于静态和准动态的数据同步。但是购买和维护新服务器的费用较高，还必须在各个地区设置镜像服务器，配备专业技术人员进行管理与维护。对于大型网站来说，更新所用的带宽成本也大大提高了。</li>
<li>高速缓存，成本较低，适用于静态内容。Internet的统计表明，超过80%的用户经常访问的是20%的网站的内容，在这个规律下，缓存服务器可以处理大部分客户的静态请求，而原始的服务器只需处理约20%左右的非缓存请求和动态请求，于是大大加快了客户请求的响应时间，并降低了原始服务器的负载。　　CDN服务一般会在全国范围内的关键节点上放置缓存服务器。</li>
<li>专线，让用户直接访问数据源，可以实现数据的动态同步。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>二八定律：80%的业务访问集中在20%的数据上。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/WeiGe/p/5658175.html" target="_blank" rel="external">QPS从0到4000请求每秒，谈达达后台架构演化之路</a></li>
<li><a href="http://blog.csdn.net/y_h_t/article/details/6322823" target="_blank" rel="external">高并发量网站解决方案</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-服务器&quot;&gt;&lt;a href=&quot;#1-服务器&quot; class=&quot;headerlink&quot; title=&quot;1 服务器&quot;&gt;&lt;/a&gt;1 服务器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用高性能CPU主机&lt;/li&gt;
&lt;li&gt;数据库使用物理机，避免虚拟机，提升IO性能&lt;/li&gt;
&lt;li&gt;使
    
    </summary>
    
      <category term="架构" scheme="http://www.venux.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://www.venux.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="解决方案" scheme="http://www.venux.cn/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>线程笔记</title>
    <link href="http://www.venux.cn/2017/10/13/%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.venux.cn/2017/10/13/线程笔记/</id>
    <published>2017-10-13T11:26:03.000Z</published>
    <updated>2018-05-14T02:53:19.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h2><h3 id="1-1-进程-amp-线程"><a href="#1-1-进程-amp-线程" class="headerlink" title="1.1 进程&amp;线程"></a>1.1 进程&amp;线程</h3><ul>
<li><strong>进程</strong>：应用程序的实例要使用的资源的集合。<ul>
<li>每个进程都被赋予一个虚拟地址空间，确保进程中的数据和代码无法由另一个进程访问，确保了应用程序实例的健壮性；</li>
<li>进程无法访问OS内核代码，保证系统稳定性和安全性。</li>
</ul>
</li>
<li>线程<a id="more"></a>
</li>
</ul>
<h3 id="1-2-垃圾回收背后的线程情况"><a href="#1-2-垃圾回收背后的线程情况" class="headerlink" title="1.2 垃圾回收背后的线程情况"></a>1.2 垃圾回收背后的线程情况</h3><p>执行垃圾回收时，CLR 必须挂起（暂停）所有线程，遍历它们的栈来查找根以便对堆中的对象进行标记，再次遍历它们的栈（有的对象在压缩期间发生了移动，所以要更新它们的根），再恢复所有的线程。所以，较少线程的数量会显著提升垃圾回收的性能。</p>
<h3 id="1-3-调试背后的线程情况"><a href="#1-3-调试背后的线程情况" class="headerlink" title="1.3 调试背后的线程情况"></a>1.3 调试背后的线程情况</h3><p>每次使用调试器并遇到断电，Windows 都会挂起正在调试的应用程序中的所有线程，并在单步执行或者运行应用程序后恢复所有线程。所以，线程越多，调试体验越差。</p>
<h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><h2 id="2-深入"><a href="#2-深入" class="headerlink" title="2 深入"></a>2 深入</h2><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="2-1-要构建高性能应用程序和组件，就应该尽量避免上下文切换；"><a href="#2-1-要构建高性能应用程序和组件，就应该尽量避免上下文切换；" class="headerlink" title="2.1 要构建高性能应用程序和组件，就应该尽量避免上下文切换；"></a>2.1 要构建高性能应用程序和组件，就应该尽量避免上下文切换；</h3><h3 id="2-2-应尽量使用线程池来执行异步操作；"><a href="#2-2-应尽量使用线程池来执行异步操作；" class="headerlink" title="2.2 应尽量使用线程池来执行异步操作；"></a>2.2 应尽量使用线程池来执行异步操作；</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基础知识&quot;&gt;&lt;a href=&quot;#1-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1 基础知识&quot;&gt;&lt;/a&gt;1 基础知识&lt;/h2&gt;&lt;h3 id=&quot;1-1-进程-amp-线程&quot;&gt;&lt;a href=&quot;#1-1-进程-amp-线程&quot; class=&quot;headerlink&quot; title=&quot;1.1 进程&amp;amp;线程&quot;&gt;&lt;/a&gt;1.1 进程&amp;amp;线程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：应用程序的实例要使用的资源的集合。&lt;ul&gt;
&lt;li&gt;每个进程都被赋予一个虚拟地址空间，确保进程中的数据和代码无法由另一个进程访问，确保了应用程序实例的健壮性；&lt;/li&gt;
&lt;li&gt;进程无法访问OS内核代码，保证系统稳定性和安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程
    
    </summary>
    
      <category term="ASP.NET" scheme="http://www.venux.cn/categories/ASP-NET/"/>
    
      <category term="基础" scheme="http://www.venux.cn/categories/ASP-NET/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C#" scheme="http://www.venux.cn/tags/C/"/>
    
      <category term="APS.NET" scheme="http://www.venux.cn/tags/APS-NET/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://www.venux.cn/2017/10/10/%E9%9D%A2%E8%AF%95/"/>
    <id>http://www.venux.cn/2017/10/10/面试/</id>
    <published>2017-10-10T12:03:44.000Z</published>
    <updated>2018-05-14T02:53:19.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-和-NET"><a href="#1-C-和-NET" class="headerlink" title="1. C#和.NET"></a>1. C#和.NET</h2><h3 id="1-1-C-基础知识"><a href="#1-1-C-基础知识" class="headerlink" title="1.1 C#基础知识"></a>1.1 C#基础知识</h3><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><ul>
<li>private【Private】 私有（定义类型、嵌套类型）</li>
<li>protected【Family】 保护（定义类型、嵌套类型、不同程序集中的派生类型）</li>
<li>C#不支持【Family and Assembly】（定义类型、嵌套类型、同一程序集中的派生类型）</li>
<li>internal【Assembly】 内部（同一程序集中的所有类型）</li>
<li>protected internal【Family or Assembly】（定义类型、嵌套类型、同一程序集中的所有类型，不同程序集中的派生类型）</li>
<li>public【Public】 公有</li>
</ul>
<p><em>PS：</em></p>
<ul>
<li>【】中为CLR术语。</li>
<li><code>C#</code>派生类型重写基类型定义的成员，<code>C#编译器</code>要求两者具有相同可访问性，<code>CLR</code>允许放宽但不允许收紧成员的可访问性。</li>
</ul>
<a id="more"></a>
<h4 id="值类型、引用类型"><a href="#值类型、引用类型" class="headerlink" title="值类型、引用类型"></a>值类型、引用类型</h4><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>1 总是从<code>托管堆</code>分配，new 操作符返回指向对象的内存地址；<br>2 堆上分配的每个对象都有一些额外成员（类型对象指针、同步块索引），这些成员必须初始化；<br>3 对象中的其他字节（为字段而设）总是设为零；<br>4 从托管堆分配对象时，可能强制执行一次垃圾回收。</p>
<h5 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h5><p>1 <code>一般</code>在<code>线程栈</code>上分配；<br>2 优点：缓解托管堆的压力，减少应用程序生存期内的垃圾回收次数；<br>3 所有值类型必须从 System.ValueType 派生；<br>4 值类型可以实现一个或多个接口；<br>5 所有值类型隐式密封；</p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li>值类型对象两种表示形式：未装箱和已装箱，引用类型总是已装箱</li>
<li>值类型从 System.ValueType 派生，该类型重写了 Equals 方法，能在两对象的字段值完全匹配返回 true，也重写了 GetHashCode 方法，算法会将实例字段的值计算进去。<em>由于默认实现存在性能问题，故定义值类型需重写。</em></li>
<li>值类型隐式密封，故不应引入任何虚方法，且所有方法不能时抽象方法，所有方法都隐式密封。</li>
<li>引用类型包含堆中对象的地址，默认初始化为 null，值类型总是包含基础类型的一个值，默认初始化为 0。</li>
<li>值类型赋给另一个值类型变量，会执行逐字段复制，引用类型则只复制内存地址，故对值类型变量执行操作不会影响另一个值类型，引用类型则不同。</li>
<li>由于未装箱的值类型不在堆上分配，一旦定义了该类型的实例的方法不再活动，分配的存储就会释放，而不等垃圾回收。</li>
</ul>
<h5 id="值类型设计前提："><a href="#值类型设计前提：" class="headerlink" title="值类型设计前提："></a>值类型设计前提：</h5><ul>
<li>类型具有基元类型的行为，没有成员会改变类型的任何实例字段。即不可变（immutable），建议将全部字段标记为 readonly。</li>
<li>类型不需要从其他类型继承。</li>
<li>类型也不派生其他任何类型。</li>
<li>类型的实例较小（16字节或更小）。</li>
<li>类型的实例较大（大于16字节），但不作为方法实参传递，也不作为返回参数。</li>
</ul>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul>
<li><a href="http://www.cnblogs.com/venux/p/6307561.html" target="_blank" rel="external">个人笔记</a></li>
</ul>
<h4 id="委托、事件"><a href="#委托、事件" class="headerlink" title="委托、事件"></a>委托、事件</h4><h4 id="重载、重写"><a href="#重载、重写" class="headerlink" title="重载、重写"></a>重载、重写</h4><h4 id="接口、抽象类"><a href="#接口、抽象类" class="headerlink" title="接口、抽象类"></a>接口、抽象类</h4><h4 id="out和ref"><a href="#out和ref" class="headerlink" title="out和ref"></a>out和ref</h4><h4 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h4><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><ul>
<li>Equals:如果两个<code>对象</code>具有相同值，就返回true。<ul>
<li>对象相等性和同一性</li>
</ul>
</li>
<li>GetHashCode:若对象要在哈希表集合（如Dictionary）中作为键，则应重写该方法。<ul>
<li>良好分布：指针对所有输入，GetHashCode生成的哈希值应该在所有整数中产生一个随机的分布。</li>
</ul>
</li>
<li>ToString:默认返回类型的完整名称（this.GetType().FullName）。</li>
<li>GetType:返回类型的一个实例。<ul>
<li>非虚方法，防止类重写，隐瞒类型，从而破坏类型安全性。</li>
</ul>
</li>
<li><a href="https://msdn.microsoft.com/en-us/library/system.object.memberwiseclone(v=vs.110" target="_blank" rel="external">MemberwiseClone</a>.aspx):浅拷贝。<ul>
<li>protected</li>
<li>非虚方法</li>
<li>The MemberwiseClone method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object. If a field is a <code>value</code> type, <code>a bit-by-bit copy of the field is performed</code>. If a field is a <code>reference</code> type, <code>the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object</code>.（意即：obj和cloneObj对应的值类型不会同时改变；引用类型同时改变）。    </li>
</ul>
</li>
<li>Finalize:垃圾回收之前调用该<code>虚</code>方法，可重写进行对象清理工作。</li>
</ul>
<h4 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h4><p>1 计算类型及其所有基类型（直到Object）中定义的所有<code>实例字段</code>需要的字节数，堆上每个对象都需要一些额外的成员（overhead成员、开销成员），包括<code>类型对象指针type object pointer</code>和<code>同步块索引sync block index</code>，CLR利用这些成员管理对象，额外成员的字节数需要计入对象大小。</p>
<p>2 从<code>托管堆</code>分配类型要求的字节数，从而分配对象的内存，所有字节设为零。</p>
<p>3 初始化对象的类型对象指针和同步块索引。</p>
<p>4 调用类型的实例构造器，传递实参，编译器自动生成代码调用基类构造器，并负责初始化定义的实例字段，最终调用Object的构造器，返回。</p>
<p>5 返回指向新建对象的一个引用（指针）。</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol>
<li>C#运行类型定义转换操作符方法，但只有使用转型表达式才调用，使用<code>as</code>或<code>is</code>永不调用它们。</li>
</ol>
<h4 id="类型、对象、线程栈、托管堆在运行时的相互关系"><a href="#类型、对象、线程栈、托管堆在运行时的相互关系" class="headerlink" title="类型、对象、线程栈、托管堆在运行时的相互关系"></a>类型、对象、线程栈、托管堆在运行时的相互关系</h4><p>CLR via C# 4.4 P90</p>
<h4 id="字段和属性有什么区别"><a href="#字段和属性有什么区别" class="headerlink" title="字段和属性有什么区别"></a>字段和属性有什么区别</h4><ul>
<li><p>答一：两者都是类的成员。不同的是：<br>  1 字段是数据成员，属性是方法成员;<br>  2 访问上对于属性访问需要使用访问元get,set，字段没有访问元直接赋值或者取值;<br>  3 属性能override，visual字段不能。</p>
</li>
<li><p>答二：如果你编写一些控件给别的开发者用，而需要给他们提供“数据绑定”这种傻瓜化的机制，那么使用属性才可以做到。<br>属性是方法而字段不是，当你用反射去掉用的时候，它们有各自的API。因为属性是方法，所以它可以和方法那样定义在接口中，或者被继承和重写，重写属性被ORM/AOP等框架用来注入代码。</p>
</li>
</ul>
<h4 id="抽象方法，和虚方法的区别"><a href="#抽象方法，和虚方法的区别" class="headerlink" title="抽象方法，和虚方法的区别"></a>抽象方法，和虚方法的区别</h4><ul>
<li>抽象方法一定是虚方法，虚方法未必是抽象方法。</li>
<li>虚方法是指可以被继承类重写的方法，而抽象方法是指，基类是抽象类，没有实现它，因此必须被继承类重写的方法。</li>
</ul>
<h4 id="new的几种用法"><a href="#new的几种用法" class="headerlink" title="new的几种用法"></a>new的几种用法</h4><ul>
<li>创建对象或者结构（只是用于调用结构构造函数）；</li>
<li>隐藏基类成员；</li>
<li>泛型里用于约束</li>
</ul>
<h4 id="什么叫做泛型"><a href="#什么叫做泛型" class="headerlink" title="什么叫做泛型"></a>什么叫做泛型</h4><ul>
<li>从编程的角度说是在定义类或者方法的时候省去具体的类型，由调用者来指定，类型+泛型类型合成得到真正的类型。</li>
<li>从实现机制上说，泛型是CLR在运行时动态根据泛型类型创建的匿名类型。</li>
<li>从OO设计的角度说，泛型体现了多态性。</li>
<li>泛型使得程序员可以复用数据结构和算法，并且适应不同的类型，享有编译期间的强类型检查和语法提示。<br>  一些经典的FCL提供的泛型类型和接口,List<t>、Dictionary<t1, t2="">这个属于复用数据结构,IComparer<t>、IEnumerable<t>这个属于复用算法</t></t></t1,></t></li>
</ul>
<h4 id="什么叫做类"><a href="#什么叫做类" class="headerlink" title="什么叫做类"></a>什么叫做类</h4><p>就C#而言，类是对象的模板，对象是类的实例。C#是强类型语言，一切皆需要类型，除了内置的简单类型，那些其实例为引用对象的都叫做类。C#也允许定义抽象类和密封类，以及两者的叠加——静态类，它们都无法实例化，其实这是编译器的限制，本质上它们和一般的类没有区别，是特殊情况。</p>
<h4 id="EF的理解"><a href="#EF的理解" class="headerlink" title="EF的理解"></a>EF的理解</h4><ul>
<li>对象关系映射（ORM）机制和LINQ To EF Provider，在此基础上的缓存机制、延迟加载、对象状态跟踪、事务等等。</li>
<li>EF是微软官方的ORM框架，结束了之前各种第三方ORM混战的局面，统一了API，这无疑是开发者的福音。EF拥有非常优雅的，基于C#/VB语言优化的API，比如原生的LINQ查询，自然的Code First的对数据结构的定义，Fluent API方式的数据库和关系的定义等等。VS完美支持EF并且提供了多种数据库的适配。</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>开发调试时打开编译器的/checked+开关，虽然会慢点，但能轻松进行溢出检查，及时修正BUG。正式发布时使用/checked-开关。</li>
<li>System.Decimal是<code>非常特殊</code>的类型，虽然C#视其为基元类型，但CLR不然。内部提供各种计算方法和操作符重载，故处理速度慢于CLR基元类型。</li>
</ul>
<h3 id="1-2-ASP-NET"><a href="#1-2-ASP-NET" class="headerlink" title="1.2 ASP.NET"></a>1.2 ASP.NET</h3><h4 id="页面传值"><a href="#页面传值" class="headerlink" title="页面传值"></a>页面传值</h4><ul>
<li><a href="http://www.cnblogs.com/zhangkai2237/archive/2012/05/06/2486462.html" target="_blank" rel="external">参考1</a></li>
</ul>
<h4 id="ASP-NET服务器控件的生命周期"><a href="#ASP-NET服务器控件的生命周期" class="headerlink" title="ASP.NET服务器控件的生命周期"></a>ASP.NET服务器控件的生命周期</h4><ul>
<li><a href="http://www.cnblogs.com/waters/articles/3373013.html" target="_blank" rel="external">参考1</a></li>
<li><a href="http://www.cnblogs.com/peterYong/p/6556597.html" target="_blank" rel="external">参考2</a></li>
</ul>
<h4 id="ASP-NET七个内置对象"><a href="#ASP-NET七个内置对象" class="headerlink" title="ASP.NET七个内置对象"></a>ASP.NET七个内置对象</h4><h3 id="1-3-名词解释"><a href="#1-3-名词解释" class="headerlink" title="1.3 名词解释"></a>1.3 名词解释</h3><ul>
<li>FCL(Framework Class Library)框架类库</li>
<li>CLS(Common Language Stander)</li>
<li>CLR(Common Language Runtime)公共语言运行时</li>
<li>IDL(Interface Definition Language)接口定义语言</li>
<li>IL(Intermediate Language)中间语言</li>
</ul>
<h3 id="1-4-IL"><a href="#1-4-IL" class="headerlink" title="1.4 IL"></a>1.4 IL</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li>add：两值相加，不执行溢出检查</li>
<li>add.ovf：两值相加，执行溢出检查，抛出System.OverflowException</li>
<li>sub：减</li>
<li>sub.ovf</li>
<li>mul：乘</li>
<li>mul.ovf</li>
<li>conv：转换</li>
<li>conv.ovf</li>
</ul>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li>CLR via C#(第4版)</li>
<li><a href="http://bbs.csdn.net/topics/390919248" target="_blank" rel="external">文章一</a></li>
</ul>
<h2 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2.数据库"></a>2.数据库</h2><h3 id="2-1-基础"><a href="#2-1-基础" class="headerlink" title="2.1 基础"></a>2.1 基础</h3><ul>
<li>Table1含有字段Col1，Col2，Col3，请用一条标准SQL选出Col2重复条数&gt;=2的所有记录。<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">    <span class="keyword">COUNT</span>(<span class="number">1</span>)</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    Table1</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></div><div class="line">    Col2</div><div class="line"><span class="keyword">HAVING</span></div><div class="line">    <span class="keyword">COUNT</span>(COL2) &gt;= <span class="number">2</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-SQL性能优化"><a href="#2-2-SQL性能优化" class="headerlink" title="2.2 SQL性能优化"></a>2.2 SQL性能优化</h3><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><h2 id="3-数据结构和算法"><a href="#3-数据结构和算法" class="headerlink" title="3. 数据结构和算法"></a>3. 数据结构和算法</h2><h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><h3 id="3-2-算法"><a href="#3-2-算法" class="headerlink" title="3.2 算法"></a>3.2 算法</h3><h4 id="3-2-1-冒泡排序"><a href="#3-2-1-冒泡排序" class="headerlink" title="3.2.1 冒泡排序"></a>3.2.1 冒泡排序</h4><h4 id="3-2-2-快速排序"><a href="#3-2-2-快速排序" class="headerlink" title="3.2.2 快速排序"></a>3.2.2 快速排序</h4><h4 id="3-2-3-冒泡排序"><a href="#3-2-3-冒泡排序" class="headerlink" title="3.2.3 冒泡排序"></a>3.2.3 冒泡排序</h4><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://github.com/aalhour/C-Sharp-Algorithms" target="_blank" rel="external">https://github.com/aalhour/C-Sharp-Algorithms</a></p>
<h2 id="4-编程思想"><a href="#4-编程思想" class="headerlink" title="4. 编程思想"></a>4. 编程思想</h2><h3 id="4-1-原则"><a href="#4-1-原则" class="headerlink" title="4.1 原则"></a>4.1 原则</h3><ul>
<li>SOLID</li>
</ul>
<h3 id="4-2-设计模式"><a href="#4-2-设计模式" class="headerlink" title="4.2 设计模式"></a>4.2 设计模式</h3><h3 id="4-3-MVC"><a href="#4-3-MVC" class="headerlink" title="4.3 MVC"></a>4.3 MVC</h3><h3 id="4-4-DDD"><a href="#4-4-DDD" class="headerlink" title="4.4 DDD"></a>4.4 DDD</h3><h2 id="5-前端"><a href="#5-前端" class="headerlink" title="5. 前端"></a>5. 前端</h2><h3 id="5-1-JavaScript"><a href="#5-1-JavaScript" class="headerlink" title="5.1 JavaScript"></a>5.1 JavaScript</h3><h3 id="5-2-JQuery"><a href="#5-2-JQuery" class="headerlink" title="5.2 JQuery"></a>5.2 JQuery</h3><h3 id="5-3-性能优化"><a href="#5-3-性能优化" class="headerlink" title="5.3 性能优化"></a>5.3 性能优化</h3><h3 id="5-4-其他"><a href="#5-4-其他" class="headerlink" title="5.4 其他"></a>5.4 其他</h3><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><h3 id="6-1-新技术"><a href="#6-1-新技术" class="headerlink" title="6.1 新技术"></a>6.1 新技术</h3><h3 id="6-2-职业规划"><a href="#6-2-职业规划" class="headerlink" title="6.2 职业规划"></a>6.2 职业规划</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-C-和-NET&quot;&gt;&lt;a href=&quot;#1-C-和-NET&quot; class=&quot;headerlink&quot; title=&quot;1. C#和.NET&quot;&gt;&lt;/a&gt;1. C#和.NET&lt;/h2&gt;&lt;h3 id=&quot;1-1-C-基础知识&quot;&gt;&lt;a href=&quot;#1-1-C-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1.1 C#基础知识&quot;&gt;&lt;/a&gt;1.1 C#基础知识&lt;/h3&gt;&lt;h4 id=&quot;访问修饰符&quot;&gt;&lt;a href=&quot;#访问修饰符&quot; class=&quot;headerlink&quot; title=&quot;访问修饰符&quot;&gt;&lt;/a&gt;访问修饰符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;private【Private】 私有（定义类型、嵌套类型）&lt;/li&gt;
&lt;li&gt;protected【Family】 保护（定义类型、嵌套类型、不同程序集中的派生类型）&lt;/li&gt;
&lt;li&gt;C#不支持【Family and Assembly】（定义类型、嵌套类型、同一程序集中的派生类型）&lt;/li&gt;
&lt;li&gt;internal【Assembly】 内部（同一程序集中的所有类型）&lt;/li&gt;
&lt;li&gt;protected internal【Family or Assembly】（定义类型、嵌套类型、同一程序集中的所有类型，不同程序集中的派生类型）&lt;/li&gt;
&lt;li&gt;public【Public】 公有&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;PS：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【】中为CLR术语。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C#&lt;/code&gt;派生类型重写基类型定义的成员，&lt;code&gt;C#编译器&lt;/code&gt;要求两者具有相同可访问性，&lt;code&gt;CLR&lt;/code&gt;允许放宽但不允许收紧成员的可访问性。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="面试" scheme="http://www.venux.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://www.venux.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaEEE开发环境搭建</title>
    <link href="http://www.venux.cn/2017/09/18/JavaEE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.venux.cn/2017/09/18/JavaEE开发环境搭建/</id>
    <published>2017-09-18T10:46:11.000Z</published>
    <updated>2018-05-14T02:53:19.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java环境"><a href="#1-Java环境" class="headerlink" title="1.Java环境"></a>1.Java环境</h2><h3 id="1-1-Java下载"><a href="#1-1-Java下载" class="headerlink" title="1.1 Java下载"></a>1.1 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">Java下载</a></h3><h3 id="1-2-环境变量配置"><a href="#1-2-环境变量配置" class="headerlink" title="1.2 环境变量配置"></a>1.2 环境变量配置</h3><ol>
<li><strong>JAVA_HOME</strong>:C:\Program Files\Java\jdk1.8.0_144（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%JAVA_HOME%\bin;</li>
<li><strong>CLASS_PATH</strong>:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</li>
</ol>
<h3 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h3><ul>
<li><strong>java-version</strong>:版本号</li>
<li><strong>java</strong>:Java环境</li>
<li><strong>javac</strong>:Java编译器</li>
</ul>
<h3 id="1-4-Eclipse集成"><a href="#1-4-Eclipse集成" class="headerlink" title="1.4 Eclipse集成"></a>1.4 Eclipse集成</h3><ul>
<li><strong>默认</strong>：Eclipse 会自动关联环境变量中配置的 JDK。</li>
<li><strong>手动</strong>：“Window”–“Preferences”–“Java”–“Installed JREs”–“Add”–“Standard VM”–选择jdk安装目录。 （多个版本的JDK手工进行配置）</li>
</ul>
<a id="more"></a>
<h2 id="2-Tomcat服务器"><a href="#2-Tomcat服务器" class="headerlink" title="2.Tomcat服务器"></a>2.Tomcat服务器</h2><h3 id="2-1-Tomcat下载"><a href="#2-1-Tomcat下载" class="headerlink" title="2.1 Tomcat下载"></a>2.1 <a href="http://tomcat.apache.org/download-90.cgi" target="_blank" rel="external">Tomcat下载</a></h3><h3 id="2-2-环境变量配置"><a href="#2-2-环境变量配置" class="headerlink" title="2.2 环境变量配置"></a>2.2 环境变量配置</h3><ol>
<li><strong>CATALINA_HOME</strong>：C:\Program Files\Tomcat 8.5（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%CATALINA_HOME%\bin;</li>
</ol>
<h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h3><ul>
<li><strong>localhost:8080</strong>:Tomcat默认主页</li>
</ul>
<h3 id="2-4-Eclipse集成"><a href="#2-4-Eclipse集成" class="headerlink" title="2.4 Eclipse集成"></a>2.4 Eclipse集成</h3><ul>
<li>“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。</li>
</ul>
<h2 id="3-Eclipse-IDE"><a href="#3-Eclipse-IDE" class="headerlink" title="3.Eclipse IDE"></a>3.Eclipse IDE</h2><h3 id="3-1-Eclipse下载"><a href="#3-1-Eclipse下载" class="headerlink" title="3.1 Eclipse下载"></a>3.1 <a href="https://www.eclipse.org/downloads/" target="_blank" rel="external">Eclipse下载</a></h3><h2 id="4-Maven"><a href="#4-Maven" class="headerlink" title="4.Maven"></a>4.Maven</h2><p>基于项目对象模型POM（Project Object Model），用来管理项目的构建、报告和文档的软件项目管理工具。主要提供：</p>
<ul>
<li>统一开发规范和工具</li>
<li>统一管理 jar 包</li>
</ul>
<h3 id="4-1-Maven下载"><a href="#4-1-Maven下载" class="headerlink" title="4.1 Maven下载"></a>4.1 <a href="http://maven.apache.org/download.cgi" target="_blank" rel="external">Maven下载</a></h3><h3 id="4-2-环境变量配置"><a href="#4-2-环境变量配置" class="headerlink" title="4.2 环境变量配置"></a>4.2 环境变量配置</h3><ol>
<li><strong>MAVEN_HOME</strong>:C:\Program Files\apache-maven-3.5.0（注：结尾不加分号）</li>
<li><strong>PATH</strong>:%MAVEN_HOME%\lib;</li>
<li><strong>MAVEN_OPTS</strong>: -Xms128m -Xmx512m;(设置Maven可用内存大小)</li>
</ol>
<h3 id="4-3-测试"><a href="#4-3-测试" class="headerlink" title="4.3 测试"></a>4.3 测试</h3><ul>
<li><strong>maven -v</strong>:版本号</li>
</ul>
<h3 id="4-4-配置文件"><a href="#4-4-配置文件" class="headerlink" title="4.4 配置文件"></a>4.4 配置文件</h3><p><code>‪C:\Program Files\apache-maven-3.5.0\conf\settings.xml</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1 <a href="http://maven.apache.org/index.html" target="_blank" rel="external">Maven官网</a><br>2 <a href="http://blog.csdn.net/column/details/maven-it.html" target="_blank" rel="external">Maven入门</a><br>3 <a href="http://blog.csdn.net/lfsfxy9/article/details/9397937" target="_blank" rel="external">Eclipse Maven插件安装</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Java环境&quot;&gt;&lt;a href=&quot;#1-Java环境&quot; class=&quot;headerlink&quot; title=&quot;1.Java环境&quot;&gt;&lt;/a&gt;1.Java环境&lt;/h2&gt;&lt;h3 id=&quot;1-1-Java下载&quot;&gt;&lt;a href=&quot;#1-1-Java下载&quot; class=&quot;headerlink&quot; title=&quot;1.1 Java下载&quot;&gt;&lt;/a&gt;1.1 &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java下载&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;1-2-环境变量配置&quot;&gt;&lt;a href=&quot;#1-2-环境变量配置&quot; class=&quot;headerlink&quot; title=&quot;1.2 环境变量配置&quot;&gt;&lt;/a&gt;1.2 环境变量配置&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JAVA_HOME&lt;/strong&gt;:C:\Program Files\Java\jdk1.8.0_144（注：结尾不加分号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PATH&lt;/strong&gt;:%JAVA_HOME%\bin;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLASS_PATH&lt;/strong&gt;:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-3-测试&quot;&gt;&lt;a href=&quot;#1-3-测试&quot; class=&quot;headerlink&quot; title=&quot;1.3 测试&quot;&gt;&lt;/a&gt;1.3 测试&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;java-version&lt;/strong&gt;:版本号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;java&lt;/strong&gt;:Java环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;javac&lt;/strong&gt;:Java编译器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-4-Eclipse集成&quot;&gt;&lt;a href=&quot;#1-4-Eclipse集成&quot; class=&quot;headerlink&quot; title=&quot;1.4 Eclipse集成&quot;&gt;&lt;/a&gt;1.4 Eclipse集成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;默认&lt;/strong&gt;：Eclipse 会自动关联环境变量中配置的 JDK。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手动&lt;/strong&gt;：“Window”–“Preferences”–“Java”–“Installed JREs”–“Add”–“Standard VM”–选择jdk安装目录。 （多个版本的JDK手工进行配置）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.venux.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
      <category term="Tomcat" scheme="http://www.venux.cn/tags/Tomcat/"/>
    
      <category term="Eclipse" scheme="http://www.venux.cn/tags/Eclipse/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-08COMPOSITE（组合）— 对象结构型模式</title>
    <link href="http://www.venux.cn/2017/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08%E7%BB%84%E5%90%88/"/>
    <id>http://www.venux.cn/2017/09/13/设计模式-08组合/</id>
    <published>2017-09-13T11:40:08.000Z</published>
    <updated>2018-05-14T02:53:19.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1 意图"></a>1 意图</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2 别名"></a>2 别名</h2><p>无</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3 动机"></a>3 动机</h2><p>在绘图编辑器和图形捕捉系统这样的图形应用程序中，用户可以使用简单的组件创建复杂的图表。用户可以组合多个简单组件以形成一些较大的组件，这些组件又可以组合成更大的组件。一个简单的实现方法是为 Text 和 Line 这样的图元定义一些类，另外定义一些类作为这些图元的容器类（Container）。问题：使用这些类的代码必须区别对待图元对象与容器对象，而实际上大多数情况下用户认为它们是一样的。<br><img src="/images/posts/组合1.jpg" alt="图一"><br><a id="more"></a></p>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4 适用性"></a>4 适用性</h2><ul>
<li>你想表示对象的部分 -整体层次结构。</li>
<li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h2><p><img src="/images/posts/组合2.jpg" alt="图二"></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6 参与者"></a>6 参与者</h2><ul>
<li>Component(Graphic)<ul>
<li>为组合中的对象声明接口。</li>
<li>在适当的情况下，实现所有类共有接口的缺省行为。</li>
<li>声明一个接口用于访问和管理 Component 的子组件。</li>
<li>(可选)在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它。</li>
</ul>
</li>
<li>Leaf(Rectangle、Line、Text 等)<ul>
<li>在组合中表示叶节点对象，叶节点没有子节点。</li>
<li>在组合中定义图元对象的行为。</li>
</ul>
</li>
<li>Composite(Picture)<ul>
<li>定义有子部件的那些部件的行为。</li>
<li>存储子部件。</li>
<li>在 Component 接口中实现与子部件有关的操作。</li>
</ul>
</li>
<li>Client<ul>
<li>通过 Component 接口操纵组合部件的对象。</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7 协作"></a>7 协作</h2><p>用户使用  Component 类接口与组合结构中的对象进行交互。如果接收者是一个叶节点 ,则直接处理请求。如果接收者是  Composite , 它通常将请求发送给它的子部件，在转发请求之前与/或之后可能执行一些辅助操作。</p>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8 效果"></a>8 效果</h2><ul>
<li>定义了包含基本对象和组合对象的类层次结构 </li>
<li>简化客户代码</li>
<li>使得更容易增加新类型的组件</li>
<li>使你的设计变得更加一般化</li>
<li>子部件排序</li>
<li></li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9 实现"></a>9 实现</h2><ul>
<li>显式的父部件引用</li>
<li>共享组件</li>
<li>最大化 Component 接口</li>
<li>声明管理子部件的操作（透明性 or 安全性）</li>
<li>Component 是否应该实现一个 Component 列表</li>
<li>应该由谁删除 Component</li>
<li>存贮组件最好用哪一种数据结构（列表、树、数组和 hash 表，效率）</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10 代码示例"></a>10 代码示例</h2><ul>
<li><p>Component</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Component</div><div class="line">&#123;</div><div class="line">    public abstract void Operation();</div><div class="line"></div><div class="line">    public virtual void Add(Component component)</div><div class="line">    &#123;</div><div class="line">        //默认实现，Leaf不需要复写，Composite需要复写</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public virtual void Remove(Component component)</div><div class="line">    &#123;</div><div class="line">        //默认实现，Leaf不需要复写，Composite需要复写</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public virtual Component GetChild(int index)</div><div class="line">    &#123;</div><div class="line">        //默认实现，Leaf不需要复写，Composite需要复写</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Leaf(Rectangle、Line、Text 等)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Leaf:Component</div><div class="line">&#123;</div><div class="line">    public override void Operation()</div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(&quot;Leaf&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Composite(Picture)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Composite:Component</div><div class="line">&#123;</div><div class="line">    private List&lt;Component&gt; children=new List&lt;Component&gt;();</div><div class="line"></div><div class="line">    public override void Operation()</div><div class="line">    &#123;</div><div class="line">        foreach(var component in children)</div><div class="line">        &#123;</div><div class="line">            component.Operation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public new void Add(Component component)</div><div class="line">    &#123;</div><div class="line">        children.Add(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public new void Remove(Component component)</div><div class="line">    &#123;</div><div class="line">       children.Add(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public new Component GetChild(int index)</div><div class="line">    &#123;</div><div class="line">        return children[index];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Client</div><div class="line">&#123;</div><div class="line">    public static void Main(string[] args)</div><div class="line">    &#123;</div><div class="line">        Component leaf=new Leaf();</div><div class="line">        leaf.Operation();</div><div class="line"></div><div class="line">        Component composite=new Composite();</div><div class="line">        composite.Add(leaf);</div><div class="line">        composite.Operation();</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11 已知应用"></a>11 已知应用</h2><p>MVC 中的 View。</p>
<h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12 相关模式"></a>12 相关模式</h2><ul>
<li>通常部件 - 父部件连接用于 Responsibility of Chain 模式。</li>
<li>Decorator 模式经常与 Composite 模式一起使用。当装饰和组合一起使用时，它们通常有一个公共的父类。因此装饰必须支持具有 Add、Remove 和 GetChild 操作的 Component。</li>
<li>Flyweight 让你共享组件，但不再能引用他们的父部件。</li>
<li>Itertor 可用来遍历 Composite。</li>
<li>Visitor 将本来应该分布在 Composite 和 Leaf 类中的操作和行为局部化。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-意图&quot;&gt;&lt;a href=&quot;#1-意图&quot; class=&quot;headerlink&quot; title=&quot;1 意图&quot;&gt;&lt;/a&gt;1 意图&lt;/h2&gt;&lt;p&gt;将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;
&lt;h2 id=&quot;2-别名&quot;&gt;&lt;a href=&quot;#2-别名&quot; class=&quot;headerlink&quot; title=&quot;2 别名&quot;&gt;&lt;/a&gt;2 别名&lt;/h2&gt;&lt;p&gt;无&lt;/p&gt;
&lt;h2 id=&quot;3-动机&quot;&gt;&lt;a href=&quot;#3-动机&quot; class=&quot;headerlink&quot; title=&quot;3 动机&quot;&gt;&lt;/a&gt;3 动机&lt;/h2&gt;&lt;p&gt;在绘图编辑器和图形捕捉系统这样的图形应用程序中，用户可以使用简单的组件创建复杂的图表。用户可以组合多个简单组件以形成一些较大的组件，这些组件又可以组合成更大的组件。一个简单的实现方法是为 Text 和 Line 这样的图元定义一些类，另外定义一些类作为这些图元的容器类（Container）。问题：使用这些类的代码必须区别对待图元对象与容器对象，而实际上大多数情况下用户认为它们是一样的。&lt;br&gt;&lt;img src=&quot;/images/posts/组合1.jpg&quot; alt=&quot;图一&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.venux.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="设计模式" scheme="http://www.venux.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
