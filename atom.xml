<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>祥_venux</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.venux.cn/"/>
  <updated>2018-06-06T06:24:56.284Z</updated>
  <id>http://www.venux.cn/</id>
  
  <author>
    <name>祥_venux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>06.重构-简化条件表达式</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/06.%E9%87%8D%E6%9E%84-%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/06.重构-简化条件表达式/</id>
    <published>2018-06-05T15:06:26.000Z</published>
    <updated>2018-06-06T06:24:56.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>复杂条件逻辑拆分：Decompose（分解） Conditional；</li><li>代码多次测试结果相同：Consolidate（合并） Conditional Expression；</li><li>条件代码重复：Consolidate Duplicate Conditional Fragments（碎片）；</li><li>“单一出口”特殊情况：Replace Nested Conditional with Guard Clauses；</li><li>去除控制标记：Remove Control Flag；</li><li>switch 语句：Replace Conditional with Polymorphism（多态）；</li><li>去除 Null 检验：Introduce Null Object；</li></ul><a id="more"></a><h2 id="2-Decompose-Conditional（分解条件表达式）"><a href="#2-Decompose-Conditional（分解条件表达式）" class="headerlink" title="2. Decompose Conditional（分解条件表达式）"></a>2. Decompose Conditional（分解条件表达式）</h2><p>从 if-then-else 中分别提炼到独立函数；</p><h2 id="3-Consolidate-Conditional-Expression（合并条件表达式）"><a href="#3-Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="3. Consolidate Conditional Expression（合并条件表达式）"></a>3. Consolidate Conditional Expression（合并条件表达式）</h2><p>将同样结果的条件测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。<br><code>ps</code>:</p><ul><li>类似多个 case 使用同样的代码。</li><li>如果你认为这些检查的确需要彼此独立，就可以不要使用该项重构，不过必须表示清楚自己的意义。</li></ul><h2 id="4-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#4-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="4. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>4. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h2><p>将重复代码提取到条件表达式之外。</p><h2 id="5-Remove-Control-Flag（移除控制标记）"><a href="#5-Remove-Control-Flag（移除控制标记）" class="headerlink" title="5. Remove Control Flag（移除控制标记）"></a>5. Remove Control Flag（移除控制标记）</h2><p>以 break、continue、return 语句取代控制标记。</p><h2 id="6-Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式，防御编程）"><a href="#6-Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式，防御编程）" class="headerlink" title="6. Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式，防御编程）"></a>6. Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式，防御编程）</h2><p>使用卫语句表现所有特殊情况。<br><strong>精髓</strong>：给某一条分支以特别的重视。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><ul><li>条件表达式不同形式：<ul><li>所有分支都是正常行为：使用 if-else；</li><li>只有一种是正常行为，其他都是不正常情况：if-return,XXX；</li></ul></li><li>将条件反转，而后使用该重构手法；</li></ul><h3 id="6-2-示例"><a href="#6-2-示例" class="headerlink" title="6.2 示例"></a>6.2 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">false</span> &amp;&amp; B==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="comment">//Do Here</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">true</span> &amp;&amp; B==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#7-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="7. Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>7. Replace Conditional with Polymorphism（以多态取代条件表达式）</h2><p>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。<br><code>ps</code>：多态最根本的好处：根据对象的不同类型（形态）采用不同的行为，而不必编写明显的条件表达式。</p><h3 id="7-1-做法"><a href="#7-1-做法" class="headerlink" title="7.1 做法"></a>7.1 做法</h3><ul><li>建立继承结构<ul><li>Replace Type Code with Subclasses；</li><li>Replace Type Code with State/Strategy；</li></ul></li></ul><h2 id="8-Introduce-Null-Object（引入-Null-对象）"><a href="#8-Introduce-Null-Object（引入-Null-对象）" class="headerlink" title="8. Introduce Null Object（引入 Null 对象）"></a>8. Introduce Null Object（引入 Null 对象）</h2><p>将 null 值替换为 null 对象。<br><code>ps</code>：</p><ul><li>空对象一定是常量，它们的任何成分都不会发生变化。因此，可考虑使用单例模式保证唯一实例。</li><li>本质上来说，Null object 模式属于 Special Case 模式。</li></ul><h2 id="9-Introduce-Assertion（引入断言）"><a href="#9-Introduce-Assertion（引入断言）" class="headerlink" title="9. Introduce Assertion（引入断言）"></a>9. Introduce Assertion（引入断言）</h2><p>以断言明确表现某些用以对程序状态的假设。<br><code>ps</code>：</p><ul><li>断言是个条件表达式，应该总是为真。若失败，则表示程序员犯错了，所以断言的失败会导致一个非受控异常（unchecked exception）。</li><li>断言绝对不能被系统其它部分使用，实际上，最后成品往往需删除断言。</li><li>不要滥用断言，请不要使用它来检查“你认为应该为真”的条件，请只是用它来检查“一定必须为真”的条件。</li><li>如果断言所指示的约束条件不能满足，代码是否仍能正常运行？若可以，则移除断言。</li><li>断言的价值在于：帮助程序员理解代码正确运行的必要条件。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第9章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;复杂条件逻辑拆分：Decompose（分解） Conditional；&lt;/li&gt;
&lt;li&gt;代码多次测试结果相同：Consolidate（合并） Conditional Expression；&lt;/li&gt;
&lt;li&gt;条件代码重复：Consolidate Duplicate Conditional Fragments（碎片）；&lt;/li&gt;
&lt;li&gt;“单一出口”特殊情况：Replace Nested Conditional with Guard Clauses；&lt;/li&gt;
&lt;li&gt;去除控制标记：Remove Control Flag；&lt;/li&gt;
&lt;li&gt;switch 语句：Replace Conditional with Polymorphism（多态）；&lt;/li&gt;
&lt;li&gt;去除 Null 检验：Introduce Null Object；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>05.重构-重新组织数据</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/05.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/05.重构-重新组织数据/</id>
    <published>2018-05-31T15:06:26.000Z</published>
    <updated>2018-06-06T02:49:37.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>表示方式：Replace Value with Object、Change Value to Reference；</li><li>数组的行为方式很像一种数据结构：Replace Array with Object；</li><li>魔法数：Replace Magic Number with Symbolic Constant；</li><li>对象关联方向：Change Unidirectional Association to Bidirectional（单向-&gt;双向）、Change Bidirectional Association to Unidirectional（双向-&gt;单向）；</li><li>非公开数据：Encapsulate Field、Encapsulate Collection；</li><li>记录暴露在外：Replace Record with Data Class；</li><li>类型码（type code）：Replace Type Code with Class、Replace Type Code with Subclasses、Replace Type Code with State/Strategy；</li></ul><a id="more"></a><h2 id="2-Self-Encapsulate-Field（自封装字段）"><a href="#2-Self-Encapsulate-Field（自封装字段）" class="headerlink" title="2. Self Encapsulate Field（自封装字段）"></a>2. Self Encapsulate Field（自封装字段）</h2><p>为这个字段设置取值、设值函数，并只能通过该函数访问。</p><h2 id="3-Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#3-Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="3. Replace Data Value with Object（以对象取代数据值）"></a>3. Replace Data Value with Object（以对象取代数据值）</h2><p>将数据项变成对象。</p><h2 id="4-Change-Value-to-Reference（将值对象改为引用对象）"><a href="#4-Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="4. Change Value to Reference（将值对象改为引用对象）"></a>4. Change Value to Reference（将值对象改为引用对象）</h2><p>问题：你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。<br>将这个值对象改为引用对象。</p><h3 id="4-1-动机"><a href="#4-1-动机" class="headerlink" title="4.1 动机"></a>4.1 动机</h3><ul><li>实例共享，防止多份拷贝；</li><li>解决方案：如单例模式、静态函数等；</li></ul><h2 id="5-Change-Reference-to-Value（将引用对象改为值对象）"><a href="#5-Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="5. Change Reference to Value（将引用对象改为值对象）"></a>5. Change Reference to Value（将引用对象改为值对象）</h2><p>问题：你有一个引用对象，很小且不可变，而且不易管理。<br>将这个引用对象改为值对象。</p><h3 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h3><ul><li>值对象特性：不可变；</li><li>提供 equals() 和 hashCode() 等实现；</li></ul><h2 id="6-Replace-Array-with-Object（以对象取代数组）"><a href="#6-Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="6. Replace Array with Object（以对象取代数组）"></a>6. Replace Array with Object（以对象取代数组）</h2><p>问题：你有一个数组，其中的元素每个都代表不同的东西。<br><code>ps</code>：Martin Flower 写《重构》一书时，基于 Java1.0 -&gt; Java1.1 版本，那时还没有泛型一说。现如今应该不会出现这种数组存储完全不同类型的问题，否则就是需求分析建模出错。<br>以对象取代数组，对于数组中的每个元素，都使用一个字段表示。</p><h2 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h2><ul><li>数组存储不同类型数据；</li><li>个人理解另一个问题：数组数据涉及到相关操作，可考虑将属性修改为直接继承已有列表类型的对象，而后扩展相应操作。</li></ul><h2 id="7-Duplicate-Observed-Data（复制“被监视数据”）"><a href="#7-Duplicate-Observed-Data（复制“被监视数据”）" class="headerlink" title="7. Duplicate Observed Data（复制“被监视数据”）"></a>7. Duplicate Observed Data（复制“被监视数据”）</h2><p>将数据复制到一个领域对象中。建立一个 Observer 模式，用以同步领域对象和 GUI 对象内的重复数据。</p><h3 id="7-1-动机"><a href="#7-1-动机" class="headerlink" title="7.1 动机"></a>7.1 动机</h3><ul><li>UI 和业务逻辑代码分离；</li></ul><h2 id="8-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#8-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="8. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>8. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h2><p>添加一个反向指针，并使修改函数能够同时更新两条连接。</p><h3 id="8-1-动机"><a href="#8-1-动机" class="headerlink" title="8.1 动机"></a>8.1 动机</h3><ul><li>被引用类需要其引用者以便进行某些处理。</li></ul><h2 id="9-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）"><a href="#9-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）" class="headerlink" title="9. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）"></a>9. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）</h2><p>去除不必要的关联。</p><h3 id="9-1-动机"><a href="#9-1-动机" class="headerlink" title="9.1 动机"></a>9.1 动机</h3><ul><li>双向关联维护复杂，引用垃圾回收不了；</li><li>依赖关系太强，导致紧耦合；</li></ul><h2 id="10-Replace-Magic-Number-with-Symbolic-Constant（使用字面常量替换魔法数）"><a href="#10-Replace-Magic-Number-with-Symbolic-Constant（使用字面常量替换魔法数）" class="headerlink" title="10. Replace Magic Number with Symbolic Constant（使用字面常量替换魔法数）"></a>10. Replace Magic Number with Symbolic Constant（使用字面常量替换魔法数）</h2><p>创造一个变量，根据其意义为它命名，并将上述的字面数值替换为这个常量。<br><code>ps</code>：</p><ul><li>常量不会造成任何性能开销，却可以大大提高代码可读性。</li><li>若魔法数是类型码，考虑使用 Replace Type Code with Class；</li></ul><h2 id="11-Encapsulate-Field（封装字段）"><a href="#11-Encapsulate-Field（封装字段）" class="headerlink" title="11. Encapsulate Field（封装字段）"></a>11. Encapsulate Field（封装字段）</h2><p>将字段声明为 private，并提供 get/set 方法。<br><code>ps</code>：面向对象的原则之一就是封装，或称为“数据隐藏”。故数据不应该声明为 public，而通过（函数）行为暴露。</p><h2 id="12-Encapsulate-Collection（封装集合）"><a href="#12-Encapsulate-Collection（封装集合）" class="headerlink" title="12. Encapsulate Collection（封装集合）"></a>12. Encapsulate Collection（封装集合）</h2><p>让这个函数返回该集合的一个只读副本，并在这个类中提供添加/删除集合元素的函数。</p><h3 id="12-1-动机"><a href="#12-1-动机" class="headerlink" title="12.1 动机"></a>12.1 动机</h3><ul><li>集合用来保存一组实例，并提供取值/设值函数；</li><li>取值函数不应该返回集合本身，因为这会使得用户修改集合内容而集合拥有者却不知晓，过多暴露对象内部数据结构的信息；</li><li>不应该为集合提供一个设置函数，而应该提供添加/删除元素的函数；</li><li>封装数组，直接将数组替换为其他集合；</li></ul><h2 id="13-Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#13-Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="13. Replace Record with Data Class（以数据类取代记录）"></a>13. Replace Record with Data Class（以数据类取代记录）</h2><p>为该记录创建一个“哑”数据对象。<br><code>ps</code>：其实就是单独建立一个实体（Model/Entity），只有取值/设值函数。</p><h2 id="14-Replace-Type-Code-with-Class（以类取代状态码）"><a href="#14-Replace-Type-Code-with-Class（以类取代状态码）" class="headerlink" title="14. Replace Type Code with Class（以类取代状态码）"></a>14. Replace Type Code with Class（以类取代状态码）</h2><p>以一个新的类替换该数值类型码。<br><code>ps</code>：</p><ul><li>现如今有枚举类型，强类型检查，可优先考虑。</li><li>或者单独建立一个类，提供相应的状态码的静态字段，类似于 C# 中 Encoding 类的实现。</li></ul><h2 id="15-Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#15-Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="15. Replace Type Code with Subclasses（以子类取代类型码）"></a>15. Replace Type Code with Subclasses（以子类取代类型码）</h2><p>以子类取代这个类型码。<br><code>ps</code>：</p><ul><li>主要作用是为 Replace Conditional with Polymorphism 搭建平台。</li><li>若宿主类中无条件表达式，推荐使用 Replace Type Code with Class。</li></ul><h3 id="15-1-动机"><a href="#15-1-动机" class="headerlink" title="15.1 动机"></a>15.1 动机</h3><ul><li>以类型码的宿主类作为基类，针对每种类型码建立相应子类；</li><li>把“对不同行为的了解”从类用户转移到类自身；</li><li>不适用情况，需使用 Replace Type Code with State/Strategy：<ul><li>类型码在对象创建后发生改变；</li><li>由于某种原因，类型码宿主已有子类；</li></ul></li></ul><h2 id="16-Replace-Type-Code-with-State-Strategy（使用-State-Strategy-模式取代类型码）"><a href="#16-Replace-Type-Code-with-State-Strategy（使用-State-Strategy-模式取代类型码）" class="headerlink" title="16. Replace Type Code with State/Strategy（使用 State/Strategy 模式取代类型码）"></a>16. Replace Type Code with State/Strategy（使用 State/Strategy 模式取代类型码）</h2><p>以状态对象取代类型码。</p><ul><li>状态：State；</li><li>算法：Strategy；</li></ul><h2 id="17-Replace-Subclass-with-Fields（以字段取代子类）"><a href="#17-Replace-Subclass-with-Fields（以字段取代子类）" class="headerlink" title="17. Replace Subclass with Fields（以字段取代子类）"></a>17. Replace Subclass with Fields（以字段取代子类）</h2><p>问题：各个子类的唯一差别在于“返回常量数据”的函数上。<br>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。</p><h3 id="17-1-动机"><a href="#17-1-动机" class="headerlink" title="17.1 动机"></a>17.1 动机</h3><p>建立子类的目的是为了增加新特性或变化行为。其中，有一类行为变化被称为“常量函数”，它们会返回一个硬编码的值，使得不同子类的同一个函数返回不同的值。<br><strong>若子类只有常量函数，则没存在的价值。可直接在超类中使用字段表示类型（如 C# 中的 Encoding 类）</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第8章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;表示方式：Replace Value with Object、Change Value to Reference；&lt;/li&gt;
&lt;li&gt;数组的行为方式很像一种数据结构：Replace Array with Object；&lt;/li&gt;
&lt;li&gt;魔法数：Replace Magic Number with Symbolic Constant；&lt;/li&gt;
&lt;li&gt;对象关联方向：Change Unidirectional Association to Bidirectional（单向-&amp;gt;双向）、Change Bidirectional Association to Unidirectional（双向-&amp;gt;单向）；&lt;/li&gt;
&lt;li&gt;非公开数据：Encapsulate Field、Encapsulate Collection；&lt;/li&gt;
&lt;li&gt;记录暴露在外：Replace Record with Data Class；&lt;/li&gt;
&lt;li&gt;类型码（type code）：Replace Type Code with Class、Replace Type Code with Subclasses、Replace Type Code with State/Strategy；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>04.重构-在对象之间搬移特性</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/04.%E9%87%8D%E6%9E%84-%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/04.重构-在对象之间搬移特性/</id>
    <published>2018-05-31T15:06:26.000Z</published>
    <updated>2018-06-01T07:18:42.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>职责不清晰：Move Field、Move Method；</li><li>类承担过多职责：Extract Class；</li><li>类职责过少：Inline Class；</li><li>类之间关联：Hide Delegate、Remove Middle Man；</li><li>不能访问类的源码，却又想添加职责：Introduce Foreign Method、Introduce Local Extension；</li></ul><a id="more"></a><h2 id="2-Move-Method（搬移函数）"><a href="#2-Move-Method（搬移函数）" class="headerlink" title="2. Move Method（搬移函数）"></a>2. Move Method（搬移函数）</h2><p>问题：类中，有个函数与另一类过多交互。<br>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是直接移除。</p><h3 id="2-1-动机"><a href="#2-1-动机" class="headerlink" title="2.1 动机"></a>2.1 动机</h3><ul><li>类中有太多行为职责；</li><li>类之间太多合作导致高度耦合；</li></ul><h2 id="3-Move-Field（搬移字段）"><a href="#3-Move-Field（搬移字段）" class="headerlink" title="3. Move Field（搬移字段）"></a>3. Move Field（搬移字段）</h2><p>问题：类中，某个字段被另外一个类更多的使用。<br>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。</p><h3 id="3-2-做法"><a href="#3-2-做法" class="headerlink" title="3.2 做法"></a>3.2 做法</h3><ul><li>Self Encapsulate Field：即对字段进行包装，提高 get、set 操作；</li></ul><h2 id="4-Extract-Class（提炼类）"><a href="#4-Extract-Class（提炼类）" class="headerlink" title="4. Extract Class（提炼类）"></a>4. Extract Class（提炼类）</h2><p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p><h3 id="4-1-动机"><a href="#4-1-动机" class="headerlink" title="4.1 动机"></a>4.1 动机</h3><ul><li>类的职责过多；</li><li>类有部分特性需子类化；</li></ul><h2 id="5-Inline-Class（类内联化）"><a href="#5-Inline-Class（类内联化）" class="headerlink" title="5. Inline Class（类内联化）"></a>5. Inline Class（类内联化）</h2><p>将这个类的所有特性搬移到另一个类中，然后移除原类。此手法正好与 Extract Class 相反。</p><h3 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h3><p>一个类不再承担足够职责，不再有单独存在的里有。</p><h2 id="6-Hide-Delegate（隐藏“委托关系”）"><a href="#6-Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="6. Hide Delegate（隐藏“委托关系”）"></a>6. Hide Delegate（隐藏“委托关系”）</h2><p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><p>“封装”意味着每个对象都应该尽可能少了解系统的其他部分。</p><h2 id="7-Remove-Middle-Man（移除中间人）"><a href="#7-Remove-Middle-Man（移除中间人）" class="headerlink" title="7. Remove Middle Man（移除中间人）"></a>7. Remove Middle Man（移除中间人）</h2><p>问题：某个类做了过多的简单委托动作。<br>让客户直接调用委托类。</p><h3 id="7-1-动机"><a href="#7-1-动机" class="headerlink" title="7.1 动机"></a>7.1 动机</h3><ul><li>合适的隐藏程度；</li><li>与 Hide Delegate 相反；</li></ul><h2 id="8-Introduce-Foreign-Method（引入外部函数）"><a href="#8-Introduce-Foreign-Method（引入外部函数）" class="headerlink" title="8. Introduce Foreign Method（引入外部函数）"></a>8. Introduce Foreign Method（引入外部函数）</h2><p>问题：你需要为提供服务的类增加一个函数，但无法修改这个类。<br>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</p><h3 id="8-1-动机"><a href="#8-1-动机" class="headerlink" title="8.1 动机"></a>8.1 动机</h3><ul><li>同样功能防止重复代码。</li><li>若许多类都需要同样的外加函数，则应提取出来，使用 Introduce Local Extension。<br><code>ps:</code>类似 C# 的扩展函数。</li><li>坚持“函数与数据应该被统一封装”的原则。</li></ul><h2 id="9-Introduce-Local-Extension（引入本地扩展）"><a href="#9-Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="9. Introduce Local Extension（引入本地扩展）"></a>9. Introduce Local Extension（引入本地扩展）</h2><p>问题：你需要为提供服务的类增加一些函数，但无法修改这个类。<br>建立一个新类，使它包含这些额外函数。让这个扩展品成为原类的子类或包装类。<br>  <code>ps:</code>C# 的扩展方法更简单易用，若编程语言不支持扩展方法，则使用子类或包装类形式。</p><h3 id="9-1-注意事项"><a href="#9-1-注意事项" class="headerlink" title="9.1 注意事项"></a>9.1 注意事项</h3><ul><li>优先级：扩展方法 &gt; 子类 &gt; 包装类；</li><li>添加“转型构造函数”，即源类型作为参数的构造函数；</li><li>子类问题：必须在对象创建期实施、必须创建子类对象（若旧对象一直使用，则有两个对象保存原数据，数据修改会有问题）；</li><li>包装类 Wrapper；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第7章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;职责不清晰：Move Field、Move Method；&lt;/li&gt;
&lt;li&gt;类承担过多职责：Extract Class；&lt;/li&gt;
&lt;li&gt;类职责过少：Inline Class；&lt;/li&gt;
&lt;li&gt;类之间关联：Hide Delegate、Remove Middle Man；&lt;/li&gt;
&lt;li&gt;不能访问类的源码，却又想添加职责：Introduce Foreign Method、Introduce Local Extension；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>03.重构-重新组织函数</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/03.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/03.重构-重新组织函数/</id>
    <published>2018-05-31T10:06:26.000Z</published>
    <updated>2018-06-01T07:18:34.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>Long Methods（过长函数）：Extract Method；</li><li>某些函数没做什么太多事情：Inline Method；</li><li>临时变量：Replace Temp with Query、Split Temporary Variable、Replace Method with Method Object；</li><li>参数问题：Remove Assignments to Parameters；</li><li>改进算法：Substitute Algorithm；</li></ul><a id="more"></a><h2 id="2-Extract-Method（提炼函数）"><a href="#2-Extract-Method（提炼函数）" class="headerlink" title="2. Extract Method（提炼函数）"></a>2. Extract Method（提炼函数）</h2><p>将一段代码放进一个独立函数中，并让函数名称解释其用途。</p><h3 id="2-1-动机"><a href="#2-1-动机" class="headerlink" title="2.1 动机"></a>2.1 动机</h3><ul><li>函数粒度小，易于复用和覆写；</li><li>高层函数更像注释；</li></ul><h3 id="2-2-做法"><a href="#2-2-做法" class="headerlink" title="2.2 做法"></a>2.2 做法</h3><ul><li>无局部变量：直接挪移</li><li>有局部变量，但不修改它或局部变量是对象：局部变量当做参数传递</li><li>对局部变量再赋值（Remove Assignments to Parameters）<ul><li>若只有被提炼代码使用：挪移局部变量</li><li>否则：返回值</li><li>返回变量不止一个：推荐只返回一个值，使用多个函数；若编程语言支持“出参数”（output parameter），则可使用。（类似 C# 的 ref 和 out，可考虑新特性元组 Tuple）<br>详见书P133。</li></ul></li></ul><h2 id="3-Inline-Method（内联函数）"><a href="#3-Inline-Method（内联函数）" class="headerlink" title="3. Inline Method（内联函数）"></a>3. Inline Method（内联函数）</h2><p>在函数调用点插入函数本体，然后移除该函数。</p><h3 id="3-1-动机"><a href="#3-1-动机" class="headerlink" title="3.1 动机"></a>3.1 动机</h3><ul><li>短小函数只有一处调用，过多导致复杂性太高，移动不方便等等；</li><li>防止间接层过多，晕头转向；</li></ul><h3 id="3-2-做法"><a href="#3-2-做法" class="headerlink" title="3.2 做法"></a>3.2 做法</h3><ul><li>检查函数，确定不具备多态性<ul><li>若子类继承该函数，就不能内联；<br>详见书P140</li></ul></li></ul><h2 id="4-Inline-Temp（内联临时变量）"><a href="#4-Inline-Temp（内联临时变量）" class="headerlink" title="4. Inline Temp（内联临时变量）"></a>4. Inline Temp（内联临时变量）</h2><p>将所有对该变量的引用操作，替换为对它赋值的那个表达式自身。</p><h3 id="4-1-动机"><a href="#4-1-动机" class="headerlink" title="4.1 动机"></a>4.1 动机</h3><ul><li>临时变量被赋予某个函数调用的返回值。<br><code>ps</code>：个人感觉部分情况还是可使用临时变量，以便调试使用，更清晰。</li></ul><h2 id="5-Replace-Temp-with-Query（以查询替代临时变量）"><a href="#5-Replace-Temp-with-Query（以查询替代临时变量）" class="headerlink" title="5. Replace Temp with Query（以查询替代临时变量）"></a>5. Replace Temp with Query（以查询替代临时变量）</h2><p>将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用。<br><code>ps</code>：该操作会导致函数执行多次，故为了效率考虑，若执行速度慢的查询，还是需使用临时变量。</p><h2 id="6-Introduce-Explaining-Variable（引入解释下变量）"><a href="#6-Introduce-Explaining-Variable（引入解释下变量）" class="headerlink" title="6. Introduce Explaining Variable（引入解释下变量）"></a>6. Introduce Explaining Variable（引入解释下变量）</h2><p>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><ul><li>与 Inline Temp（内联临时变量）相反；</li><li>表达式可能非常复杂而难以阅读，临时变量可帮助拆分，提高阅读性；<br><code>ps</code>：作者推荐使用 Extract Method，以便复用。</li></ul><h2 id="7-Split-Temporary-Variable（分解临时变量）"><a href="#7-Split-Temporary-Variable（分解临时变量）" class="headerlink" title="7. Split Temporary Variable（分解临时变量）"></a>7. Split Temporary Variable（分解临时变量）</h2><p>针对每次赋值，创造一个独立、对应的临时变量。</p><h3 id="7-1-动机"><a href="#7-1-动机" class="headerlink" title="7.1 动机"></a>7.1 动机</h3><p>某个临时变量被赋值超过一次，它既不是<strong>循环变量</strong>，又不是<strong>搜集计算结果</strong>。除了这两种情况，其他意味着临时变量承担了多个责任，应该被替换为多个临时变量，每个变量只承担一个责任。</p><h2 id="8-Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#8-Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="8. Remove Assignments to Parameters（移除对参数的赋值）"></a>8. Remove Assignments to Parameters（移除对参数的赋值）</h2><p>以一个临时变量取代该参数的位置。</p><h3 id="8-1-动机"><a href="#8-1-动机" class="headerlink" title="8.1 动机"></a>8.1 动机</h3><ul><li>防止混用<strong>按值传递</strong>和<strong>按引用传递</strong>；</li><li>不要对参数赋值（特别是 Java、C# 这类只采用值传递的编程语言），出参数（ref、out）除外；</li><li>可以为参数加上 final 修饰符，强制不对参数赋值；<br><code>ps</code>：在按值传递的情况下，对参数的任何修改，都不会对调用端造成任何影响。</li></ul><h2 id="9-Replace-Method-with-Method-Object（以函数对象取代函数）"><a href="#9-Replace-Method-with-Method-Object（以函数对象取代函数）" class="headerlink" title="9. Replace Method with Method Object（以函数对象取代函数）"></a>9. Replace Method with Method Object（以函数对象取代函数）</h2><p>问题：你有一个大型函数，其中对局部变量的使用使你无法采用 Extract Method。<br>将这个函数放进一个单独对象中，这样该局部变量就成为了这个对象的字段，然后就可拆分。</p><h2 id="10-Substitute-Algorithm（替换算法）"><a href="#10-Substitute-Algorithm（替换算法）" class="headerlink" title="10. Substitute Algorithm（替换算法）"></a>10. Substitute Algorithm（替换算法）</h2><p>将函数本体替换为另一个算法。</p><h3 id="10-1-动机"><a href="#10-1-动机" class="headerlink" title="10.1 动机"></a>10.1 动机</h3><p>解决问题有好几种方法，其中某些方法会比另一些简单。<br>使用这项重构手法之前，请先确定自己已经尽可能分解了原先函数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第6章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Long Methods（过长函数）：Extract Method；&lt;/li&gt;
&lt;li&gt;某些函数没做什么太多事情：Inline Method；&lt;/li&gt;
&lt;li&gt;临时变量：Replace Temp with Query、Split Temporary Variable、Replace Method with Method Object；&lt;/li&gt;
&lt;li&gt;参数问题：Remove Assignments to Parameters；&lt;/li&gt;
&lt;li&gt;改进算法：Substitute Algorithm；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>02.重构-重构手法</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/02.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E6%89%8B%E6%B3%95/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/02.重构-重构手法/</id>
    <published>2018-05-30T10:06:26.000Z</published>
    <updated>2018-06-01T07:17:54.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-重构的记录格式"><a href="#1-重构的记录格式" class="headerlink" title="1. 重构的记录格式"></a>1. 重构的记录格式</h2><ul><li>名称（name）</li><li>简短概要（summary）：介绍重构手法的适用场景，以及它所做的事情。</li><li>动机（motivation）：Why，介绍“为什么需要这个重构”和“什么情况下不该适用这个重构”。</li><li>做法（mechanics）：How。</li><li>范例（examples）</li></ul><a id="more"></a><h2 id="2-寻找引用点"><a href="#2-寻找引用点" class="headerlink" title="2. 寻找引用点"></a>2. 寻找引用点</h2><ul><li>文本查找工具，不要盲目地查找-替换；</li><li>编译器，缺点：<ul><li>被删除的部分在继承体系中不知声明一次；</li><li>效率太慢；</li><li>无法找到反射机制的引用点；</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第5章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-重构的记录格式&quot;&gt;&lt;a href=&quot;#1-重构的记录格式&quot; class=&quot;headerlink&quot; title=&quot;1. 重构的记录格式&quot;&gt;&lt;/a&gt;1. 重构的记录格式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;名称（name）&lt;/li&gt;
&lt;li&gt;简短概要（summary）：介绍重构手法的适用场景，以及它所做的事情。&lt;/li&gt;
&lt;li&gt;动机（motivation）：Why，介绍“为什么需要这个重构”和“什么情况下不该适用这个重构”。&lt;/li&gt;
&lt;li&gt;做法（mechanics）：How。&lt;/li&gt;
&lt;li&gt;范例（examples）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>01.重构-介绍</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/01.%E9%87%8D%E6%9E%84-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/01.重构-介绍/</id>
    <published>2018-05-29T10:06:26.000Z</published>
    <updated>2018-06-01T07:17:54.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul><li>重构（refactoring）是在不改变软件可观察行为的前提下改善其内部结构。</li><li>重构是这样一个过程：在不改变代码外在行为的前提下，对代码进行修改，以改进程序的内部结构。</li><li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高可理解性，降低其修改成本。</li><li>重构（动词）：使用一系列重构首发，在不改变软件可观察行为的前提下，调整其结构。</li></ul><a id="more"></a><h2 id="2-原则"><a href="#2-原则" class="headerlink" title="2. 原则"></a>2. 原则</h2><ul><li>不改变软件行为只是重构的最基本要求；</li><li>不需了解软件行为才是目的；</li><li>个人理解：封装完整性？调用 API 而无需了解 API 内部实现和行为。</li><li>设计模式为重构提供了目标；</li><li>判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据放在一起。<ul><li><code>ps:</code>有些设计模式破坏这个原则，如 Strategy 和 Visitor，Self Delegation，这是为了对抗坏味道 Divergent Change。</li><li>最根本的原则：将总是一起变化的东西放在一起。</li></ul></li></ul><h2 id="3-目的"><a href="#3-目的" class="headerlink" title="3. 目的"></a>3. 目的</h2><ul><li>重构改进软件设计<ul><li>消除重复代码</li></ul></li><li>重构使软件更容易理解</li><li>重构帮助找到 bug</li><li>重构提高编程速度</li></ul><h2 id="4-经验"><a href="#4-经验" class="headerlink" title="4. 经验"></a>4. 经验</h2><ul><li>重构前需建立一组可靠的测试环境，且必须能自我检验；</li><li>重构技术就是以微小的步伐修改程序，如果出错，可以很容易发现；</li><li>良好的名称是代码清晰的关键；</li><li>尽量除去临时变量；</li><li>最好不要在另一个对象的属性基础上运用 switch 语句，如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用；</li><li>技术复审是减少错误、提高开发速度的一条重要途径。</li></ul><h2 id="5-何时重构"><a href="#5-何时重构" class="headerlink" title="5. 何时重构"></a>5. 何时重构</h2><ul><li>反对专门拨出时间进行重构；</li><li>重构应该随时随地进行；</li><li>不应该为了重构而重构；</li><li>三次法则（事不过三，三则重构）<ul><li>第一次做某件事时只管去做；</li><li>第二次做类似的事会产生反感，但无论如何还是可以去做；</li><li>第三次再做类似的事，就应该重构。</li></ul></li><li>添加功能时重构；</li><li>修补错误时重构；</li><li>复审代码时重构；</li></ul><h2 id="6-为什么重构有用-–-Kent-Beck"><a href="#6-为什么重构有用-–-Kent-Beck" class="headerlink" title="6. 为什么重构有用 – Kent Beck"></a>6. 为什么重构有用 – Kent Beck</h2><h3 id="6-1-问题"><a href="#6-1-问题" class="headerlink" title="6.1 问题"></a>6.1 问题</h3><ul><li>难以阅读的程序，难以修改；</li><li>逻辑重复的程序，难以修改；</li><li>添加新行为时需要修改已有代码的程序，难以修改；</li><li>带复杂条件逻辑的程序，难以修改；</li></ul><h3 id="6-2-期望"><a href="#6-2-期望" class="headerlink" title="6.2 期望"></a>6.2 期望</h3><ul><li>容易阅读；</li><li>所有逻辑都只在唯一地点指定；</li><li>新的改动不会危及现有行为；</li><li>尽可能简单表达条件逻辑；</li></ul><h2 id="7-间接层"><a href="#7-间接层" class="headerlink" title="7. 间接层"></a>7. 间接层</h2><blockquote><p>计算机科学是这样一门科学：它相信所有问题都可以通过增加一个间接层来解决。</p><footer><strong>Dennis DeBruler</strong></footer></blockquote><h2 id="8-重构难题"><a href="#8-重构难题" class="headerlink" title="8. 重构难题"></a>8. 重构难题</h2><h3 id="8-1-数据库"><a href="#8-1-数据库" class="headerlink" title="8.1 数据库"></a>8.1 数据库</h3><ul><li>绝大多数程序都与其背后的数据库结构紧密耦合在一起；</li><li>数据迁移（migration）；</li><li>在非对象数据库中，解决办法之一是：在对象模型和数据库模型之间插入一个分割层，隔离两个模型各自的编号；</li></ul><h3 id="8-2-修改接口"><a href="#8-2-修改接口" class="headerlink" title="8.2 修改接口"></a>8.2 修改接口</h3><p>只有当需要修改的接口被哪些“找不到，即使找到也不能修改”的代码使用时，接口的修改才会成为问题。此时，这个接口是个已发布接口（published interface），比公开接口（public interface）更进一步。</p><ul><li>必须同时维护新旧两个接口，直到所有用户都有时间对这个变化做出反应；<ul><li>让旧接口调用新接口，千万不要复制函数实现；</li><li>将旧接口标记为 deprecated（java 的已过时），例如 Java 容器类；</li></ul></li><li>尽量不要发布接口，除非真的有必要；</li><li>Java 还有一种特别的接口修改：在 throws 子句中增加一个异常。此时，需要新建函数，然后在旧函数调用它，并处理这个异常。</li></ul><p><code>ps:</code>不要过早发布接口。请修改你的代码所有权政策，使重构更顺畅。</p><h3 id="8-3-难以通过重构手法完成的设计改动"><a href="#8-3-难以通过重构手法完成的设计改动" class="headerlink" title="8.3 难以通过重构手法完成的设计改动"></a>8.3 难以通过重构手法完成的设计改动</h3><p>先想象重构的情况，考虑候选设计方案难度，而后在设计上投入更多力气。</p><h2 id="9-何时不该重构"><a href="#9-何时不该重构" class="headerlink" title="9. 何时不该重构"></a>9. 何时不该重构</h2><ul><li>有时候代码是在太混乱，重构还不如重新重写一个；</li><li>重写（而非重构）的一个清楚讯号就是：现有代码根本不能正常运作；</li><li>折中办法：将“大块头软件”重构为封装良好的小型组件；</li><li>项目已近最后期限，此刻应该避免重构；</li></ul><h2 id="10-代码的坏味道（Bad-Smell）"><a href="#10-代码的坏味道（Bad-Smell）" class="headerlink" title="10. 代码的坏味道（Bad Smell）"></a>10. 代码的坏味道（Bad Smell）</h2><h3 id="10-1-Duplicated-Code（重复代码）"><a href="#10-1-Duplicated-Code（重复代码）" class="headerlink" title="10.1 Duplicated Code（重复代码）"></a>10.1 Duplicated Code（重复代码）</h3><ul><li>Extract（提取） Method：重复代码；</li><li>Pull Up Method：多个子类重复代码，提取代码放到超类；</li><li>Form Template Method：各个子类有所差异，使用 Template Method（模板方法）模式；</li><li>Substitute（替代） Algorithm：不同算法做同样的事；</li><li>Extract Class：若两个毫不相关的类出现，则将重复代码提炼到一个独立类；</li></ul><h3 id="10-2-Long-Method（过长函数）"><a href="#10-2-Long-Method（过长函数）" class="headerlink" title="10.2 Long Method（过长函数）"></a>10.2 Long Method（过长函数）</h3><p>“间接层”所能带来的全部利益–解释能力、共享能力、选择能力–都是由小型函数支持的。小函数真正容易理解的关键之处在于一个好名字。</p><ul><li>Extract Method</li><li>Replace Temp with Query</li><li>Introduce Parameter Object</li><li>Preserve（保持） Whole Object</li><li>Replace Method with Method Object</li><li>Decompose（分解） Conditional</li></ul><h3 id="10-3-Large-Class（过大的类）"><a href="#10-3-Large-Class（过大的类）" class="headerlink" title="10.3 Large Class（过大的类）"></a>10.3 Large Class（过大的类）</h3><ul><li>Extract Class</li><li>Extract Subclass</li><li>Extract Interface：先确定客户端如何使用它们，而后为每种使用方式提炼出一个接口。</li><li>Duplicate Observed Data</li></ul><h3 id="10-4-Long-Parameter-List（过长参数列）"><a href="#10-4-Long-Parameter-List（过长参数列）" class="headerlink" title="10.4 Long Parameter List（过长参数列）"></a>10.4 Long Parameter List（过长参数列）</h3><ul><li>Replace Parameter with Method</li><li>Preserve Whole Object</li><li>Introduce Parameter Object：如果某些数据缺乏合理的对象归属，可为它们制造一个“参数对象”；<br>-<code>ps:</code>例外情况，有时候不希望造成“被调用对象”与“较大对象”间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情合理。但需注意引发的代价。若参数列太长或变化太频繁，就需要重新考虑依赖结构。</li></ul><h3 id="10-5-Divergent-Change（发散式变化）"><a href="#10-5-Divergent-Change（发散式变化）" class="headerlink" title="10.5 Divergent Change（发散式变化）"></a>10.5 Divergent Change（发散式变化）</h3><p>某个类因为不同原因在不同方向发生变化。此时也许将对象拆分更好，这么一来每个对象就可以只因一种变化而修改。</p><ul><li>Extract Class</li></ul><h3 id="10-6-Shotgun-Surgery（散弹式修改）"><a href="#10-6-Shotgun-Surgery（散弹式修改）" class="headerlink" title="10.6 Shotgun Surgery（散弹式修改）"></a>10.6 Shotgun Surgery（散弹式修改）</h3><p>某种变化引发在许多不同的类内做出许多小修改。考虑把所有需要修改的代码放进同一个类。</p><ul><li>Move Method</li><li>Move Field</li><li>Inline Class</li></ul><p><code>ps:</code>Divergent Change 是指“一个类受多种变化的影响”，Shotgun Surgery 则是指“一种变化引发多个类相应修改”。</p><h3 id="10-7-Feature-Envy（依恋情结）"><a href="#10-7-Feature-Envy（依恋情结）" class="headerlink" title="10.7 Feature Envy（依恋情结）"></a>10.7 Feature Envy（依恋情结）</h3><ul><li>Extract Method</li><li>Move Method</li></ul><h3 id="10-8-Data-Clumps（数据泥团）"><a href="#10-8-Data-Clumps（数据泥团）" class="headerlink" title="10.8 Data Clumps（数据泥团）"></a>10.8 Data Clumps（数据泥团）</h3><p>两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有数据它们自己的对象。</p><ul><li>Extract Class</li><li>Introduce Parameter Object</li><li>Preserve Whole Object</li></ul><h3 id="10-9-Primitive-Obsession（基本类型偏执）"><a href="#10-9-Primitive-Obsession（基本类型偏执）" class="headerlink" title="10.9 Primitive Obsession（基本类型偏执）"></a>10.9 Primitive Obsession（基本类型偏执）</h3><ul><li>Replace Data Value with Object</li><li>Replace Type Code with Class</li><li>Replace Type Code with Subclass</li><li>Replace Type Code with State/Strategy</li><li>Extract Class</li><li>Introduce Parameter Object</li><li>Replace Array with Object</li></ul><h3 id="10-10-Switch-Statements（switch表达式）"><a href="#10-10-Switch-Statements（switch表达式）" class="headerlink" title="10.10 Switch Statements（switch表达式）"></a>10.10 Switch Statements（switch表达式）</h3><p>面向对象程序的一个最明显的特征就是：少用 switch（或 case）语句，问题在于重复，同样 switch 语句散布不同地方，需同时修改。解决方案是<strong>多态</strong>。</p><ul><li>Extract Method</li><li>Extract Class</li><li>Replace Type Code with Subclass</li><li>Replace Type Code with State/Strategy</li><li>Replace Conditional with Polymorphism（多态性）</li><li>Replace Parameter with Explicit（明确的） Methods</li><li>Introduce Null Object</li></ul><h3 id="10-11-Paraller-Inheritance-Hierarchies（平行继承体系）"><a href="#10-11-Paraller-Inheritance-Hierarchies（平行继承体系）" class="headerlink" title="10.11 Paraller Inheritance Hierarchies（平行继承体系）"></a>10.11 Paraller Inheritance Hierarchies（平行继承体系）</h3><p>Shotgun Surgery 的特殊情况，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。<br><strong>策略</strong>：让一个继承体系的实例引用另一个继承体系的实例。</p><ul><li>Move Method</li><li>Move Field</li></ul><h3 id="10-12-Lazy-Class（冗赘类）"><a href="#10-12-Lazy-Class（冗赘类）" class="headerlink" title="10.12 Lazy Class（冗赘类）"></a>10.12 Lazy Class（冗赘类）</h3><p>你所创建的每一个类，都得有人去理解和维护它，若一个类重构后完全没啥意义，就应该考虑删除它。</p><ul><li>Collapse（崩溃、折叠） Hierarchy</li><li>Inline Class</li></ul><h3 id="10-13-Speculative-Generality（夸夸其谈未来性）"><a href="#10-13-Speculative-Generality（夸夸其谈未来性）" class="headerlink" title="10.13 Speculative Generality（夸夸其谈未来性）"></a>10.13 Speculative Generality（夸夸其谈未来性）</h3><ul><li>Collapse Hierarchy</li><li>Inline Class</li><li>Remove Parameter</li><li>Rename Method</li></ul><h3 id="10-14-Temporary-Field（令人迷惑的临时字段）"><a href="#10-14-Temporary-Field（令人迷惑的临时字段）" class="headerlink" title="10.14 Temporary Field（令人迷惑的临时字段）"></a>10.14 Temporary Field（令人迷惑的临时字段）</h3><ul><li>Extract Class</li><li>Introduce Null Object</li></ul><h3 id="10-15-Message-Chains（过度耦合的消息链）"><a href="#10-15-Message-Chains（过度耦合的消息链）" class="headerlink" title="10.15 Message Chains（过度耦合的消息链）"></a>10.15 Message Chains（过度耦合的消息链）</h3><ul><li>Hide Delegate</li><li>Extract Method</li><li>Move Method</li></ul><h3 id="10-16-Middle-Man（中间人）"><a href="#10-16-Middle-Man（中间人）" class="headerlink" title="10.16 Middle Man（中间人）"></a>10.16 Middle Man（中间人）</h3><p>过度委托</p><ul><li>Remove Middle Man</li><li>Inline Method</li><li>Replace Delegation with Inheritance</li></ul><h3 id="10-17-Inappropriate-Intimacy（不恰当的亲密关系，即狎昵关系）"><a href="#10-17-Inappropriate-Intimacy（不恰当的亲密关系，即狎昵关系）" class="headerlink" title="10.17 Inappropriate Intimacy（不恰当的亲密关系，即狎昵关系）"></a>10.17 Inappropriate Intimacy（不恰当的亲密关系，即狎昵关系）</h3><ul><li>Move Method</li><li>Move Field</li><li>Change Bidirectional（双向） Association（关联） to Unidirectional（单向）</li><li>Extract Class</li><li>Hide Delegate</li><li>Replace Inheritance with Delegation</li></ul><h3 id="10-18-Alternative-Classes-with-Different-Interfaces（异曲同工的类）"><a href="#10-18-Alternative-Classes-with-Different-Interfaces（异曲同工的类）" class="headerlink" title="10.18 Alternative Classes with Different Interfaces（异曲同工的类）"></a>10.18 Alternative Classes with Different Interfaces（异曲同工的类）</h3><ul><li>Rename Method</li><li>Move Method</li><li>Extract SuperClass</li></ul><h3 id="10-19-Incomplete-Library-Class（不完美的类库）"><a href="#10-19-Incomplete-Library-Class（不完美的类库）" class="headerlink" title="10.19 Incomplete Library Class（不完美的类库）"></a>10.19 Incomplete Library Class（不完美的类库）</h3><ul><li>Introduce Foreign Method</li><li>Introduce Local Extension</li></ul><h3 id="10-20-Data-Class（纯粹的数据类）"><a href="#10-20-Data-Class（纯粹的数据类）" class="headerlink" title="10.20 Data Class（纯粹的数据类）"></a>10.20 Data Class（纯粹的数据类）</h3><p>指拥有一些字段以及访问（读写）这些字段的函数的类，即 Model 实体类。</p><ul><li>Encapsulate（封装） Field</li><li>Encapsulate Collection</li><li>Remove Setting Method</li><li>Move Method</li><li>Extract Method</li><li>Hide Method</li></ul><h3 id="10-21-Refused-Bequest（被拒绝的遗赠）"><a href="#10-21-Refused-Bequest（被拒绝的遗赠）" class="headerlink" title="10.21 Refused Bequest（被拒绝的遗赠）"></a>10.21 Refused Bequest（被拒绝的遗赠）</h3><p>子类不需要超类的函数和数据，意味着继承体系设计错误。</p><ul><li>Push Down Method</li><li>Push Down Field</li><li>Replace Iniheritance with Delegation</li></ul><h3 id="10-22-Comments（过多的注释）"><a href="#10-22-Comments（过多的注释）" class="headerlink" title="10.22 Comments（过多的注释）"></a>10.22 Comments（过多的注释）</h3><p>注释太长太多意味着代码很糟糕。</p><ul><li>Extract Method</li><li>Rename Method</li><li>Introduce Assertion<br><code>ps:</code>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</li></ul><h2 id="11-测试"><a href="#11-测试" class="headerlink" title="11 测试"></a>11 测试</h2><p>如果你想进行重构，首要前提就是拥有一个可靠的测试环境。<br><code>ps</code>：</p><ul><li>确保所有测试都完全自动化，让它们检查自己的测试结果。</li><li>一套测试就是一个强大的 bug 侦测器，能够大大缩减查找 bug 所需要的时间。</li><li>当事情被认为应该会出错时，别忘了检查是否抛出预期的异常。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>Replace Type Code with State/Strategy</li><li>Move Method</li><li>Replace Conditional with Polymorphism</li><li>Form Template Method</li><li>Replace Temp with Query</li><li>Extract Method</li><li>Self Encapsulate(自封装) Field</li></ul><h3 id="重构-vs-性能优化"><a href="#重构-vs-性能优化" class="headerlink" title="重构 vs 性能优化"></a>重构 vs 性能优化</h3><table><thead><tr><th>类型</th><th>重构</th><th>性能优化</th></tr></thead><tbody><tr><td>内部结构</td><td>改变</td><td>改变</td></tr><tr><td>外部行为</td><td>不改变或很小改变</td><td>不改变（除了执行速度）</td></tr><tr><td>目的</td><td>软件更容易被理解和修改，性能没有变化</td><td>性能提升，但往往使代码较难理解</td></tr></tbody></table><h3 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h3><ul><li><strong>怎么对经理说重构</strong>：很多经理嘴巴上说自己“质量驱动”，实际是“进度驱动”，这种情况建议是：不要告诉经理！</li><li>学习一种可以大幅提高生产力的新技术时，你总是难以察觉其不适用的场合。通常你在一个特定场景中学习它，这个场景往往是个项目。这种情况下你很难看出什么会造成这种新技术成效不彰或形成危害。</li><li><blockquote><p>他把未完成的重构工作形容为“债务”。很多公司都需要借债来使自己更有效的运转，但借债就得付利息，过于复杂的代码所造成的维护和扩展的额外成本就是利息。你可以承受一定程度的利息，但如果利息太高，你就会被压垮。把债务管理好是很重要的，你应该随时通过重构来偿还一部分债务。</p><footer><strong>Ward Cunningham</strong></footer></blockquote></li><li>重构与设计互补。</li><li>如果在所有可能的变化出现地点都建立起灵活性，整个系统的复杂度和维护难度都会大大提高。当然，如果最后发现所有这些灵活性都毫无必要，这才是最大的失败。</li><li>重构可以带来更简单的设计，同时又不损失灵活性，也降低了设计过程的难度，减轻了设计压力。</li><li><blockquote><p>哪怕你完全了解系统，也请实际度量它的性能，不要瞎猜。瞎猜可能会让你学到一些东西，但十有八九是错的。</p><footer><strong>Ron Jeffries</strong></footer></blockquote></li><li>如何确定该提炼哪一段代码：寻找注释，它们通常能指出代码用途和实现手法之间的语义距离。</li><li>对象技术的全部要点：将数据和对数据的操作行为包装到一起。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第1-4章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;重构（refactoring）是在不改变软件可观察行为的前提下改善其内部结构。&lt;/li&gt;
&lt;li&gt;重构是这样一个过程：在不改变代码外在行为的前提下，对代码进行修改，以改进程序的内部结构。&lt;/li&gt;
&lt;li&gt;重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高可理解性，降低其修改成本。&lt;/li&gt;
&lt;li&gt;重构（动词）：使用一系列重构首发，在不改变软件可观察行为的前提下，调整其结构。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器</title>
    <link href="http://www.venux.cn//posts/03.%E5%B7%A5%E5%85%B7/01.Linux/01.CentOS/vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://www.venux.cn//posts/03.工具/01.Linux/01.CentOS/vim编辑器/</id>
    <published>2018-05-28T10:06:26.000Z</published>
    <updated>2018-06-01T07:17:54.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h2 id="2-退出"><a href="#2-退出" class="headerlink" title="2. 退出"></a>2. 退出</h2><p>先按<code>Esc</code>切换命令模式，而后在<code>:</code>后输入相关命令：</p><ul><li><strong>wq</strong>：写入退出，等同于 <strong>x</strong>；</li><li><strong>q!</strong>：不保存退出；</li><li><strong>!</strong>：强制退出，并在提示后回车。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>Linux 命令要小写。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;h2 id=&quot;2-退出&quot;&gt;&lt;a href=&quot;#2-退出&quot; class=&quot;headerlink&quot; title=&quot;2. 退出&quot;&gt;
      
    
    </summary>
    
      <category term="03.工具" scheme="http://www.venux.cn/categories/03-%E5%B7%A5%E5%85%B7/"/>
    
      <category term="01.Linux" scheme="http://www.venux.cn/categories/03-%E5%B7%A5%E5%85%B7/01-Linux/"/>
    
      <category term="01.CentOS" scheme="http://www.venux.cn/categories/03-%E5%B7%A5%E5%85%B7/01-Linux/01-CentOS/"/>
    
    
      <category term="Linux" scheme="http://www.venux.cn/tags/Linux/"/>
    
      <category term="CentOS" scheme="http://www.venux.cn/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>CSharp与Java对比</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/04.%E5%85%B6%E4%BB%96/CSharp%E4%B8%8EJava%E5%AF%B9%E6%AF%94/"/>
    <id>http://www.venux.cn//posts/01.编程语言/04.其他/CSharp与Java对比/</id>
    <published>2018-05-25T12:05:42.000Z</published>
    <updated>2018-06-01T07:17:54.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-代码风格"><a href="#1-代码风格" class="headerlink" title="1.代码风格"></a>1.代码风格</h2><h3 id="1-1-命名规范"><a href="#1-1-命名规范" class="headerlink" title="1.1 命名规范"></a>1.1 命名规范</h3><h4 id="1-1-1-接口"><a href="#1-1-1-接口" class="headerlink" title="1.1.1 接口"></a>1.1.1 接口</h4><table><thead><tr><th>分类</th><th>详细</th><th>C#</th><th>Java</th></tr></thead><tbody><tr><td>命名</td><td>接口</td><td>前缀I</td><td>无</td></tr><tr><td>命名</td><td>接口实现</td><td>无</td><td>后缀Impl</td></tr><tr><td>命名</td><td>抽象类</td><td>前缀Base</td><td>前缀Abstract</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-代码风格&quot;&gt;&lt;a href=&quot;#1-代码风格&quot; class=&quot;headerlink&quot; title=&quot;1.代码风格&quot;&gt;&lt;/a&gt;1.代码风格&lt;/h2&gt;&lt;h3 id=&quot;1-1-命名规范&quot;&gt;&lt;a href=&quot;#1-1-命名规范&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="04.其他" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/04-%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="C#" scheme="http://www.venux.cn/tags/C/"/>
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C#代码规范</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://www.venux.cn//posts/01.编程语言/01.CSharp/CSharp代码规范/</id>
    <published>2018-05-25T10:06:26.000Z</published>
    <updated>2018-06-01T07:17:54.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-规范制定原则"><a href="#1-规范制定原则" class="headerlink" title="1.    规范制定原则"></a>1.    规范制定原则</h2><ul><li>方便代码的交流和维护。</li><li>不影响编码的效率，不与大众习惯冲突。</li><li>使代码更美观、阅读更方便。</li><li>使代码的逻辑更清晰、更易于理解。</li></ul><h2 id="2-术语定义"><a href="#2-术语定义" class="headerlink" title="2.    术语定义"></a>2.    术语定义</h2><h3 id="2-1-Pascal-大小写"><a href="#2-1-Pascal-大小写" class="headerlink" title="2.1 Pascal 大小写"></a>2.1 Pascal 大小写</h3><p>将标识符的首字母和后面连接的每个单词的首字母都大写。可以对三字符或更多字符的标识符使用Pascal 大小写。例如： BackColor。</p><h3 id="2-2-Camel-大小写"><a href="#2-2-Camel-大小写" class="headerlink" title="2.2 Camel 大小写"></a>2.2 Camel 大小写</h3><p>标识符的首字母小写，而每个后面连接的单词的首字母都大写。例如：backColor。</p><h2 id="3-代码外观"><a href="#3-代码外观" class="headerlink" title="3. 代码外观"></a>3. 代码外观</h2><h3 id="3-1-列宽"><a href="#3-1-列宽" class="headerlink" title="3.1 列宽"></a>3.1 列宽</h3><p>控制在 120 字符左右。</p><h3 id="3-2-换行"><a href="#3-2-换行" class="headerlink" title="3.2 换行"></a>3.2 换行</h3><ul><li>在逗号后换行。</li><li>在操作符前换行。</li><li>规则1优先于规则2。</li></ul><h3 id="3-3-缩进"><a href="#3-3-缩进" class="headerlink" title="3.3    缩进"></a>3.3    缩进</h3><p>缩进应该是每行一个Tab(4个空格)，不要在代码中使用Tab字符。<br><code>VS设置</code>：工具-&gt;选项-&gt;文本编辑器-&gt;C#-&gt;制表符-&gt;插入空格</p><h3 id="3-4-空行"><a href="#3-4-空行" class="headerlink" title="3.4    空行"></a>3.4    空行</h3><p>空行是为了将逻辑上相关联的代码分块，以便提高代码的可阅读性。</p><ul><li><p>在以下情况下使用两个空行</p><ul><li>接口和类的定义之间。</li><li>枚举和类的定义之间。</li><li>类与类的定义之间.</li></ul></li><li><p>在以下情况下使用一个空行</p><ul><li>方法与方法、属性与属性之间。</li><li>方法中变量声明与语句之间。</li><li>方法与方法之间。</li><li>方法中不同的逻辑块之间。</li><li>方法中的返回语句与其他的语句之间。</li><li>属性与方法、属性与字段、方法与字段之间。</li><li>注释与它注释的语句间不空行，但与其他的语句间空一行。</li></ul></li></ul><h3 id="3-5-程序注释"><a href="#3-5-程序注释" class="headerlink" title="3.5 程序注释"></a>3.5 程序注释</h3><h4 id="3-5-1-文件注释"><a href="#3-5-1-文件注释" class="headerlink" title="3.5.1 文件注释"></a>3.5.1 文件注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//===========================================================</span><br><span class="line">// Copyright (c) $年份 $公司名称.  </span><br><span class="line">// 版权所有.</span><br><span class="line">//===========================================================</span><br></pre></td></tr></table></figure><h4 id="3-5-2-对象注释（类、接口、枚举、结构等）"><a href="#3-5-2-对象注释（类、接口、枚举、结构等）" class="headerlink" title="3.5.2 对象注释（类、接口、枚举、结构等）"></a>3.5.2 对象注释（类、接口、枚举、结构等）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// $功能描述</span><br><span class="line">/// 作者：$作者</span><br><span class="line">/// 日期：$创建日期</span><br><span class="line">/// 版本：$版本号</span><br><span class="line">/// &lt;/summary&gt;</span><br></pre></td></tr></table></figure><h4 id="3-5-3-其他注释（单行注释、多行注释、方法注释）"><a href="#3-5-3-其他注释（单行注释、多行注释、方法注释）" class="headerlink" title="3.5.3 其他注释（单行注释、多行注释、方法注释）"></a>3.5.3 其他注释（单行注释、多行注释、方法注释）</h4><ul><li>方法注释<strong>必须</strong>；</li><li>其他根据情况自行添加。</li></ul><h2 id="4-命名规范"><a href="#4-命名规范" class="headerlink" title="4. 命名规范"></a>4. 命名规范</h2><h3 id="4-1-命名原则"><a href="#4-1-命名原则" class="headerlink" title="4.1 命名原则"></a>4.1 命名原则</h3><ul><li>使名称足够长以便有一定的意义，并且足够短以避免冗长。</li><li>唯一名称在编程上仅用于将各项区分开。</li><li>表现力强的名称是为了帮助人们阅读，提供人们可以理解的名称是有意义的。</li><li>请确保选择的名称符合适用语言的规则和标准。</li></ul><h3 id="4-2-命名空间"><a href="#4-2-命名空间" class="headerlink" title="4.2    命名空间"></a>4.2    命名空间</h3><p>命名命名空间时的一般性规则是使用公司名称，后跟项目名称和可选的功能与设计。<br><code>示例</code>：namespace CompanyName.ProjectName.ModuleName</p><h3 id="4-3-类"><a href="#4-3-类" class="headerlink" title="4.3    类"></a>4.3    类</h3><ul><li>使用 Pascal 大小写。</li><li>用名词或名词短语命名类。</li><li>使用全称避免缩写，除非缩写已是一种公认的约定，如URL、HTML。</li><li>不要使用类型前缀，如在类名称上对类使用 C 前缀。例如，使用类名称 FileStream，而不是 CFileStream。 </li></ul><h3 id="4-4-接口"><a href="#4-4-接口" class="headerlink" title="4.4    接口"></a>4.4    接口</h3><ul><li>用名词或名词短语，或者描述行为的形容词命名接口。例如，接口名称 IComponent 使用描述性名词。接口名称 ICustomAttributeProvider 使用名词短语。名称 IPersistable 使用形容词。 </li><li>使用 Pascal 大小写。 </li><li>少用缩写。 </li><li>给接口名称加上字母 I 前缀，以指示该类型为接口。在定义类/接口对（其中类是接口的标准实现）时使用相似的名称。两个名称的区别应该只是接口名称上有字母 I 前缀。</li><li>当类是接口的标准执行时，定义这一对类/接口组合就要使用相似的名称。两个名称的不同之处只是接口名前有一个I前缀。</li></ul><h3 id="4-5-属性-Attribute"><a href="#4-5-属性-Attribute" class="headerlink" title="4.5 属性 (Attribute)"></a>4.5 属性 (Attribute)</h3><ul><li>将后缀 Attribute 添加到自定义属性类。</li></ul><h3 id="4-6-枚举-Enum"><a href="#4-6-枚举-Enum" class="headerlink" title="4.6    枚举 (Enum)"></a>4.6    枚举 (Enum)</h3><ul><li>对于 Enum 类型和值名称使用 Pascal 大小写。 </li><li>少用缩写。 </li><li>不要在 Enum 类型名称上使用 Enum 后缀。</li></ul><h3 id="4-7-参数"><a href="#4-7-参数" class="headerlink" title="4.7    参数"></a>4.7    参数</h3><ul><li>使用描述性参数名称。参数名称应当具有足够的描述性，以便参数的名称及其类型可用于在大多数情况下确定它的含义。 </li><li>对参数名称使用 Camel 大小写。 </li><li>使用描述参数的含义的名称，而不要使用描述参数的类型的名称。开发工具将提供有关参数的类型的有意义的信息。因此， 通过描述意义，可以更好地使用参数的名称。少用基于类型的参数名称，仅在适合使用它们的地方使用它们。 </li><li>不要使用保留的参数。保留的参数是专用参数，如果需要，可以在未来的版本中公开它们。相反，如果在类库的未来版本中需要更多的数据，请为方法添加新的重载。 </li><li>不要给参数名称加匈牙利语类型表示法的前缀。 </li></ul><h3 id="4-8-方法"><a href="#4-8-方法" class="headerlink" title="4.8    方法"></a>4.8    方法</h3><ul><li>使用动词或动词短语命名方法。 </li><li>使用 Pascal 大小写。</li></ul><h3 id="4-9-属性-property"><a href="#4-9-属性-property" class="headerlink" title="4.9    属性 (property)"></a>4.9    属性 (property)</h3><ul><li>使用名词或名词短语命名属性。 </li><li>使用 Pascal 大小写。 </li><li>不要使用匈牙利语表示法。</li></ul><h3 id="4-10-常量-const"><a href="#4-10-常量-const" class="headerlink" title="4.10    常量 (const)"></a>4.10    常量 (const)</h3><ul><li>所有单词大写，多个单词之间用 “_” 隔开。</li></ul><h3 id="4-11-字段-Field"><a href="#4-11-字段-Field" class="headerlink" title="4.11 字段(Field)"></a>4.11 字段(Field)</h3><ul><li>private、protected 使用 Camel 大小写。</li><li>public 使用 Pascal 大小写。</li><li>为了区分字段和局部变量，建议在首字母前加一下划线_。<br><code>ps</code>：C# 中通常字段只有 private，若需暴露，请使用属性。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-规范制定原则&quot;&gt;&lt;a href=&quot;#1-规范制定原则&quot; class=&quot;headerlink&quot; title=&quot;1.    规范制定原则&quot;&gt;&lt;/a&gt;1.    规范制定原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;方便代码的交流和维护。&lt;/li&gt;
&lt;li&gt;不影响编码的效率，不与
      
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="01.CSharp" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-CSharp/"/>
    
    
      <category term="C#" scheme="http://www.venux.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>DDD-01介绍</title>
    <link href="http://www.venux.cn//posts/08.%E6%9E%B6%E6%9E%84/01.DDD/01.%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.venux.cn//posts/08.架构/01.DDD/01.介绍/</id>
    <published>2018-05-14T03:06:38.000Z</published>
    <updated>2018-06-01T07:17:54.496Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="08.架构" scheme="http://www.venux.cn/categories/08-%E6%9E%B6%E6%9E%84/"/>
    
      <category term="01.DDD" scheme="http://www.venux.cn/categories/08-%E6%9E%B6%E6%9E%84/01-DDD/"/>
    
    
      <category term="DDD" scheme="http://www.venux.cn/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>java-Tomcat</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-Tomcat/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-Tomcat/</id>
    <published>2018-04-18T14:13:30.000Z</published>
    <updated>2018-06-01T07:17:54.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>Apache 基金会下的一款开源的 web 服务器。</p><h2 id="2-下载"><a href="#2-下载" class="headerlink" title="2.下载"></a>2.下载</h2><p><a href="http://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">Tomcat下载</a></p><h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><p>解压缩到指定目录</p><h3 id="3-1-目录结构"><a href="#3-1-目录结构" class="headerlink" title="3.1 目录结构"></a>3.1 目录结构</h3><ul><li>bin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。</li><li>conf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。</li><li>lib：库文件。tomcat运行时需要的jar包所在的目录</li><li>logs：日志</li><li>temp：临时产生的文件，即缓存</li><li>webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问</li><li>work：编译以后的class文件。</li></ul><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><h3 id="4-1-环境变量配置"><a href="#4-1-环境变量配置" class="headerlink" title="4.1 环境变量配置"></a>4.1 环境变量配置</h3><ol><li><strong>CATALINA_HOME</strong>：C:\Program Files\Tomcat 8.5（注：结尾不加分号）</li><li><strong>PATH</strong>:%CATALINA_HOME%\bin;</li><li><strong>CLASS_PATH</strong>:%CATALINA_HOME%\lib;</li></ol><h3 id="4-2-配置文件"><a href="#4-2-配置文件" class="headerlink" title="4.2 配置文件"></a>4.2 配置文件</h3><p>$CATALINA_HOME 目录下的 conf 目录，核心配置文件 server.xml。</p><h2 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h2><p>进入 $CATALINA_HOME 目录下的 bin 目录，运行 startup.bat 即可。</p><h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h3><ul><li><strong>localhost:8080</strong>:Tomcat默认主页</li></ul><h3 id="7-Eclipse集成"><a href="#7-Eclipse集成" class="headerlink" title="7 Eclipse集成"></a>7 Eclipse集成</h3><ul><li>“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。</li></ul><a id="more"></a><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;p&gt;Apache 基金会下的一款开源的 web 服务器。&lt;/p&gt;
&lt;h2 id=&quot;2-下载&quot;&gt;&lt;a href=&quot;#2-下载&quot; class=&quot;headerlink&quot; title=&quot;2.下载&quot;&gt;&lt;/a&gt;2.下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://tomcat.apache.org/download-90.cgi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tomcat下载&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-安装&quot;&gt;&lt;a href=&quot;#3-安装&quot; class=&quot;headerlink&quot; title=&quot;3. 安装&quot;&gt;&lt;/a&gt;3. 安装&lt;/h2&gt;&lt;p&gt;解压缩到指定目录&lt;/p&gt;
&lt;h3 id=&quot;3-1-目录结构&quot;&gt;&lt;a href=&quot;#3-1-目录结构&quot; class=&quot;headerlink&quot; title=&quot;3.1 目录结构&quot;&gt;&lt;/a&gt;3.1 目录结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;bin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。&lt;/li&gt;
&lt;li&gt;conf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。&lt;/li&gt;
&lt;li&gt;lib：库文件。tomcat运行时需要的jar包所在的目录&lt;/li&gt;
&lt;li&gt;logs：日志&lt;/li&gt;
&lt;li&gt;temp：临时产生的文件，即缓存&lt;/li&gt;
&lt;li&gt;webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问&lt;/li&gt;
&lt;li&gt;work：编译以后的class文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-配置&quot;&gt;&lt;a href=&quot;#4-配置&quot; class=&quot;headerlink&quot; title=&quot;4. 配置&quot;&gt;&lt;/a&gt;4. 配置&lt;/h2&gt;&lt;h3 id=&quot;4-1-环境变量配置&quot;&gt;&lt;a href=&quot;#4-1-环境变量配置&quot; class=&quot;headerlink&quot; title=&quot;4.1 环境变量配置&quot;&gt;&lt;/a&gt;4.1 环境变量配置&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CATALINA_HOME&lt;/strong&gt;：C:\Program Files\Tomcat 8.5（注：结尾不加分号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PATH&lt;/strong&gt;:%CATALINA_HOME%\bin;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLASS_PATH&lt;/strong&gt;:%CATALINA_HOME%\lib;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;4-2-配置文件&quot;&gt;&lt;a href=&quot;#4-2-配置文件&quot; class=&quot;headerlink&quot; title=&quot;4.2 配置文件&quot;&gt;&lt;/a&gt;4.2 配置文件&lt;/h3&gt;&lt;p&gt;$CATALINA_HOME 目录下的 conf 目录，核心配置文件 server.xml。&lt;/p&gt;
&lt;h2 id=&quot;5-启动&quot;&gt;&lt;a href=&quot;#5-启动&quot; class=&quot;headerlink&quot; title=&quot;5. 启动&quot;&gt;&lt;/a&gt;5. 启动&lt;/h2&gt;&lt;p&gt;进入 $CATALINA_HOME 目录下的 bin 目录，运行 startup.bat 即可。&lt;/p&gt;
&lt;h3 id=&quot;6-测试&quot;&gt;&lt;a href=&quot;#6-测试&quot; class=&quot;headerlink&quot; title=&quot;6. 测试&quot;&gt;&lt;/a&gt;6. 测试&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;localhost:8080&lt;/strong&gt;:Tomcat默认主页&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;7-Eclipse集成&quot;&gt;&lt;a href=&quot;#7-Eclipse集成&quot; class=&quot;headerlink&quot; title=&quot;7 Eclipse集成&quot;&gt;&lt;/a&gt;7 Eclipse集成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-JSP</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-JSP/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-JSP/</id>
    <published>2018-04-18T14:05:19.000Z</published>
    <updated>2018-06-01T07:17:54.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>JSP（Java Server Pages），一种动态网页开发技术，类似于 ASP。通常以<code>&lt;%</code>开头，以<code>%&gt;</code>结尾。</p><a id="more"></a><h2 id="2-特点（与CGI对比）"><a href="#2-特点（与CGI对比）" class="headerlink" title="2 特点（与CGI对比）"></a>2 特点（与CGI对比）</h2><ul><li>性能更加优越，因为JSP可以直接在HTML网页中动态嵌入元素而不需要单独引用CGI文件。</li><li>服务器调用的是已经编译好的JSP文件，而不像CGI/Perl那样必须先载入解释器和目标脚本。</li><li>JSP 基于Java Servlet API，因此，JSP拥有各种强大的企业级Java API，包括JDBC，JNDI，EJB，JAXP等等。</li><li>JSP页面可以与处理业务逻辑的 Servlet 一起使用，这种模式被Java servlet 模板引擎所支持。</li></ul><h2 id="3-JSP-流程"><a href="#3-JSP-流程" class="headerlink" title="3 JSP 流程"></a>3 JSP 流程</h2><p><img src="/images/posts/jsp-arch.jpg" alt="JSP 位置"><br><img src="/images/posts/jsp-processing.jpg" alt="JSP 流程"></p><ul><li>浏览器发送一个 HTTP 请求给服务器。</li><li>Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成。</li><li>JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码。</li><li>JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎。</li><li>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。</li><li>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。</li><li>Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样。</li></ul><h2 id="4-JSP-生命周期"><a href="#4-JSP-生命周期" class="headerlink" title="4 JSP 生命周期"></a>4 JSP 生命周期</h2><p><img src="/images/posts/jsp_life_cycle.jpg" alt="JSP 生命周期"></p><ul><li><strong>编译阶段</strong>：servlet容器编译servlet源文件，生成servlet类。若未修改，则跳过。<ul><li>解析JSP文件。</li><li>将JSP文件转为servlet。</li><li>编译servlet。</li></ul></li><li><p><strong>初始化阶段</strong>：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//JSP初始化代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行阶段</strong>：调用与JSP对应的servlet实例的服务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">  <span class="comment">//服务端处理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>销毁阶段</strong>：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//清理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-JSP-语法"><a href="#5-JSP-语法" class="headerlink" title="5 JSP 语法"></a>5 JSP 语法</h2><h3 id="5-1-脚本程序"><a href="#5-1-脚本程序" class="headerlink" title="5.1 脚本程序"></a>5.1 脚本程序</h3><p>可包含任意量的Java语句、变量、方法或表达式。格式：<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% 代码片段 %&gt;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:scriptlet&gt;</span><br><span class="line">  代码片段</span><br><span class="line">&lt;/jsp:scriptlet&gt;</span><br></pre></td></tr></table></figure></p><h3 id="5-2-头部支持中文"><a href="#5-2-头部支持中文" class="headerlink" title="5.2 头部支持中文"></a>5.2 头部支持中文</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html;charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="5-3-声明"><a href="#5-3-声明" class="headerlink" title="5.3 声明"></a>5.3 声明</h3><p>一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! declaration;[ declaration;]+ ... %&gt;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:declaration&gt;</span><br><span class="line">  代码片段</span><br><span class="line">&lt;/jsp:declaration&gt;</span><br></pre></td></tr></table></figure></p><h3 id="5-4-表达式"><a href="#5-4-表达式" class="headerlink" title="5.4 表达式"></a>5.4 表达式</h3><p>一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。<br><code>注意：</code>不能以分号来结束。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 表达式 %&gt;</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:expression&gt;</span><br><span class="line">   表达式</span><br><span class="line">&lt;/jsp:expression&gt;</span><br></pre></td></tr></table></figure></p><h3 id="5-5-注释"><a href="#5-5-注释" class="headerlink" title="5.5 注释"></a>5.5 注释</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--注释--%&gt;</span><br></pre></td></tr></table></figure><h3 id="5-6-指令"><a href="#5-6-指令" class="headerlink" title="5.6 指令"></a>5.6 指令</h3><p>设置与整个JSP页面相关的属性。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ directive attribute=<span class="string">"value"</span> %&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>&lt;%@ page … %&gt;</td><td>定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td></tr><tr><td>&lt;%@ include … %&gt;</td><td>包含其他文件</td></tr><tr><td>&lt;%@ taglib … %&gt;</td><td>引入标签库的定义，可以是自定义标签</td></tr></tbody></table><h3 id="5-7-行为"><a href="#5-7-行为" class="headerlink" title="5.7 行为"></a>5.7 行为</h3><p>使用XML语法结构来控制servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。<br>行为标签只有一种语法格式，它严格遵守XML标准。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:action_name attribute=<span class="string">"value"</span> /&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>jsp:include</td><td>用于在当前页面中包含静态或动态资源</td></tr><tr><td>jsp:useBean</td><td>寻找和初始化一个JavaBean组件</td></tr><tr><td>jsp:setProperty</td><td>设置 JavaBean组件的值</td></tr><tr><td>jsp:getProperty</td><td>将 JavaBean组件的值插入到 output中</td></tr><tr><td>jsp:forward</td><td>从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td></tr><tr><td>jsp:plugin</td><td>用于在生成的HTML页面中包含Applet和JavaBean对象</td></tr><tr><td>jsp:element</td><td>动态创建一个XML元素</td></tr><tr><td>jsp:attribute</td><td>定义动态创建的XML元素的属性</td></tr><tr><td>jsp:body</td><td>定义动态创建的XML元素的主体</td></tr><tr><td>jsp:text</td><td>用于封装模板数据</td></tr></tbody></table><h3 id="5-8-隐含对象"><a href="#5-8-隐含对象" class="headerlink" title="5.8 隐含对象"></a>5.8 隐含对象</h3><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>request</td><td>HttpServletRequest类的实例</td></tr><tr><td>response</td><td>HttpServletResponse类的实例</td></tr><tr><td>out</td><td>PrintWriter类的实例，用于把结果输出至网页上</td></tr><tr><td>session</td><td>HttpSession类的实例</td></tr><tr><td>application</td><td>ServletContext类的实例，与应用上下文有关</td></tr><tr><td>config</td><td>ServletConfig类的实例</td></tr><tr><td>pageContext</td><td>PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问</td></tr><tr><td>page</td><td>类似于Java类中的this关键字</td></tr><tr><td>Exception</td><td>Exception类的对象，代表发生错误的JSP页面中对应的异常对象</td></tr></tbody></table><h3 id="5-9-控制流语句"><a href="#5-9-控制流语句" class="headerlink" title="5.9 控制流语句"></a>5.9 控制流语句</h3><h4 id="5-9-1-判断语句"><a href="#5-9-1-判断语句" class="headerlink" title="5.9.1 判断语句"></a>5.9.1 判断语句</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;% <span class="keyword">if</span>(flag)&#123; %&gt;</span><br><span class="line">  &lt;p&gt;True&lt;/p&gt;</span><br><span class="line">&lt;% &#125;<span class="keyword">else</span>&#123; %&gt;</span><br><span class="line">  &lt;p&gt;False&lt;/p&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="5-9-2-循环语句"><a href="#5-9-2-循环语句" class="headerlink" title="5.9.2 循环语句"></a>5.9.2 循环语句</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">for</span> ( index = <span class="number">1</span>; index &lt;= <span class="number">3</span>; index++)&#123; %&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;%= index %&gt; </span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="5-10-运算符"><a href="#5-10-运算符" class="headerlink" title="5.10 运算符"></a>5.10 运算符</h3><p>JSP支持所有Java逻辑和算术运算符。</p><h3 id="5-11-字面量"><a href="#5-11-字面量" class="headerlink" title="5.11 字面量"></a>5.11 字面量</h3><ul><li>布尔值(boolean)：true 和 false;</li><li>整型(int)：与 Java 中的一样;</li><li>浮点型(float)：与 Java 中的一样;</li><li>字符串(string)：以单引号或双引号开始和结束;</li><li>Null：null。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;p&gt;JSP（Java Server Pages），一种动态网页开发技术，类似于 ASP。通常以&lt;code&gt;&amp;lt;%&lt;/code&gt;开头，以&lt;code&gt;%&amp;gt;&lt;/code&gt;结尾。&lt;/p&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-名词解释</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-名词解释/</id>
    <published>2018-04-15T14:19:21.000Z</published>
    <updated>2018-06-01T07:17:54.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1 名词解释"></a>1 名词解释</h2><table><thead><tr><th>缩写</th><th>全称</th><th>详细信息</th></tr></thead><tbody><tr><td>POJOs</td><td>Plain Old Java Objects</td><td>普通的 Java对象</td></tr><tr><td>DAO</td><td>Data Access Objects</td><td>数据访问对象</td></tr><tr><td>CGI</td><td>Common Gateway Interfa e</td><td>公共网关接口</td></tr><tr><td>JSP</td><td>Java Server Pages</td><td>Java服务页面（动态网页开发技术）</td></tr></tbody></table><a id="more"></a><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-名词解释&quot;&gt;&lt;a href=&quot;#1-名词解释&quot; class=&quot;headerlink&quot; title=&quot;1 名词解释&quot;&gt;&lt;/a&gt;1 名词解释&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;th&gt;全称&lt;/th&gt;
&lt;th&gt;详细信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;POJOs&lt;/td&gt;
&lt;td&gt;Plain Old Java Objects&lt;/td&gt;
&lt;td&gt;普通的 Java对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DAO&lt;/td&gt;
&lt;td&gt;Data Access Objects&lt;/td&gt;
&lt;td&gt;数据访问对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CGI&lt;/td&gt;
&lt;td&gt;Common Gateway Interfa e&lt;/td&gt;
&lt;td&gt;公共网关接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JSP&lt;/td&gt;
&lt;td&gt;Java Server Pages&lt;/td&gt;
&lt;td&gt;Java服务页面（动态网页开发技术）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-MyBatis</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-MyBatis/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-MyBatis/</id>
    <published>2018-04-15T14:17:04.000Z</published>
    <updated>2018-06-01T07:17:54.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>MyBatis 是一款<strong>持久层框架</strong>，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><a id="more"></a><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;p&gt;MyBatis 是一款&lt;strong&gt;持久层框架&lt;/strong&gt;，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-Maven</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-Maven/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-Maven/</id>
    <published>2018-04-15T09:36:50.000Z</published>
    <updated>2018-06-01T07:17:54.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>Maven 是一个项目构建和管理的自动化工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。</p><p>Maven 使用惯例优于配置的原则 。它要求在没有定制之前，所有的项目都有如下的结构：</p><table><thead><tr><th>目录</th><th>目的</th></tr></thead><tbody><tr><td>${basedir}</td><td>存放 pom.xml和所有的子目录</td></tr><tr><td>${basedir}/src/main/java</td><td>项目的 java源代码</td></tr><tr><td>${basedir}/src/main/resources</td><td>项目的资源，比如说 property文件</td></tr><tr><td>${basedir}/src/test/java</td><td>项目的测试类，比如说 JUnit代码</td></tr><tr><td>${basedir}/src/test/resources</td><td>测试使用的资源</td></tr></tbody></table><p>一个 maven 项目在默认情况下会产生 JAR 文件，另外 ，编译后 的 classes 会放在 ${basedir}/target/classes 下面， JAR 文件会放在 ${basedir}/target 下面。<br><a id="more"></a></p><h2 id="2-下载-amp-安装-amp-配置"><a href="#2-下载-amp-安装-amp-配置" class="headerlink" title="2 下载&amp;安装&amp;配置"></a>2 下载&amp;安装&amp;配置</h2><h3 id="2-1-前提"><a href="#2-1-前提" class="headerlink" title="2.1 前提"></a>2.1 前提</h3><p>需安装配置 java 开发环境</p><h3 id="2-2-下载地址"><a href="#2-2-下载地址" class="headerlink" title="2.2 下载地址"></a>2.2 下载地址</h3><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven下载</a></p><h3 id="2-3-安装"><a href="#2-3-安装" class="headerlink" title="2.3 安装"></a>2.3 安装</h3><p>直接解压缩到指定目录</p><h3 id="2-4-配置"><a href="#2-4-配置" class="headerlink" title="2.4 配置"></a>2.4 配置</h3><p>配置文件：<code>‪C:\Program Files\apache-maven-3.5.0\conf\settings.xml</code></p><ol><li><strong>MAVEN_HOME</strong>:C:\Program Files\apache-maven-3.5.0（注：结尾不加分号）</li><li><strong>PATH</strong>:%MAVEN_HOME%\bin;</li><li><strong>MAVEN_OPTS</strong>: -Xms128m -Xmx512m;(设置Maven可用内存大小)</li><li>修改本地仓库路径：setting.xml 中的 localRepository。</li></ol><h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><ul><li><strong>mvn -v</strong>:版本号</li></ul><h3 id="2-6-集成IDE"><a href="#2-6-集成IDE" class="headerlink" title="2.6 集成IDE"></a>2.6 集成IDE</h3><ul><li>Eclipse IDE：<a href="https://www.eclipse.org/m2e/" target="_blank" rel="noopener">M2Eclipse</a>，直接搜索 Maven 即可。<ul><li>Launching Maven builds from within Eclipse</li><li>Dependency management for Eclipse build path based on Maven’s pom.xml</li><li>Resolving Maven dependencies from the Eclipse workspace without installing to local Maven repository</li><li>Automatic downloading of the required dependencies and sources from the remote Maven repositories</li><li>Wizards for creating new Maven projects, pom.xml and to enable Maven support on existing projects</li><li>Quick search for dependencies in remote Maven repositories</li><li>Quick fixes in the Java editor for looking up required dependencies/jars by the class or package name</li><li>Integration with other Eclipse tools, such as WTP, AJDT, Mylyn, Subclipse and others.</li></ul></li><li>Intellij IDEA:<a href="https://www.jetbrains.com/help/idea/maven.html" target="_blank" rel="noopener">Intellij IDEA-Maven</a></li></ul><h2 id="3-核心概念"><a href="#3-核心概念" class="headerlink" title="3 核心概念"></a>3 核心概念</h2><h3 id="3-1-POM（Project-Object-Model）-ps-个人理解为类似于VS的csproj文件，用于管理项目"><a href="#3-1-POM（Project-Object-Model）-ps-个人理解为类似于VS的csproj文件，用于管理项目" class="headerlink" title="3.1 POM（Project Object Model）[ps:个人理解为类似于VS的csproj文件，用于管理项目]"></a>3.1 POM（Project Object Model）[ps:个人理解为类似于VS的csproj文件，用于管理项目]</h3><p>pom 是一个 xml，是maven工作的基础，在执行 task 或者 goal 时，maven 会去项目根目录下读取 pom.xml 获得需要的配置信息。该文件包括项目的信息和 maven build 项目所需的配置信息，通常有项目信息(如版本、成员)、项目的依赖、插件和 goal 、build 选项等等。<br>pom 是可继承的，大型项目中，子模块的 pom 需指定父模块的 pom。<br>节点定义：</p><ul><li>project：pom文件的顶级元素</li><li>modelVersion：所使用的object model版本，为了确保稳定的使用，这个元素是强制性的。除非maven开发者升级模板，否则不需要修改</li><li>groupId：是项目创建团体或组织的唯一标志符，通常是域名倒写，如groupId  org.apache.maven.plugins就是为所有maven插件预留的</li><li>artifactId：是项目artifact唯一的基地址名</li><li>packaging：artifact打包的方式，如jar、war、ear等等。默认为jar。这个不仅表示项目最终产生何种后缀的文件，也表示build过程使用什么样的lifecycle。</li><li>version：artifact的版本，通常能看见为类似0.0.1-SNAPSHOT，其中SNAPSHOT表示项目开发中，为开发版本</li><li>name：表示项目的展现名，在maven生成的文档中使用</li><li>url：表示项目的地址，在maven生成的文档中使用</li><li>description：表示项目的描述，在maven生成的文档中使用</li><li>dependencies：表示依赖，在子节点dependencies中添加具体依赖的groupId - artifactId和version</li><li>build：表示build配置</li><li>parent：表示父pom</li></ul><h3 id="3-2-Artifact（类似于-nuget-中的包）"><a href="#3-2-Artifact（类似于-nuget-中的包）" class="headerlink" title="3.2 Artifact（类似于 nuget 中的包）"></a>3.2 Artifact（类似于 nuget 中的包）</h3><ul><li>需指定项目要产生的文件，如 jar，源文件，二进制，war，pom 等，类似于 VS 中的项目类型。</li><li>groupId:artifactId:version 组成的标识符唯一识别，唯一确定了一个 artifact。</li><li>需要被使用(依赖)的 artifact 都要放在仓库(见Repository)中。</li></ul><h3 id="3-3-Repositories（仓储）"><a href="#3-3-Repositories（仓储）" class="headerlink" title="3.3 Repositories（仓储）"></a>3.3 Repositories（仓储）</h3><ul><li>主要用来存储 Artifact。</li><li>可分为本地和远程。<ul><li>本地对 Windows 系统存放于<code>用户/.m2/repository</code>，可修改。</li></ul></li></ul><h3 id="3-4-Build-Lifecycle（构建生存周期）"><a href="#3-4-Build-Lifecycle（构建生存周期）" class="headerlink" title="3.4 Build Lifecycle（构建生存周期）"></a>3.4 Build Lifecycle（构建生存周期）</h3><p>指一个项目的构建过程，由 phase（片段） 构成。分三种：</p><ul><li>default：处理项目的部署，大致流程：<ol><li>validate 验证项目是否正确以及必须的信息是否可用</li><li>compile 编译源代码</li><li>test 测试编译后的代码，即执行单元测试代码</li><li>package 打包编译后的代码，在target目录下生成package文件</li><li>integration-test 处理package以便需要时可以部署到集成测试环境</li><li>verify 检验package是否有效并且达到质量标准</li><li>install 安装package到本地仓库，方便本地其它项目使用</li><li>deploy 部署，拷贝最终的package到远程仓库和替他开发这或项目共享，在集成或发布环境完成</li></ol></li><li>clean：处理项目的清理</li><li>site：处理项目的文档生成</li></ul><p>注意：phase 是有序的，执行指定的 phase 时，会先执行完之前的 phase。</p><h3 id="3-5-Goal（任务）"><a href="#3-5-Goal（任务）" class="headerlink" title="3.5 Goal（任务）"></a>3.5 Goal（任务）</h3><p>表示一个特定的任务，区别于 build。</p><ul><li>mvn compile：编译</li><li>mvn package：打包</li><li>mvn deploy：部署</li><li>mvn clean install：先执行 clean 之前的 phase，在执行 clean，install。</li><li>mvn install：安装到本地</li></ul><h3 id="3-6-Archetype（原型）"><a href="#3-6-Archetype（原型）" class="headerlink" title="3.6 Archetype（原型）"></a>3.6 Archetype（原型）</h3><p>类似于 .net core 的项目模板</p><h2 id="4-常用参数"><a href="#4-常用参数" class="headerlink" title="4 常用参数"></a>4 常用参数</h2><ul><li>mvn -e：显示详细错误</li><li>mvn -U：强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖）</li><li>mvn -o：运行offline模式，不联网更新依赖</li><li>mvn -N：仅在当前项目模块执行命令，关闭reactor</li><li>mvn -pl：module_name在指定模块上执行命令</li><li>mvn -ff：在递归执行命令过程中，一旦发生错误就直接退出</li><li>mvn -Dxxx=yyy：指定java全局属性</li><li>mvn -Pxxx：引用profile xxx</li><li>mvn test-compile：编译测试代码</li><li>mvn test：运行程序中的单元测试</li><li>mvn compile：编译项目</li><li>mvn package：打包，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件</li><li>mvn install：打包并安装到本地仓库，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。每个phase都可以作为goal，也可以联合，如之前介绍的mvn clean install</li><li>mvn archetype:generate：创建maven项目</li><li>mvn package：打包，上面已经介绍过了</li><li>mvn package：-Prelease打包，并生成部署用的包，比如deploy/*.tgz</li><li>mvn install：打包并安装到本地库</li><li>mvn eclipse:eclipse：生成eclipse项目文件</li><li>mvn eclipse:clean：清除eclipse项目文件</li><li>mvn site：生成项目相关信息的网站</li><li>mvn -Dwtpversion=2.0：指定maven版本</li><li>mvn -Dmaven.test.skip=true：如果命令包含了test phase，则忽略单元测试</li><li>mvn -DuserProp=filePath：指定用户自定义配置文件位置</li><li>mvn -DdownloadSources=true -Declipse.addVersionToProjectName=true eclipse:eclipse：生成eclipse项目文件，尝试从仓库下载源代码，并且生成的项目包含模块版本（注意如果使用公用POM，上述的开关缺省已打开）</li><li>mvn -Dsurefire.useFile=false：如果执行单元测试出错，用该命令可以在console输出失败的单元测试及相关信息</li><li>set MAVEN_OPTS=-Xmx512m -XX:MaxPermSize=256m：调大jvm内存和持久代，maven/jvm out of memory error</li><li>mvn -X：maven log level设定为debug在运行</li><li>mvn debug：运行jpda允许remote debug</li><li>mvn –help 帮助</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://maven.apache.org/index.html" target="_blank" rel="noopener">Maven官网</a><br>2 <a href="http://blog.csdn.net/column/details/maven-it.html" target="_blank" rel="noopener">Maven入门</a><br>3 <a href="http://www.trinea.cn/android/maven/" target="_blank" rel="noopener">Maven介绍，包括作用、核心概念、用法、常用命令、扩展及配置</a><br>4 <a href="http://www.oracle.com/technetwork/cn/community/java/apache-maven-getting-started-1-406235-zhs.html" target="_blank" rel="noopener">Maven入门介绍</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;p&gt;Maven 是一个项目构建和管理的自动化工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。&lt;/p&gt;
&lt;p&gt;Maven 使用惯例优于配置的原则 。它要求在没有定制之前，所有的项目都有如下的结构：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;目的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;${basedir}&lt;/td&gt;
&lt;td&gt;存放 pom.xml和所有的子目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;${basedir}/src/main/java&lt;/td&gt;
&lt;td&gt;项目的 java源代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;${basedir}/src/main/resources&lt;/td&gt;
&lt;td&gt;项目的资源，比如说 property文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;${basedir}/src/test/java&lt;/td&gt;
&lt;td&gt;项目的测试类，比如说 JUnit代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;${basedir}/src/test/resources&lt;/td&gt;
&lt;td&gt;测试使用的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个 maven 项目在默认情况下会产生 JAR 文件，另外 ，编译后 的 classes 会放在 ${basedir}/target/classes 下面， JAR 文件会放在 ${basedir}/target 下面。&lt;br&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
      <category term="Maven" scheme="http://www.venux.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>java-反射</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%8F%8D%E5%B0%84/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-反射/</id>
    <published>2018-04-09T15:36:43.000Z</published>
    <updated>2018-06-01T07:17:54.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Class（java-lang-Class）"><a href="#1-Class（java-lang-Class）" class="headerlink" title="1 Class（java.lang.Class）"></a>1 Class（java.lang.Class）</h2><p>该类是反射的核心，获取类的Class对象引用方式：</p><ul><li>使用类文字，如Test.class、double.class（等价于Doubel.TYPE）和void.class；</li><li>使用Object类的getClass()方法</li><li>使用Class类的forName()静态方法</li></ul><a id="more"></a><h2 id="2-字段"><a href="#2-字段" class="headerlink" title="2 字段"></a>2 字段</h2><ul><li>getFields()方法返回所有可访问的公共字段在类中声明或继承自超类。</li><li>getDeclaredFields()方法返回所有字段只出现在类的声明中(不是从继承的字段)。</li><li>getField(String name)和 getDeclaredField(String name)通过字段名获取 Field 对象。</li></ul><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h2><ul><li>java.lang.reflect.Method（继承自抽象类Executable） 类的实例表示一个方法。</li><li>java.lang.reflect.Constructor（继承自抽象类Executable） 类的实例表示一个构造函数。</li><li>Parameter 类：可执行文件中的参数。默认情况，参数名称不存储在类文件中，而类似于arg0,arg1。</li><li>TypeVariable：通用方法或构造函数的类型参数。</li><li>Executable类（抽象）：可执行。<ul><li>getParameters()：获取参数数组；</li><li>getExceptionTypes()：获取异常数组；</li><li>getTypeParameters()：获取类型参数数组；</li><li>getModifiers()：获取修饰符</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[]  getMethods()</span><br><span class="line">Method[]  getDeclaredMethods()：返回当前类的所有声明的构造函数。</span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name,  Class...  parameterTypes)</span></span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name,  Class...  parameterTypes)</span></span></span><br></pre></td></tr></table></figure><h2 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4 构造函数"></a>4 构造函数</h2><ul><li>Constructor[] getConstructors()：返回当前和超类的所有公共构造函数。</li><li>Constructor[]  getDeclaredConstructors()</li><li>Constructor<t> getConstructor(Class…  parameterTypes)</t></li><li>Constructor<t> getDeclaredConstructor(Class…  parameterTypes)</t></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Class（java-lang-Class）&quot;&gt;&lt;a href=&quot;#1-Class（java-lang-Class）&quot; class=&quot;headerlink&quot; title=&quot;1 Class（java.lang.Class）&quot;&gt;&lt;/a&gt;1 Class（java.lang.Class）&lt;/h2&gt;&lt;p&gt;该类是反射的核心，获取类的Class对象引用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用类文字，如Test.class、double.class（等价于Doubel.TYPE）和void.class；&lt;/li&gt;
&lt;li&gt;使用Object类的getClass()方法&lt;/li&gt;
&lt;li&gt;使用Class类的forName()静态方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-集合</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E9%9B%86%E5%90%88/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-集合/</id>
    <published>2018-04-09T13:43:16.000Z</published>
    <updated>2018-06-01T07:17:54.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-集合遍历"><a href="#1-集合遍历" class="headerlink" title="1 集合遍历"></a>1 集合遍历</h2><h3 id="1-1-迭代器（实现-Iterator-接口的实例）"><a href="#1-1-迭代器（实现-Iterator-接口的实例）" class="headerlink" title="1.1 迭代器（实现 Iterator 接口的实例）"></a>1.1 迭代器（实现 Iterator<e> 接口的实例）</e></h3><ul><li>检查是否有尚未访问的元素。</li><li>访问集合中的下一个元素。</li><li>删除集合的最后访问元素。</li></ul><h3 id="1-2-for-each循环"><a href="#1-2-for-each循环" class="headerlink" title="1.2 for-each循环"></a>1.2 for-each循环</h3><ul><li>for-each循环遍历任何实现类实现Iterable接口的集合。</li></ul><p><code>ps:</code>不能使用for-each循环从集合中删除元素，将抛出ConcurrentModificationException异常。</p><h3 id="1-3-forEach-方法"><a href="#1-3-forEach-方法" class="headerlink" title="1.3 forEach()方法"></a>1.3 forEach()方法</h3><ul><li>Iterable接口包含一个新的 forEach(Consumer action)方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a list of strings</span></span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">"A"</span>);</span><br><span class="line">    names.add(<span class="string">"B"</span>);</span><br><span class="line">    names.add(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">    names.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-集合（Set接口）（唯一对象的集合）"><a href="#2-集合（Set接口）（唯一对象的集合）" class="headerlink" title="2 集合（Set接口）（唯一对象的集合）"></a>2 集合（Set接口）（唯一对象的集合）</h3><ul><li>集合是唯一元素的集合。当向集合添加重复元素时，它们将被忽略。</li><li>Java最多允许一个Set中的一个空元素。 </li><li>Set 中元素的排序并不重要。Java不保证 Set 中元素的排序。</li></ul><h3 id="2-1-数学集"><a href="#2-1-数学集" class="headerlink" title="2.1 数学集"></a>2.1 数学集</h3><ul><li>HashSet 类：不保证顺序元素</li><li>LinkedHashSet 类：保证插入元素顺序</li></ul><h3 id="2-2-排序集"><a href="#2-2-排序集" class="headerlink" title="2.2 排序集"></a>2.2 排序集</h3><p>SortedSet 接口表示Java集合中的排序集合框架。</p><ul><li>元素实现Comparable接口，将使用compareTo()方法排序，称之为自然排序；</li><li>传递一个比较器自定义排序；</li><li>若指定Comparator，则用Comparator排序而忽略Comparable。</li><li>TreeSet是SortedSet接口的一个实现。</li></ul><h3 id="2-3-导航集（有序集）"><a href="#2-3-导航集（有序集）" class="headerlink" title="2.3 导航集（有序集）"></a>2.3 导航集（有序集）</h3><p>NavigableSet 表示Java集合中的可导航集合框架。NavigableSet 接口继承了SortedSet接口和扩展 SortedSet 。</p><ul><li>TreeSet 类是 NavigableSet 接口的实现类之一。</li></ul><h2 id="3-列表（List接口）（有序、可重复）"><a href="#3-列表（List接口）（有序、可重复）" class="headerlink" title="3 列表（List接口）（有序、可重复）"></a>3 列表（List接口）（有序、可重复）</h2><ul><li>ArrayList：访问快，添加删除慢</li><li>LinkedList：访问慢，添加删除快</li><li>LinkIterator接口（继承Iterator接口）遍历列表</li></ul><h2 id="4-队列（Queue接口）（先进先出FIFO）"><a href="#4-队列（Queue接口）（先进先出FIFO）" class="headerlink" title="4 队列（Queue接口）（先进先出FIFO）"></a>4 队列（Queue接口）（先进先出FIFO）</h2><ul><li>LinkedList：简单的队列允许在尾部插入和从头部移除。</li><li>PriorityQueue：优先级队列为每个元素分配优先级，并允许从队列中删除具有最高优先级的元素。</li><li>DelayQueue：延迟队列向每个元素添加延迟，并仅在其延迟已过去时删除该元素。</li><li>Deque、ArrayDeque、LinkedList（FIFO或LIFO）：双端队列允许其元件从头部和尾部插入和移除。</li><li>BlockingQueue接口（线程安全、适用于生产者/消费者）、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue：阻塞队列阻塞线程，当线程已满时向其添加元素，当线程为空时，它阻止线程从中删除元素。</li><li>TransferQueue：传输队列是阻塞队列，其中对象的切换发生在生产者线程和消费者线程之间。</li><li>阻塞双端队列是双端队列和阻塞队列的组合。</li></ul><h2 id="5-映射（Map-lt-K-V-gt-接口）-（键不能重复）"><a href="#5-映射（Map-lt-K-V-gt-接口）-（键不能重复）" class="headerlink" title="5 映射（Map&lt;K,V&gt;接口） （键不能重复）"></a>5 映射（Map&lt;K,V&gt;接口） （键不能重复）</h2><ul><li>HashMap</li><li>LinkedHashMap</li><li>WeakHashMap</li></ul><h2 id="6-Collection-类"><a href="#6-Collection-类" class="headerlink" title="6 Collection 类"></a>6 Collection 类</h2><p>该类中包含许多静态的辅助方法用于处理集合，如排序、搜索等。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-集合遍历&quot;&gt;&lt;a href=&quot;#1-集合遍历&quot; class=&quot;headerlink&quot; title=&quot;1 集合遍历&quot;&gt;&lt;/a&gt;1 集合遍历&lt;/h2&gt;&lt;h3 id=&quot;1-1-迭代器（实现-Iterator-接口的实例）&quot;&gt;&lt;a href=&quot;#1-1-迭代器（实现-Iterator-接口的实例）&quot; class=&quot;headerlink&quot; title=&quot;1.1 迭代器（实现 Iterator 接口的实例）&quot;&gt;&lt;/a&gt;1.1 迭代器（实现 Iterator&lt;e&gt; 接口的实例）&lt;/e&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;检查是否有尚未访问的元素。&lt;/li&gt;
&lt;li&gt;访问集合中的下一个元素。&lt;/li&gt;
&lt;li&gt;删除集合的最后访问元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-for-each循环&quot;&gt;&lt;a href=&quot;#1-2-for-each循环&quot; class=&quot;headerlink&quot; title=&quot;1.2 for-each循环&quot;&gt;&lt;/a&gt;1.2 for-each循环&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;for-each循环遍历任何实现类实现Iterable接口的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ps:&lt;/code&gt;不能使用for-each循环从集合中删除元素，将抛出ConcurrentModificationException异常。&lt;/p&gt;
&lt;h3 id=&quot;1-3-forEach-方法&quot;&gt;&lt;a href=&quot;#1-3-forEach-方法&quot; class=&quot;headerlink&quot; title=&quot;1.3 forEach()方法&quot;&gt;&lt;/a&gt;1.3 forEach()方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Iterable接口包含一个新的 forEach(Consumer action)方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Create a list of strings&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;String&amp;gt; names = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    names.add(&lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    names.add(&lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    names.add(&lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    names.forEach(System.out::println);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java各版本新特性</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-各版本新特性/</id>
    <published>2018-04-01T14:45:48.000Z</published>
    <updated>2018-06-01T07:17:54.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java8-新特性（2014-3-18）"><a href="#1-Java8-新特性（2014-3-18）" class="headerlink" title="1 Java8 新特性（2014/3/18）"></a>1 Java8 新特性（2014/3/18）</h2><ul><li><p><strong>Lambda 表达式</strong> − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 java 7 排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortUsingJava7</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;   </span><br><span class="line">  Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 java 8 排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortUsingJava8</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;</span><br><span class="line">  Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p></li><li><p><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Vehicle vehicle = <span class="keyword">new</span> Car();</span><br><span class="line">      vehicle.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blowHorn</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"按喇叭!!!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FourWheeler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆四轮车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span>, <span class="title">FourWheeler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Vehicle.<span class="keyword">super</span>.print();</span><br><span class="line">      FourWheeler.<span class="keyword">super</span>.print();</span><br><span class="line">      Vehicle.blowHorn();</span><br><span class="line">      System.out.println(<span class="string">"我是一辆汽车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</p></li><li><p><strong>Stream API（链式编程）</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li><li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。  </li><li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream()</span><br><span class="line">                                .filter(string -&gt; !string.isEmpty())</span><br><span class="line">                                .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"筛选列表: "</span> + filtered);</span><br><span class="line">String mergedString = strings.stream()</span><br><span class="line">                              .filter(string -&gt; !string.isEmpty())</span><br><span class="line">                              .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Date Time API − 加强对日期与时间的处理。</p></li><li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li><li>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul><a id="more"></a><h1 id="2-Java9-新特性（）"><a href="#2-Java9-新特性（）" class="headerlink" title="2 Java9 新特性（）"></a>2 Java9 新特性（）</h1><h1 id="3-Java10-新特性（2018-3-20）"><a href="#3-Java10-新特性（2018-3-20）" class="headerlink" title="3 Java10 新特性（2018/3/20）"></a>3 Java10 新特性（2018/3/20）</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Java8-新特性（2014-3-18）&quot;&gt;&lt;a href=&quot;#1-Java8-新特性（2014-3-18）&quot; class=&quot;headerlink&quot; title=&quot;1 Java8 新特性（2014/3/18）&quot;&gt;&lt;/a&gt;1 Java8 新特性（2014/3/18）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Lambda 表达式&lt;/strong&gt; − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 java 7 排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sortUsingJava7&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;String&amp;gt; names)&lt;/span&gt;&lt;/span&gt;&amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Collections.sort(names, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Comparator&amp;lt;String&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String s1, String s2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s1.compareTo(s2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 java 8 排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sortUsingJava8&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;String&amp;gt; names)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Collections.sort(names, (s1, s2) -&amp;gt; s1.compareTo(s2));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;方法引用&lt;/strong&gt; − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;默认方法&lt;/strong&gt; − 默认方法就是一个在接口里面有了一个实现的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Java8Tester&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String args[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Vehicle vehicle = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Car();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      vehicle.print();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Vehicle&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;我是一辆车!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;blowHorn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;按喇叭!!!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FourWheeler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;我是一辆四轮车!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Vehicle&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;FourWheeler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Vehicle.&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.print();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      FourWheeler.&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.print();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Vehicle.blowHorn();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;我是一辆汽车!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Stream API（链式编程）&lt;/strong&gt; −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。&lt;/li&gt;
&lt;li&gt;数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。&lt;/li&gt;
&lt;li&gt;聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。  &lt;/li&gt;
&lt;li&gt;Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。&lt;/li&gt;
&lt;li&gt;内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt;strings = Arrays.asList(&lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bc&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;efg&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;abcd&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;jkl&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; filtered = strings.stream()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                .filter(string -&amp;gt; !string.isEmpty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                .collect(Collectors.toList());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;筛选列表: &quot;&lt;/span&gt; + filtered);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String mergedString = strings.stream()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              .filter(string -&amp;gt; !string.isEmpty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              .collect(Collectors.joining(&lt;span class=&quot;string&quot;&gt;&quot;, &quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;合并字符串: &quot;&lt;/span&gt; + mergedString);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Date Time API − 加强对日期与时间的处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。&lt;/li&gt;
&lt;li&gt;Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识02</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8602/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-基础知识02/</id>
    <published>2018-03-29T14:01:27.000Z</published>
    <updated>2018-06-01T07:17:54.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-枚举（Enumeration）"><a href="#1-1-枚举（Enumeration）" class="headerlink" title="1.1 枚举（Enumeration）"></a>1.1 枚举（Enumeration）</h3><p>定义了一种从数据结构中取回连续元素的方式，已被迭代器取代。</p><h3 id="1-2-位集合（BitSet）"><a href="#1-2-位集合（BitSet）" class="headerlink" title="1.2 位集合（BitSet）"></a>1.2 位集合（BitSet）</h3><p>实现了一组可以单独设置和清除的位或标志。该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</p><h3 id="1-3-向量（Vector）"><a href="#1-3-向量（Vector）" class="headerlink" title="1.3 向量（Vector）"></a>1.3 向量（Vector）</h3><ul><li>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。</li><li>和数组一样，Vector对象的元素也能通过索引访问。</li><li>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</li></ul><h3 id="1-4-栈（Stack）"><a href="#1-4-栈（Stack）" class="headerlink" title="1.4 栈（Stack）"></a>1.4 栈（Stack）</h3><p>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</p><h3 id="1-5-字典（Dictionary）（已过时，使用Map接口替代）"><a href="#1-5-字典（Dictionary）（已过时，使用Map接口替代）" class="headerlink" title="1.5 字典（Dictionary）（已过时，使用Map接口替代）"></a>1.5 字典（Dictionary）（已过时，使用Map接口替代）</h3><p>字典（Dictionary） 类是一个<strong>抽象类</strong>，它定义了键映射到值的数据结构。</p><h3 id="1-6-哈希表（Hashtable）"><a href="#1-6-哈希表（Hashtable）" class="headerlink" title="1.6 哈希表（Hashtable）"></a>1.6 哈希表（Hashtable）</h3><p>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。</p><h3 id="1-7-属性（Properties）"><a href="#1-7-属性（Properties）" class="headerlink" title="1.7 属性（Properties）"></a>1.7 属性（Properties）</h3><p>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</p><a id="more"></a><h2 id="2-集合框架"><a href="#2-集合框架" class="headerlink" title="2 集合框架"></a>2 <strong>集合框架</strong></h2><p>集合框架是一个用来代表和操纵集合的统一架构。</p><h3 id="2-1-设计目标"><a href="#2-1-设计目标" class="headerlink" title="2.1 设计目标"></a>2.1 设计目标</h3><ul><li>高性能,基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li><li>允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li><li>对一个集合的扩展和适应必须是简单的。</li></ul><h3 id="2-2-内容"><a href="#2-2-内容" class="headerlink" title="2.2 内容"></a>2.2 内容</h3><ul><li>接口：是代表集合的抽象数据类型。接口允许集合独立操纵其代表的细节。在面向对象的语言，接口通常形成一个层次。</li><li>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。</li><li>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul><h3 id="2-3-集合接口"><a href="#2-3-集合接口" class="headerlink" title="2.3 集合接口"></a>2.3 集合接口</h3><table><thead><tr><th>接口</th><th>描述</th></tr></thead><tbody><tr><td>Collection 接口</td><td>允许你使用一组对象，是Collection层次结构的根接口。</td></tr><tr><td>List 接口</td><td>继承于Collection和一个 List实例存储一个有序集合的元素。</td></tr><tr><td>Set</td><td>继承于 Collection，是一个不包含重复元素的集合。</td></tr><tr><td>SortedSet</td><td>继承于Set保存有序的集合。</td></tr><tr><td>Map</td><td>将唯一的键映射到值。</td></tr><tr><td>Map.Entry</td><td>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</td></tr><tr><td>SortedMap</td><td>继承于Map，使Key保持在升序排列。</td></tr><tr><td>Enumeration</td><td>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</td></tr></tbody></table><h3 id="2-4-集合类"><a href="#2-4-集合类" class="headerlink" title="2.4 集合类"></a>2.4 集合类</h3><table><thead><tr><th>类名</th><th>描述</th></tr></thead><tbody><tr><td>AbstractCollection</td><td>实现了大部分的集合接口。</td></tr><tr><td>AbstractList</td><td>继承于AbstractCollection 并且实现了大部分List接口。</td></tr><tr><td>AbstractSequentialList</td><td>继承于AbstractList，提供了对数据元素的链式访问而不是随机访问。</td></tr><tr><td>LinkedList</td><td>继承于 AbstractSequentialList，实现了一个链表。</td></tr><tr><td>ArrayList</td><td>通过继承AbstractList，实现动态数组。</td></tr><tr><td>AbstractSet</td><td>继承于AbstractCollection 并且实现了大部分Set接口。</td></tr><tr><td>HashSet</td><td>继承了AbstractSet，并且使用一个哈希表。</td></tr><tr><td>LinkedHashSet</td><td>具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。</td></tr><tr><td>TreeSet</td><td>继承于AbstractSet，使用元素的自然顺序对元素进行排序.</td></tr><tr><td>AbstractMap</td><td>实现了大部分的Map接口。</td></tr><tr><td>HashMap</td><td>继承了HashMap，并且使用一个哈希表。</td></tr><tr><td>TreeMap</td><td>继承了AbstractMap，并且使用一颗树。</td></tr><tr><td>WeakHashMap</td><td>继承AbstractMap类，使用弱密钥的哈希表。</td></tr><tr><td>LinkedHashMap</td><td>继承于HashMap，使用元素的自然顺序对元素进行排序.</td></tr><tr><td>IdentityHashMap</td><td>继承AbstractMap类，比较文档时使用引用相等。</td></tr></tbody></table><h2 id="3-序列化"><a href="#3-序列化" class="headerlink" title="3 序列化"></a>3 序列化</h2><ul><li>一个类的对象要想序列化成功，必须满足两个条件：<ul><li>该类必须实现 java.io.Serializable 对象。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的（transient ）。</li></ul></li><li><p>ObjectOutputStream（writeObject）—：序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></li><li><p>ObjectInputStream（readObject）：反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4 网络编程"></a>4 网络编程</h2><h3 id="4-1-网络协议（java-net）"><a href="#4-1-网络协议（java-net）" class="headerlink" title="4.1 网络协议（java.net）"></a>4.1 网络协议（java.net）</h3><ul><li>TCP： TCP是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称TCP / IP。</li><li>UDP:UDP是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。</li></ul><h3 id="4-2-Socket（java-net-Socket）"><a href="#4-2-Socket（java-net-Socket）" class="headerlink" title="4.2 Socket（java.net.Socket）"></a>4.2 Socket（java.net.Socket）</h3><p>主要使用ServerSocket和Socket类</p><ul><li><ol><li>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</li></ol></li><li><ol start="2"><li>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li></ol></li><li><ol start="3"><li>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</li></ol></li><li><ol start="4"><li>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</li></ol></li><li><ol start="5"><li>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</li></ol></li></ul><h2 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5 多线程"></a>5 多线程</h2><h3 id="5-1-线程的生命周期"><a href="#5-1-线程的生命周期" class="headerlink" title="5.1 线程的生命周期"></a>5.1 线程的生命周期</h3><p><img src="/images/posts/Java_Thread.jpg" alt="Thread"></p><ul><li>新建状态:使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</li><li>就绪状态:当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</li><li>运行状态:如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</li><li>阻塞状态:如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li></ul></li><li>死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</li></ul><h3 id="5-2-线程的优先级"><a href="#5-2-线程的优先级" class="headerlink" title="5.2 线程的优先级"></a>5.2 线程的优先级</h3><ul><li>线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</li><li>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</li></ul><h3 id="5-3-创建线程"><a href="#5-3-创建线程" class="headerlink" title="5.3 创建线程"></a>5.3 创建线程</h3><ul><li>通过实现 Runnable 接口；</li><li>通过继承 Thread 类本身；</li><li>通过 Callable 和 Future 创建线程。</li></ul><h2 id="6-文档注释"><a href="#6-文档注释" class="headerlink" title="6 文档注释"></a>6 文档注释</h2><h3 id="6-1-javadoc-标签"><a href="#6-1-javadoc-标签" class="headerlink" title="6.1 javadoc 标签"></a>6.1 javadoc 标签</h3><table><thead><tr><th>标签</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>@author</td><td>标识一个类的作者</td><td>@author description</td></tr><tr><td>@deprecated</td><td>指名一个过期的类或成员</td><td>@deprecated description</td></tr><tr><td>{@docRoot}</td><td>指明当前文档根目录的路径</td><td>Directory Path</td></tr><tr><td>@exception</td><td>标志一个类抛出的异常</td><td>@exception exception-name explanation</td></tr><tr><td>{@inheritDoc}</td><td>从直接父类继承的注释</td><td>Inherits a comment from the immediate surperclass.</td></tr><tr><td>{@link}</td><td>插入一个到另一个主题的链接</td><td>{@link name text}</td></tr><tr><td>{@linkplain}</td><td>插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td>Inserts an in-line link to another topic.</td></tr><tr><td>@param</td><td>说明一个方法的参数</td><td>@param parameter-name explanation</td></tr><tr><td>@return</td><td>说明返回值类型</td><td>@return explanation</td></tr><tr><td>@see</td><td>指定一个到另一个主题的链接</td><td>@see anchor</td></tr><tr><td>@serial</td><td>说明一个序列化属性</td><td>@serial description</td></tr><tr><td>@serialData</td><td>说明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td>@serialData description</td></tr><tr><td>@serialField</td><td>说明一个ObjectStreamField组件</td><td>@serialField name type description</td></tr><tr><td>@since</td><td>标记当引入一个特定的变化时</td><td>@since release</td></tr><tr><td>@throws</td><td>和 @exception标签一样.</td><td>The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td>{@value}</td><td>显示常量的值，该常量必须是static属性。</td><td>Displays the value of a constant, which must be a static field.</td></tr><tr><td>@version</td><td>指定类的版本</td><td>@version info</td></tr></tbody></table><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人不明了之处，故可能忽略许多知识点，如有需要，请自行查找相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-数据结构&quot;&gt;&lt;a href=&quot;#1-数据结构&quot; class=&quot;headerlink&quot; title=&quot;1 数据结构&quot;&gt;&lt;/a&gt;1 数据结构&lt;/h2&gt;&lt;h3 id=&quot;1-1-枚举（Enumeration）&quot;&gt;&lt;a href=&quot;#1-1-枚举（Enumeration）&quot; class=&quot;headerlink&quot; title=&quot;1.1 枚举（Enumeration）&quot;&gt;&lt;/a&gt;1.1 枚举（Enumeration）&lt;/h3&gt;&lt;p&gt;定义了一种从数据结构中取回连续元素的方式，已被迭代器取代。&lt;/p&gt;
&lt;h3 id=&quot;1-2-位集合（BitSet）&quot;&gt;&lt;a href=&quot;#1-2-位集合（BitSet）&quot; class=&quot;headerlink&quot; title=&quot;1.2 位集合（BitSet）&quot;&gt;&lt;/a&gt;1.2 位集合（BitSet）&lt;/h3&gt;&lt;p&gt;实现了一组可以单独设置和清除的位或标志。该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。&lt;/p&gt;
&lt;h3 id=&quot;1-3-向量（Vector）&quot;&gt;&lt;a href=&quot;#1-3-向量（Vector）&quot; class=&quot;headerlink&quot; title=&quot;1.3 向量（Vector）&quot;&gt;&lt;/a&gt;1.3 向量（Vector）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。&lt;/li&gt;
&lt;li&gt;和数组一样，Vector对象的元素也能通过索引访问。&lt;/li&gt;
&lt;li&gt;使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-4-栈（Stack）&quot;&gt;&lt;a href=&quot;#1-4-栈（Stack）&quot; class=&quot;headerlink&quot; title=&quot;1.4 栈（Stack）&quot;&gt;&lt;/a&gt;1.4 栈（Stack）&lt;/h3&gt;&lt;p&gt;栈（Stack）实现了一个后进先出（LIFO）的数据结构。&lt;/p&gt;
&lt;h3 id=&quot;1-5-字典（Dictionary）（已过时，使用Map接口替代）&quot;&gt;&lt;a href=&quot;#1-5-字典（Dictionary）（已过时，使用Map接口替代）&quot; class=&quot;headerlink&quot; title=&quot;1.5 字典（Dictionary）（已过时，使用Map接口替代）&quot;&gt;&lt;/a&gt;1.5 字典（Dictionary）（已过时，使用Map接口替代）&lt;/h3&gt;&lt;p&gt;字典（Dictionary） 类是一个&lt;strong&gt;抽象类&lt;/strong&gt;，它定义了键映射到值的数据结构。&lt;/p&gt;
&lt;h3 id=&quot;1-6-哈希表（Hashtable）&quot;&gt;&lt;a href=&quot;#1-6-哈希表（Hashtable）&quot; class=&quot;headerlink&quot; title=&quot;1.6 哈希表（Hashtable）&quot;&gt;&lt;/a&gt;1.6 哈希表（Hashtable）&lt;/h3&gt;&lt;p&gt;Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。&lt;/p&gt;
&lt;h3 id=&quot;1-7-属性（Properties）&quot;&gt;&lt;a href=&quot;#1-7-属性（Properties）&quot; class=&quot;headerlink&quot; title=&quot;1.7 属性（Properties）&quot;&gt;&lt;/a&gt;1.7 属性（Properties）&lt;/h3&gt;&lt;p&gt;Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。&lt;/p&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java环境变量配置</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-环境变量配置/</id>
    <published>2018-03-25T14:42:39.000Z</published>
    <updated>2018-06-01T07:17:54.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java下载"><a href="#1-Java下载" class="headerlink" title="1 Java下载"></a>1 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Java下载</a></h2><h2 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2 环境变量配置"></a>2 环境变量配置</h2><ol><li><strong>JAVA_HOME</strong>:C:\Program Files\Java\jdk1.8.0_144（注：结尾不加分号）</li><li><strong>PATH</strong>:%JAVA_HOME%\bin;</li><li><strong>CLASS_PATH</strong>:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</li></ol><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h2><ul><li><strong>java-version</strong>:版本号</li><li><strong>java</strong>:Java环境</li><li><strong>javac</strong>:Java编译器</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Java下载&quot;&gt;&lt;a href=&quot;#1-Java下载&quot; class=&quot;headerlink&quot; title=&quot;1 Java下载&quot;&gt;&lt;/a&gt;1 &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java下载&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;2-环境变量配置&quot;&gt;&lt;a href=&quot;#2-环境变量配置&quot; class=&quot;headerlink&quot; title=&quot;2 环境变量配置&quot;&gt;&lt;/a&gt;2 环境变量配置&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JAVA_HOME&lt;/strong&gt;:C:\Program Files\Java\jdk1.8.0_144（注：结尾不加分号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PATH&lt;/strong&gt;:%JAVA_HOME%\bin;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLASS_PATH&lt;/strong&gt;:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;3-测试&quot;&gt;&lt;a href=&quot;#3-测试&quot; class=&quot;headerlink&quot; title=&quot;3 测试&quot;&gt;&lt;/a&gt;3 测试&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;java-version&lt;/strong&gt;:版本号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;java&lt;/strong&gt;:Java环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;javac&lt;/strong&gt;:Java编译器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
</feed>
