<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>祥_venux</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.venux.cn/"/>
  <updated>2018-10-23T02:21:27.496Z</updated>
  <id>http://www.venux.cn/</id>
  
  <author>
    <name>祥_venux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>02.DI</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/01.DotNetCore/02.DI/"/>
    <id>http://www.venux.cn//posts/01.编程语言/01.CSharp/01.DotNetCore/02.DI/</id>
    <published>2018-10-22T14:48:07.000Z</published>
    <updated>2018-10-23T02:21:27.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>ASP.NET Core 支持依赖关系注入 (DI) 软件设计模式，这是一种在类及其依赖关系之间实现控制反转 (IoC) 的技术。</p><a id="more"></a><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2.概述"></a>2.概述</h2><p>依赖项是指一个对象所需的其他任何对象。</p><h3 id="2-1-直接-new-的缺点"><a href="#2-1-直接-new-的缺点" class="headerlink" title="2.1 直接 new 的缺点"></a>2.1 直接 new 的缺点</h3><ul><li>若使用不同的实现替换，必须修改类，违背了开闭原则；</li><li>层级依赖的时候，每层单独管理依赖。且依赖过多时，相关配置代码分散，不利于维护；</li><li>难于单元测试。</li></ul><h3 id="2-2-使用-DI-的优点"><a href="#2-2-使用-DI-的优点" class="headerlink" title="2.2 使用 DI 的优点"></a>2.2 使用 DI 的优点</h3><ul><li>使用接口抽象化依赖关系实现；</li><li>服务容器统一管理依赖关系；</li><li>服务注入到类的构造函数，框架负责创建依赖关系的实例，且维护生命周期。</li></ul><h2 id="3-框架提供的服务"><a href="#3-框架提供的服务" class="headerlink" title="3.框架提供的服务"></a>3.框架提供的服务</h2><table><thead><tr><th>服务类型</th><th style="text-align:center">生存期</th></tr></thead><tbody><tr><td>Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory</td><td style="text-align:center">暂时</td></tr><tr><td>Microsoft.AspNetCore.Hosting.IApplicationLifetime</td><td style="text-align:center">单例</td></tr><tr><td>Microsoft.AspNetCore.Hosting.IHostingEnvironment</td><td style="text-align:center">单例</td></tr><tr><td>Microsoft.AspNetCore.Hosting.IStartup</td><td style="text-align:center">单例</td></tr><tr><td>Microsoft.AspNetCore.Hosting.IStartupFilter</td><td style="text-align:center">暂时</td></tr><tr><td>Microsoft.AspNetCore.Hosting.Server.IServer</td><td style="text-align:center">单例</td></tr><tr><td>Microsoft.AspNetCore.Http.IHttpContextFactory</td><td style="text-align:center">暂时</td></tr><tr><td>Microsoft.Extensions.Logging.ILogger<t></t></td><td style="text-align:center">单例</td></tr><tr><td>Microsoft.Extensions.Logging.ILoggerFactory</td><td style="text-align:center">单例</td></tr><tr><td>Microsoft.Extensions.ObjectPool.ObjectPoolProvider</td><td style="text-align:center">单例</td></tr><tr><td>Microsoft.Extensions.Options.IConfigureOptions<t></t></td><td style="text-align:center">暂时</td></tr><tr><td>Microsoft.Extensions.Options.IOptions<t></t></td><td style="text-align:center">单例</td></tr><tr><td>System.Diagnostics.DiagnosticSource</td><td style="text-align:center">单例</td></tr><tr><td>System.Diagnostics.DiagnosticListener</td><td style="text-align:center">单例</td></tr></tbody></table><h2 id="4-服务生命周期"><a href="#4-服务生命周期" class="headerlink" title="4.服务生命周期"></a>4.服务生命周期</h2><ul><li>Transient（暂时）：每次请求该服务时创建（Transient lifetime services are created each time they’re requested），适用于轻量级、无状态的服务；</li><li>Scoped（作用域）：每次请求创建（Scoped lifetime services are created once per request）；<ul><li>DbContext</li></ul></li></ul><p><strong>警告</strong>：在中间件内使用有作用域的服务时，请将该服务注入至 Invoke 或 InvokeAsync 方法。 请不要通过构造函数注入进行注入，因为它会强制服务的行为与单一实例类似。</p><ul><li>Singleton（单例）：第一次请求（或在运行 ConfigureServices 且使用服务注册指定实例）时创建，后续请求都使用相同的实例。<br><strong>警告</strong>：从单一实例解析有作用域的服务很危险。 当处理后续请求时，它可能会导致服务处于不正确的状态。</li></ul><h2 id="5-设计服务最佳做法"><a href="#5-设计服务最佳做法" class="headerlink" title="5.设计服务最佳做法"></a>5.设计服务最佳做法</h2><ul><li>使用依赖注入来获取依赖关系；</li><li>避免有状态的静态方法调用（<a href="https://deviq.com/static-cling/" target="_blank" rel="noopener">静态粘附</a>）；</li><li>避免在服务中直接实例化依赖类；</li><li><a href="https://deviq.com/solid/" target="_blank" rel="noopener">SOLID</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#separation-of-concerns" target="_blank" rel="noopener">关注点分离</a></li></ul><h2 id="6-服务处理"><a href="#6-服务处理" class="headerlink" title="6.服务处理"></a>6.服务处理</h2><p>容器会自动为实现 IDisposable 的类型调用 Dispose 方法，若通过实例添加到容器，则不会自动处理。</p><h2 id="7-默认服务容器替换"><a href="#7-默认服务容器替换" class="headerlink" title="7.默认服务容器替换"></a>7.默认服务容器替换</h2><p>建议使用内置容器，除非需要不支持的功能，具体如下：</p><ul><li>属性注入；</li><li>基于名称的注入；</li><li>子容器；</li><li>自定义生命周期管理；</li><li>延迟初始化 Func<t>。</t></li></ul><h3 id="7-1-Autofac"><a href="#7-1-Autofac" class="headerlink" title="7.1 Autofac"></a>7.1 Autofac</h3><p>i. 安装 nuget 包：<code>Autofac</code>,<code>Autofac.Extensions.DependencyInjection</code>；<br>ii. 配置容器，并返回 <code>IServiceProvider</code>。要使用第三方容器，Startup.ConfigureServices 必须返回 <code>IServiceProvider</code>；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public IServiceProvider ConfigureServices(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    services.AddMvc();</span><br><span class="line">    // Add other framework services</span><br><span class="line"></span><br><span class="line">    // Add Autofac</span><br><span class="line">    var containerBuilder = new ContainerBuilder();</span><br><span class="line">    containerBuilder.RegisterModule&lt;DefaultModule&gt;();</span><br><span class="line">    containerBuilder.Populate(services);</span><br><span class="line">    var container = containerBuilder.Build();</span><br><span class="line">    return new AutofacServiceProvider(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>iii. 在 DefaultModule 配置 Autofac<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultModule : Module</span><br><span class="line">&#123;</span><br><span class="line">    protected override void Load(ContainerBuilder builder)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.RegisterType&lt;CharacterRepository&gt;().As&lt;ICharacterRepository&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="8-建议"><a href="#8-建议" class="headerlink" title="8.建议"></a>8.建议</h2><ul><li>避免在服务容器中直接存储数据和配置，配置应选用 <code>Options Pattern</code>；</li><li>避免静态访问服务（例如 IApplicationBuilder.ApplicationServices）；</li><li>避免使用服务定位器模式（例如 IServiceProvider.GetService）；</li><li>避免静态访问 <code>HttpContext</code>（例如 IHttpContextAccessor.HttpContext）。</li></ul><p><code>PS</code>：依赖注入是静态/全局对象访问模式的替代方法，若混合使用，则无法实现其优点。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.1" target="_blank" rel="noopener">依赖注入</a><br>2 <a href="https://www.martinfowler.com/articles/injection.html" target="_blank" rel="noopener">控制反转及依赖注入模式-Martin fowler</a><br>3 <a href="https://docs.autofac.org/en/latest/integration/aspnetcore.html" target="_blank" rel="noopener">Autofac文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a&gt;1.介绍&lt;/h2&gt;&lt;p&gt;ASP.NET Core 支持依赖关系注入 (DI) 软件设计模式，这是一种在类及其依赖关系之间实现控制反转 (IoC) 的技术。&lt;/p&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="01.CSharp" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-CSharp/"/>
    
      <category term="01.DotNetCore" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-CSharp/01-DotNetCore/"/>
    
    
      <category term="ASP.NET Core" scheme="http://www.venux.cn/tags/ASP-NET-Core/"/>
    
  </entry>
  
  <entry>
    <title>XmlSerializer问题汇总</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/XmlSerializer%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://www.venux.cn//posts/01.编程语言/01.CSharp/XmlSerializer问题汇总/</id>
    <published>2018-09-06T10:06:26.000Z</published>
    <updated>2018-10-23T02:21:27.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-字符串编码问题"><a href="#1-字符串编码问题" class="headerlink" title="1. 字符串编码问题"></a>1. 字符串编码问题</h2><p>问题描述：使用 StringWriter 进行 XML 序列化时，生成的 XML 编码为 UTF-16，需改为 UTF-8。<br>解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Utf8StringWriter : StringWriter</span><br><span class="line">&#123;</span><br><span class="line">    public override Encoding Encoding =&gt; Encoding.UTF8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/1564718/using-stringwriter-for-xml-serialization" target="_blank" rel="noopener">using-stringwriter-for-xml-serialization</a></li></ul><h2 id="2-null-不序列化问题"><a href="#2-null-不序列化问题" class="headerlink" title="2. null 不序列化问题"></a>2. null 不序列化问题</h2><p>问题描述：部分属性值为 null，序列化成 XML 时，不生成相应的属性 XML。<br>解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Utf8StringWriter : StringWriter</span><br><span class="line">&#123;</span><br><span class="line">    public override Encoding Encoding =&gt; Encoding.UTF8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/1296468/suppress-null-value-types-from-being-emitted-by-xmlserializer" target="_blank" rel="noopener">Suppress Null Value Types from Being Emitted by XmlSerializer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-字符串编码问题&quot;&gt;&lt;a href=&quot;#1-字符串编码问题&quot; class=&quot;headerlink&quot; title=&quot;1. 字符串编码问题&quot;&gt;&lt;/a&gt;1. 字符串编码问题&lt;/h2&gt;&lt;p&gt;问题描述：使用 StringWriter 进行 XML 序列化时，生成的 XML
      
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="01.CSharp" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-CSharp/"/>
    
    
      <category term="C#" scheme="http://www.venux.cn/tags/C/"/>
    
      <category term="疑难杂症" scheme="http://www.venux.cn/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
  </entry>
  
  <entry>
    <title>CSharp-各个版本改动</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E6%94%B9%E5%8A%A8/"/>
    <id>http://www.venux.cn//posts/01.编程语言/01.CSharp/CSharp-各个版本改动/</id>
    <published>2018-09-03T14:06:26.000Z</published>
    <updated>2018-10-23T02:21:27.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/" target="_blank" rel="noopener">C# 各版本总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/&quot; ta
      
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="01.CSharp" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-CSharp/"/>
    
    
      <category term="C#" scheme="http://www.venux.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Oracle级联更新</title>
    <link href="http://www.venux.cn//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E7%BA%A7%E8%81%94%E6%9B%B4%E6%96%B0/"/>
    <id>http://www.venux.cn//posts/02.数据库/03.Oracle/Oracle级联更新/</id>
    <published>2018-07-23T08:57:27.000Z</published>
    <updated>2018-10-09T08:43:20.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>Oracle本身是不支持外键的级联更新操作，需将外键设为延迟约束后，再通过触发器实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://www.2cto.com/database/201507/417496.html" target="_blank" rel="noopener">Oracle外键级联删除和级联更新</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;Oracle本身是不支持外键的级联更新操作，需将外键设为延迟约束后，再通过触发器实现。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;
      
    
    </summary>
    
      <category term="02.数据库" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="03.Oracle" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/03-Oracle/"/>
    
    
      <category term="Oracle" scheme="http://www.venux.cn/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle官方文档</title>
    <link href="http://www.venux.cn//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    <id>http://www.venux.cn//posts/02.数据库/03.Oracle/Oracle官方文档/</id>
    <published>2018-07-20T08:57:27.000Z</published>
    <updated>2018-10-09T08:43:20.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><p><a href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/toc.htm" target="_blank" rel="noopener">Database SQL Language Reference</a></p><h2 id="2-Null"><a href="#2-Null" class="headerlink" title="2. Null"></a>2. Null</h2><p><a href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements005.htm#SQLRF30037" target="_blank" rel="noopener">Nulls</a></p><h2 id="3-ROWNUM"><a href="#3-ROWNUM" class="headerlink" title="3. ROWNUM"></a>3. ROWNUM</h2><p><a href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/pseudocolumns009.htm#SQLRF00255" target="_blank" rel="noopener">ROWNUM Pseudocolumn（虚列）</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1. 目录&quot;&gt;&lt;/a&gt;1. 目录&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E11882_01/server.112/e41
      
    
    </summary>
    
      <category term="02.数据库" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="03.Oracle" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/03-Oracle/"/>
    
    
      <category term="Oracle" scheme="http://www.venux.cn/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle表名列名长度限制</title>
    <link href="http://www.venux.cn//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E8%A1%A8%E5%90%8D%E5%88%97%E5%90%8D%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/"/>
    <id>http://www.venux.cn//posts/02.数据库/03.Oracle/Oracle表名列名长度限制/</id>
    <published>2018-07-19T08:57:27.000Z</published>
    <updated>2018-10-09T08:43:20.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://blog.csdn.net/haiross/article/details/38379615" target="_blank" rel="noopener">oracle的表名、字段名、constraint名的长度限制分别是多少？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;1 &lt;a href=&quot;https://blog.csdn.net/haiross/article/details/38379615&quot; tar
      
    
    </summary>
    
      <category term="02.数据库" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="03.Oracle" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/03-Oracle/"/>
    
    
      <category term="Oracle" scheme="http://www.venux.cn/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>SQL比较</title>
    <link href="http://www.venux.cn//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E6%AF%94%E8%BE%83/"/>
    <id>http://www.venux.cn//posts/02.数据库/SQL比较/</id>
    <published>2018-07-17T05:31:10.000Z</published>
    <updated>2018-10-09T08:43:19.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各类区别"><a href="#各类区别" class="headerlink" title="各类区别"></a>各类区别</h2><table><thead><tr><th>问题</th><th>SQL Server</th><th>Oracle</th><th>MySQL</th></tr></thead><tbody><tr><td>指定条数</td><td>TOP</td><td>ROWNUM</td><td>LIMIT</td></tr><tr><td>排序（ASC）</td><td>null最小</td><td>null最大</td><td>-</td></tr></tbody></table><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://sqlwithmanoj.com/2015/05/03/what-is-sql-plsql-t-sql-and-difference-between-them/" target="_blank" rel="noopener">What is SQL, PL/SQL, T-SQL and difference between them</a></li><li><a href="https://stackoverflow.com/questions/1043265/what-is-the-difference-between-sql-pl-sql-and-t-sql" target="_blank" rel="noopener">What is the difference between SQL, PL-SQL and T-SQL?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;各类区别&quot;&gt;&lt;a href=&quot;#各类区别&quot; class=&quot;headerlink&quot; title=&quot;各类区别&quot;&gt;&lt;/a&gt;各类区别&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;th&gt;SQL Server&lt;/th&gt;
&lt;th&gt;Oracle&lt;/
      
    
    </summary>
    
      <category term="02.数据库" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL Server" scheme="http://www.venux.cn/tags/SQL-Server/"/>
    
      <category term="Oracle" scheme="http://www.venux.cn/tags/Oracle/"/>
    
      <category term="MySQL" scheme="http://www.venux.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Oracle字符集</title>
    <link href="http://www.venux.cn//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    <id>http://www.venux.cn//posts/02.数据库/03.Oracle/Oracle字符集/</id>
    <published>2018-07-12T08:57:27.000Z</published>
    <updated>2018-10-09T08:43:20.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://blog.csdn.net/meunsina/article/details/53954215" target="_blank" rel="noopener">彻底搞懂Oracle字符集</a><br>2 <a href="https://blog.csdn.net/wstoneh01/article/details/50588720" target="_blank" rel="noopener">正确设置与使用SQL Server的字符集（Collation，即排序规则）</a><br>3 <a href="https://blog.csdn.net/luofujiang/article/details/9030819" target="_blank" rel="noopener">ORA-12704:字符集不匹配错误</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;1 &lt;a href=&quot;https://blog.csdn.net/meunsina/article/details/53954215&quot; ta
      
    
    </summary>
    
      <category term="02.数据库" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="03.Oracle" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/03-Oracle/"/>
    
    
      <category term="Oracle" scheme="http://www.venux.cn/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle服务名</title>
    <link href="http://www.venux.cn//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%90%8D/"/>
    <id>http://www.venux.cn//posts/02.数据库/03.Oracle/Oracle服务名/</id>
    <published>2018-07-12T08:57:27.000Z</published>
    <updated>2018-10-09T08:43:20.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>TNS serviceNAME</p><ul><li>格式1：<strong>IP地址:端口号/实例名</strong>，实例192.168.10.5：1521/ORCL；</li><li>格式2：<strong>服务名</strong>，在TNSNAMES.ORA文件配置；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://blog.csdn.net/BlueCY/article/details/76164941" target="_blank" rel="noopener">Oracle ODBC 配置（不需安装oracle客户端）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;TNS serviceNAME&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;格式1：&lt;strong&gt;IP地址:端口号/实例名&lt;/stron
      
    
    </summary>
    
      <category term="02.数据库" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="03.Oracle" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/03-Oracle/"/>
    
    
      <category term="Oracle" scheme="http://www.venux.cn/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle ODBC配置</title>
    <link href="http://www.venux.cn//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Oracle/Oracle%20ODBC%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.venux.cn//posts/02.数据库/03.Oracle/Oracle ODBC配置/</id>
    <published>2018-07-12T08:57:27.000Z</published>
    <updated>2018-10-09T08:43:20.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://blog.csdn.net/BlueCY/article/details/76164941" target="_blank" rel="noopener">Oracle ODBC 配置（不需安装oracle客户端）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;1 &lt;a href=&quot;https://blog.csdn.net/BlueCY/article/details/76164941&quot; targ
      
    
    </summary>
    
      <category term="02.数据库" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="03.Oracle" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/03-Oracle/"/>
    
    
      <category term="Oracle" scheme="http://www.venux.cn/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>SQLServer转Oracle</title>
    <link href="http://www.venux.cn//posts/02.%E6%95%B0%E6%8D%AE%E5%BA%93/SQLServer%E8%BD%ACOracle/"/>
    <id>http://www.venux.cn//posts/02.数据库/SQLServer转Oracle/</id>
    <published>2018-07-12T05:31:10.000Z</published>
    <updated>2018-10-09T08:43:19.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-情景"><a href="#1-情景" class="headerlink" title="1. 情景"></a>1. 情景</h2><p>公司项目的新客户数据库为 Oracle，故需将项目的 SQL Server 库转换为 Oracle 库。</p><h2 id="2-工具"><a href="#2-工具" class="headerlink" title="2. 工具"></a>2. 工具</h2><ul><li>SQL Server 自带的 bcm（注意：需将 SQL Server 安装目录下对应版本的 Tools\Binn 目录，如<code>C:\Program Files\Microsoft SQL Server\100\Tools\Binn</code> 添加到环境变量 Path 中）；</li><li><a href="http://download.oracle.com/otn/java/sqldeveloper/sqldeveloper-17.2.0.188.1159-no-jre.zip" target="_blank" rel="noopener">SQL Developer 17.2</a>(注意：需安装配置 Java 8)；</li></ul><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br></pre></td><td class="code"><pre><span class="line">#region 私有方法</span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 合并多个空格</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;源SQL&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;目标SQL&lt;/returns&gt;</span><br><span class="line">  private string MergeSpace(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Regex replaceSpace = new Regex(@&quot;\s&#123;1,&#125;&quot;, RegexOptions.IgnoreCase);</span><br><span class="line">      string result = replaceSpace.Replace(sql, &quot; &quot;).Trim();</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 替换空字符串</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;源SQL&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;目标SQL&lt;/returns&gt;</span><br><span class="line">  /// &lt;remarks&gt;</span><br><span class="line">  /// https://www.cnblogs.com/memory4young/p/use-null-empty-space-in-oracle.html</span><br><span class="line">  /// 问题：Oracle中null和&apos;&apos;(中间没空格的空字符串)是一个意思，若字段设置为非空（not null），使用&apos;&apos;插入会报错。</span><br><span class="line">  /// 解决方案：使用&apos; &apos;（中间多一个空格）作为空字符串</span><br><span class="line">  /// &lt;/remarks&gt;</span><br><span class="line">  private string ReplaceEmptySpace(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result = new StringBuilder(sql).Replace(&quot;&apos;&apos;&quot;, &quot;&apos; &apos;&quot;).Replace(&quot;\&quot;\&quot;&quot;, &quot;\&quot; \&quot;&quot;).ToString();</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 处理bool值属性情况</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;SQL&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;SQL&lt;/returns&gt;</span><br><span class="line">  /// &lt;remarks&gt;由于Oracle的bool值类型存为number(1)，无法实现bool和number的自动转换，故使用手动转换。&lt;/remarks&gt;</span><br><span class="line">  private string HandlerBooleanValue(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (sql.IndexOf(&quot;True&quot;, StringComparison.OrdinalIgnoreCase) == -1 &amp;&amp; sql.IndexOf(&quot;False&quot;, StringComparison.OrdinalIgnoreCase) == -1)</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result = sql;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">        * 使用正则表达式的\b来区分单词边界，只匹配True、Fale，而不会匹配TrueName。</span><br><span class="line">        * https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2</span><br><span class="line">        */</span><br><span class="line">      result = Regex.Replace(result, @&quot;\bTrue\b&quot;, &quot;1&quot;, RegexOptions.IgnoreCase);</span><br><span class="line">      result = Regex.Replace(result, @&quot;\bFalse\b&quot;, &quot;0&quot;, RegexOptions.IgnoreCase);</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 处理SELECT语句中无FROM情况</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;源SQL&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;目标SQL&lt;/returns&gt;</span><br><span class="line">  /// &lt;remarks&gt;</span><br><span class="line">  /// 由于Oracle必须要有FROM语句，若无，需加上FROM DUAL子句。</span><br><span class="line">  /// 例子：</span><br><span class="line">  /// 原：SELECT &quot;TEST&quot;;</span><br><span class="line">  /// 目标：SELECT &quot;TEST&quot; FROM DUAL</span><br><span class="line">  /// &lt;/remarks&gt;</span><br><span class="line">  private string HandlerNotContainFromWhenSelect(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //不是SELECT语句或已有FROM则跳过</span><br><span class="line">      if (sql.IndexOf(&quot;SELECT&quot;, StringComparison.OrdinalIgnoreCase) == -1 || sql.IndexOf(&quot; FROM&quot;, StringComparison.OrdinalIgnoreCase) != -1)</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result = sql + &quot; FROM DUAL&quot;;</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 处理当前日期函数</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">  private string HandleDateOfNowFunction(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (sql.IndexOf(&quot;GETDATE&quot;, StringComparison.OrdinalIgnoreCase) == -1)</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line">      string sq1 = Regex.Replace(sql, @&quot;GETDATE\(\)&quot;, &quot;SYSDATE&quot;, RegexOptions.IgnoreCase);</span><br><span class="line"></span><br><span class="line">      return sq1;// Regex.Replace(sql, &quot;GETDATE()&quot;, &quot;SYSDATE&quot;, RegexOptions.IgnoreCase);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 处理日期，时间字符串</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">  /// &lt;remarks&gt;旧代码迁移过来&lt;/remarks&gt;</span><br><span class="line">  private string HandleDateString(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //不包括单引号和双引号，则表示无日期字符串，不处理</span><br><span class="line">      if (sql.IndexOf(&apos;\&apos;&apos;) == -1 &amp;&amp; sql.IndexOf(&apos;&quot;&apos;) == -1)</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line">      //只包含一个单引号或（和）一个双引号，则表示无日期字符串，不处理</span><br><span class="line">      if (sql.IndexOf(&apos;\&apos;&apos;) == sql.LastIndexOf(&apos;\&apos;&apos;) &amp;&amp; sql.IndexOf(&apos;&quot;&apos;) == sql.LastIndexOf(&apos;&quot;&apos;))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result = sql;</span><br><span class="line">      int startPos = 0;</span><br><span class="line"></span><br><span class="line">      for (int i = 0; i &lt; result.Length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          int pos = result.IndexOf(&apos;\&apos;&apos;, startPos);</span><br><span class="line"></span><br><span class="line">          if (pos == -1)</span><br><span class="line">          &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          bool isDateTime = false;</span><br><span class="line"></span><br><span class="line">          int pos2 = result.IndexOf(&apos;\&apos;&apos;, pos + 1);</span><br><span class="line">          if (pos2 == -1)</span><br><span class="line">          &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">          string temp = result.Substring(pos + 1, pos2 - pos - 1);</span><br><span class="line">          try</span><br><span class="line">          &#123;</span><br><span class="line">              string regularText = @&quot;^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;)&quot;;</span><br><span class="line">              isDateTime = System.Text.RegularExpressions.Regex.IsMatch(temp, regularText);</span><br><span class="line"></span><br><span class="line">              //特殊情况例如DateTime.Parse(&quot;3 333&quot;)也是可以通过的，所以要过滤</span><br><span class="line"></span><br><span class="line">              //DateTime dt;</span><br><span class="line">              //if (DateTime.TryParse(temp, out dt))</span><br><span class="line">              //&#123;</span><br><span class="line">              //    if (temp.IndexOf(&apos;-&apos;) &gt; 0 ||</span><br><span class="line">              //    temp.IndexOf(&apos;/&apos;) &gt; 0 || temp.IndexOf(&apos;\\&apos;) &gt; 0)</span><br><span class="line">              //    &#123;</span><br><span class="line">              //        isDateTime = true;</span><br><span class="line">              //    &#125;</span><br><span class="line">              //&#125;</span><br><span class="line">              //else</span><br><span class="line">              //    isDateTime = false;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          catch (Exception)</span><br><span class="line">          &#123;</span><br><span class="line">              isDateTime = false;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (isDateTime)</span><br><span class="line">          &#123;</span><br><span class="line">              result = result.Remove(pos, pos2 - pos + 1);</span><br><span class="line"></span><br><span class="line">              string strNewDt = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">              //根据“：”判断是否有毫秒（有3个“：”认为有毫秒）</span><br><span class="line">              if (temp.Split(new string[] &#123; &quot;:&quot; &#125;, StringSplitOptions.RemoveEmptyEntries).Length &gt; 3)</span><br><span class="line">              &#123;</span><br><span class="line">                  //temp = temp.Substring(0, temp.LastIndexOf(&quot;:&quot;));截断毫秒</span><br><span class="line">                  strNewDt = &quot;to_timestamp(&apos;&quot; + temp + &quot;&apos;,&apos;yyyy-mm-dd hh24:mi:ss:ff&apos;)&quot;;//转换为timestamp</span><br><span class="line">                  //注意：无论是截断方式合适转换为timestamp方式，最终存储到数据库后的数据都没有毫秒</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">              &#123;</span><br><span class="line">                  strNewDt = &quot;to_date(&apos;&quot; + temp + &quot;&apos;,&apos;yyyy-mm-dd hh24:mi:ss&apos;) &quot;;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              string strpre = result.Substring(0, pos);</span><br><span class="line">              string strpost = result.Substring(pos);</span><br><span class="line">              result = strpre + strNewDt + strpost;</span><br><span class="line"></span><br><span class="line">              startPos = pos + strNewDt.Length;</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">              startPos = pos2 + 1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private string ReplaceTop1(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (sql.IndexOf(&quot;SELECT &quot;, StringComparison.OrdinalIgnoreCase) == -1 || sql.IndexOf(&quot; TOP &quot;, StringComparison.OrdinalIgnoreCase) == -1)</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result = sql;</span><br><span class="line">      Dictionary&lt;string, string&gt; dict = new Dictionary&lt;string, string&gt;();</span><br><span class="line">      if (this.HasChildSelect(result))</span><br><span class="line">      &#123;</span><br><span class="line">          string childSql = this.GetChildSql(result);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private string ReplaceTop(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (sql.IndexOf(&quot;SELECT &quot;, StringComparison.OrdinalIgnoreCase) == -1 || sql.IndexOf(&quot; TOP &quot;, StringComparison.OrdinalIgnoreCase) == -1)</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result = sql;</span><br><span class="line">      Dictionary&lt;string, string&gt; dict = new Dictionary&lt;string, string&gt;();</span><br><span class="line">      while (this.HasChildSelect(result))</span><br><span class="line">      &#123;</span><br><span class="line">          string childSql = this.GetChildSql(result);</span><br><span class="line">          string guid = Guid.NewGuid().ToString();</span><br><span class="line">          dict.Add(guid, childSql);</span><br><span class="line"></span><br><span class="line">          result = result.Replace(childSql, guid);</span><br><span class="line">      &#125;</span><br><span class="line">      result = this.HandleTopSyntax(result);</span><br><span class="line"></span><br><span class="line">      if (dict.Count &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">          foreach (var di in dict)</span><br><span class="line">          &#123;</span><br><span class="line">              string newValue = ReplaceTop(di.Value);</span><br><span class="line">              result = result.Replace(di.Key, newValue);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 判断sql语句中是否存在子查询</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;要判断是否存在子查询的sql语句&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;存在子查询返回true，否则返回false&lt;/returns&gt;</span><br><span class="line">  private bool HasChildSelect(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      bool b = false;</span><br><span class="line">      if (!string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          string tmpSql = sql;</span><br><span class="line">          //此算法认为子查询都由“（）”括号括起来，如（select * from tableName）,注意可能会有Union方法不出现“（）”，此处未兼容</span><br><span class="line">          string[] ss = tmpSql.ToUpper().Split(new string[] &#123; &quot;SELECT&quot; &#125;, StringSplitOptions.RemoveEmptyEntries);</span><br><span class="line">          if (ss != null &amp;&amp; ss.Length &gt; 0)</span><br><span class="line">          &#123;</span><br><span class="line">              foreach (string s in ss)</span><br><span class="line">              &#123;</span><br><span class="line">                  if (s.Trim().EndsWith(&quot;(&quot;))</span><br><span class="line">                  &#123;</span><br><span class="line">                      b = true;</span><br><span class="line">                      break;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 获取子查询语句</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;原sql语句&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;子查询sql&lt;/returns&gt;</span><br><span class="line">  private string GetChildSql(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      string tmpSql = sql;</span><br><span class="line">      //此算法认为子查询都由“（）”括号括起来，如（select * from tableName）,注意可能会有Union方法不出现“（）”，此处未兼容</span><br><span class="line">      int startIndex = 0;//截取子查询的开始索引</span><br><span class="line">      int selectIndex = tmpSql.IndexOf(&quot;SELECT &quot;, 0, StringComparison.OrdinalIgnoreCase);</span><br><span class="line">      while (selectIndex != -1)</span><br><span class="line">      &#123;</span><br><span class="line">          startIndex += selectIndex;</span><br><span class="line">          if (tmpSql.Substring(0, selectIndex).Trim().EndsWith(&quot;(&quot;))</span><br><span class="line">          &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">          &#123;</span><br><span class="line">              tmpSql = tmpSql.Substring(selectIndex + 6);</span><br><span class="line">              selectIndex = tmpSql.IndexOf(&quot;SELECT &quot;, 0, StringComparison.OrdinalIgnoreCase);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      int endIndex = startIndex;//截取子查询的结束索引</span><br><span class="line">      int tmp = 0;//记录左括号数量</span><br><span class="line">      for (int i = startIndex; i &lt; tmpSql.Length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          if (tmpSql[i] == &apos;)&apos;)</span><br><span class="line">          &#123;</span><br><span class="line">              if (tmp == 0)</span><br><span class="line">              &#123;</span><br><span class="line">                  endIndex = i;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">              &#123;</span><br><span class="line">                  tmp--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (tmpSql[i] == &apos;(&apos;)</span><br><span class="line">          &#123;</span><br><span class="line">              tmp++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      tmpSql = tmpSql.Substring(startIndex, endIndex - startIndex);</span><br><span class="line">      return tmpSql;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ///处理TOP语法</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">  /// &lt;remarks&gt;旧代码迁移过来&lt;/remarks&gt;</span><br><span class="line">  private string HandleTopSyntax(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (sql.IndexOf(&quot;SELECT &quot;, StringComparison.OrdinalIgnoreCase) == -1 || sql.IndexOf(&quot; TOP &quot;, StringComparison.OrdinalIgnoreCase) == -1)</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result = sql;</span><br><span class="line"></span><br><span class="line">      //若有TOP，则前方需有SELECT，故从第六个字符开始搜索</span><br><span class="line">      int topIndex = sql.IndexOf(&quot; TOP &quot;, 6, StringComparison.OrdinalIgnoreCase);</span><br><span class="line"></span><br><span class="line">      sql = sql.Substring(topIndex + 4);</span><br><span class="line">      result = result.Substring(topIndex + 4);</span><br><span class="line"></span><br><span class="line">      sql = sql.Trim();</span><br><span class="line">      result = result.Trim();</span><br><span class="line"></span><br><span class="line">      //具体条数</span><br><span class="line">      string count = sql.Substring(0, sql.IndexOf(&apos; &apos;));</span><br><span class="line"></span><br><span class="line">      sql = sql.Substring(sql.IndexOf(&apos; &apos;));</span><br><span class="line">      result = result.Substring(result.IndexOf(&apos; &apos;));</span><br><span class="line"></span><br><span class="line">      result = &quot;SELECT &quot; + result;</span><br><span class="line">      int whereIndex = result.LastIndexOf(&quot;WHERE&quot;, StringComparison.OrdinalIgnoreCase);</span><br><span class="line">      if (whereIndex &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">          result = result.Insert(whereIndex + 5, &quot; ROWNUM&lt;= &quot; + count + &quot; AND &quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          int orderbyIndex = result.LastIndexOf(&quot;ORDER BY&quot;, StringComparison.OrdinalIgnoreCase);</span><br><span class="line">          if (orderbyIndex &gt; 0)</span><br><span class="line">          &#123;</span><br><span class="line">              //result = result.Insert(orderbyIndex, &quot; WHERE ROWNUM&lt;= &quot; + count);</span><br><span class="line">              //Oracle中先执行ORDER BY，后再外层执行条数选择</span><br><span class="line">              //result = &quot;SELECT * FROM (&quot; + result + &quot; ) WHERE ROWNUM &lt;= &quot; + count;</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">          &#123;</span><br><span class="line">              result = result + &quot; WHERE ROWNUM&lt;= &quot; + count;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// lfc改造后的方法，外层包Select后引起原原sql中存在select * 时报错</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">  /// &lt;remarks&gt;旧代码迁移过来&lt;/remarks&gt;</span><br><span class="line">  private string HandleTopSyntax_LFC(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (sql.IndexOf(&quot;SELECT &quot;, StringComparison.OrdinalIgnoreCase) == -1 || sql.IndexOf(&quot; TOP &quot;, StringComparison.OrdinalIgnoreCase) == -1)</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result = sql;</span><br><span class="line"></span><br><span class="line">      //若有TOP，则前方需有SELECT，故从第六个字符开始搜索</span><br><span class="line">      int topIndex = result.IndexOf(&quot; TOP &quot;, 6, StringComparison.OrdinalIgnoreCase);</span><br><span class="line"></span><br><span class="line">      //sql = sql.Substring(topIndex + 4);</span><br><span class="line">      result = result.Substring(topIndex + 4).Trim();</span><br><span class="line"></span><br><span class="line">      //sql = sql.Trim();</span><br><span class="line">      //result = result.Trim();</span><br><span class="line"></span><br><span class="line">      //获取Top值</span><br><span class="line">      string count = result.Substring(0, result.IndexOf(&apos; &apos;));</span><br><span class="line"></span><br><span class="line">      //sql = sql.Substring(sql.IndexOf(&apos; &apos;));</span><br><span class="line">      result = result.Substring(result.IndexOf(&apos; &apos;));//获取top N后的sql部分</span><br><span class="line"></span><br><span class="line">      result = &quot;SELECT * FROM (SELECT &quot; + result;</span><br><span class="line">      //int whereIndex = result.LastIndexOf(&quot;WHERE&quot;, StringComparison.OrdinalIgnoreCase);</span><br><span class="line">      //if (whereIndex &gt; 0)</span><br><span class="line">      //&#123;</span><br><span class="line">      //    //result = result.Insert(whereIndex + 5, &quot; ROWNUM&lt;= &quot; + count + &quot; AND &quot;);</span><br><span class="line">      //&#125;</span><br><span class="line">      //else</span><br><span class="line">      //&#123;</span><br><span class="line">      //    int orderbyIndex = result.LastIndexOf(&quot;ORDER BY&quot;, StringComparison.OrdinalIgnoreCase);</span><br><span class="line">      //    if (orderbyIndex &gt; 0)</span><br><span class="line">      //    &#123;</span><br><span class="line">      //        //result = result.Insert(orderbyIndex, &quot; WHERE ROWNUM&lt;= &quot; + count);</span><br><span class="line">      //        //Oracle中先执行ORDER BY，后再外层执行条数选择</span><br><span class="line">      //        result = &quot;SELECT * FROM (&quot; + result + &quot; ) WHERE ROWNUM &lt;= &quot; + count;</span><br><span class="line">      //    &#125;</span><br><span class="line">      //    else</span><br><span class="line">      //    &#123;</span><br><span class="line">      //        result = result + &quot; WHERE ROWNUM&lt;= &quot; + count;</span><br><span class="line">      //    &#125;</span><br><span class="line">      //&#125;</span><br><span class="line"></span><br><span class="line">      result = result + &quot;) WHERE ROWNUM&lt;= &quot; + count;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 处理Worklist</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">  /// &lt;remarks&gt;</span><br><span class="line">  /// 旧代码迁移过来</span><br><span class="line">  /// 备注：</span><br><span class="line">  /// 由于Oracle字段名最大长度为30个，而SQL Server的Recycle_Worklist和Worklist表中有字段名超出30个，故单独修改Oracle部分字段的字段名以兼容ORACLE。</span><br><span class="line">  /// 查询字段名大于30字符的SQL：</span><br><span class="line">  /// SELECT</span><br><span class="line">  ///     sysobjects.name AS TableName,</span><br><span class="line">  ///     syscolumns.name AS ColumnName,</span><br><span class="line">  ///     UPPER(syscolumns.name) AS OracleColumnName</span><br><span class="line">  /// FROM</span><br><span class="line">  ///     sysobjects</span><br><span class="line">  ///     LEFT JOIN syscolumns ON syscolumns.id= sysobjects.id </span><br><span class="line">  /// WHERE</span><br><span class="line">  ///     sysobjects.xtype= &apos;u&apos; </span><br><span class="line">  ///     AND len( syscolumns.name ) &gt; 30 </span><br><span class="line">  /// ORDER BY</span><br><span class="line">  ///     TableName ASC,</span><br><span class="line">  ///     ColumnName ASC;</span><br><span class="line">  /// &lt;/remarks&gt;</span><br><span class="line">  private string HandleWorkList(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (sql.IndexOf(&quot;Worklist&quot;, StringComparison.OrdinalIgnoreCase) == -1)</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result = sql;</span><br><span class="line"></span><br><span class="line">      result = Regex.Replace(result, &quot;ScheduledProcedureStepStartDate&quot;, &quot;SpsStartDate&quot;, RegexOptions.IgnoreCase);</span><br><span class="line">      result = Regex.Replace(result, &quot;ScheduledProcedureStepStartTime&quot;, &quot;SpsStartTime&quot;, RegexOptions.IgnoreCase);</span><br><span class="line">      result = Regex.Replace(result, &quot;ScheduledPerformingPhysiciansName&quot;, &quot;ScheduledPerfPhysiciansName&quot;, RegexOptions.IgnoreCase);</span><br><span class="line">      result = Regex.Replace(result, &quot;ScheduledPerformingPhysiciansChineseName&quot;, &quot;ScheduledPerfPhysiciansChName&quot;, RegexOptions.IgnoreCase);</span><br><span class="line">      result = Regex.Replace(result, &quot;ScheduledActionItemCodingSchemeDesignator&quot;, &quot;SpsItemDesignator&quot;, RegexOptions.IgnoreCase);</span><br><span class="line">      result = Regex.Replace(result, &quot;Confidentialityconstraintonpatientdata&quot;, &quot;ConfConstraintPatData&quot;, RegexOptions.IgnoreCase);</span><br><span class="line">      result = Regex.Replace(result, &quot;ScheduledProcedureStepDescription&quot;, &quot;SpsDescription&quot;, RegexOptions.IgnoreCase);</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 处理方括号</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;sql&quot;&gt;&lt;/param&gt;</span><br><span class="line">  /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">  /// &lt;remarks&gt;旧代码迁移过来&lt;/remarks&gt;</span><br><span class="line">  private string HandleSquareBracket(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      if (string.IsNullOrEmpty(sql))</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (sql.Contains(&quot;[&quot;) == false &amp;&amp; sql.Contains(&quot;]&quot;) == false)</span><br><span class="line">      &#123;</span><br><span class="line">          return sql;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result = sql;</span><br><span class="line"></span><br><span class="line">      result = result.Replace(&quot;[&quot;, string.Empty);</span><br><span class="line">      result = result.Replace(&quot;]&quot;, string.Empty);</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #region 旧代码</span><br><span class="line">  private string ConvertToOracleSyntax(string sql)</span><br><span class="line">  &#123;</span><br><span class="line">      string oracleSyntax = sql.Trim();</span><br><span class="line">      sql = sql.ToLower().Trim();</span><br><span class="line">      int startPos = 0;</span><br><span class="line"></span><br><span class="line">      #region SELECT TOP语法转换</span><br><span class="line">      if (sql.Substring(0, 6) == &quot;select&quot;)</span><br><span class="line">      &#123;</span><br><span class="line">          int topIndex = sql.IndexOf(&quot; top &quot;);</span><br><span class="line">          if (topIndex &gt;= 6 &amp;&amp; topIndex &lt; 10)</span><br><span class="line">          &#123;</span><br><span class="line">              sql = sql.Substring(topIndex + 4);</span><br><span class="line">              oracleSyntax = oracleSyntax.Substring(topIndex + 4);</span><br><span class="line"></span><br><span class="line">              sql = sql.Trim();</span><br><span class="line">              oracleSyntax = oracleSyntax.Trim();</span><br><span class="line"></span><br><span class="line">              string nstr = sql.Substring(0, sql.IndexOf(&apos; &apos;));</span><br><span class="line"></span><br><span class="line">              sql = sql.Substring(sql.IndexOf(&apos; &apos;));</span><br><span class="line">              oracleSyntax = oracleSyntax.Substring(oracleSyntax.IndexOf(&apos; &apos;));</span><br><span class="line"></span><br><span class="line">              oracleSyntax = &quot;select &quot; + oracleSyntax;</span><br><span class="line">              oracleSyntax = oracleSyntax.ToUpper();</span><br><span class="line">              int whereIndex = oracleSyntax.LastIndexOf(&quot;WHERE&quot;);</span><br><span class="line">              if (whereIndex &gt; 0)</span><br><span class="line">              &#123;</span><br><span class="line">                  oracleSyntax = oracleSyntax.Insert(whereIndex + 5, &quot; ROWNUM&lt;= &quot; + nstr + &quot; AND &quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">              &#123;</span><br><span class="line">                  int orderbyIndex = oracleSyntax.LastIndexOf(&quot;ORDER BY&quot;);</span><br><span class="line">                  if (orderbyIndex &gt; 0)</span><br><span class="line">                  &#123;</span><br><span class="line">                      oracleSyntax = oracleSyntax.Insert(orderbyIndex, &quot; WHERE ROWNUM&lt;= &quot; + nstr);</span><br><span class="line">                  &#125;</span><br><span class="line">                  else</span><br><span class="line">                  &#123;</span><br><span class="line">                      oracleSyntax = oracleSyntax + &quot; WHERE ROWNUM&lt;= &quot; + nstr;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              //oracleSyntax = &quot;select * from ( select &quot; + oracleSyntax + &quot; ) where rownum &lt;= &quot; + nstr;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      #endregion</span><br><span class="line"></span><br><span class="line">      #region 时间格式转换</span><br><span class="line">      //to_date</span><br><span class="line">      for (int i = 0; i &lt; oracleSyntax.Length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          int pos = oracleSyntax.IndexOf(&apos;\&apos;&apos;, startPos);</span><br><span class="line">          bool isDateTime = false;</span><br><span class="line">          if (pos &gt;= 0)</span><br><span class="line">          &#123;</span><br><span class="line">              int pos2 = oracleSyntax.IndexOf(&apos;\&apos;&apos;, pos + 1);</span><br><span class="line">              if (pos2 &gt; 0)</span><br><span class="line">              &#123;</span><br><span class="line">                  string temp = oracleSyntax.Substring(pos + 1, pos2 - pos - 1);</span><br><span class="line">                  try</span><br><span class="line">                  &#123;</span><br><span class="line">                      string regularText = @&quot;^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;)&quot;;</span><br><span class="line">                      isDateTime = System.Text.RegularExpressions.Regex.IsMatch(temp, regularText);</span><br><span class="line"></span><br><span class="line">                      //特殊情况例如DateTime.Parse(&quot;3 333&quot;)也是可以通过的，所以要过滤</span><br><span class="line"></span><br><span class="line">                      //DateTime dt;</span><br><span class="line">                      //if (DateTime.TryParse(temp, out dt))</span><br><span class="line">                      //&#123;</span><br><span class="line">                      //    if (temp.IndexOf(&apos;-&apos;) &gt; 0 ||</span><br><span class="line">                      //    temp.IndexOf(&apos;/&apos;) &gt; 0 || temp.IndexOf(&apos;\\&apos;) &gt; 0)</span><br><span class="line">                      //    &#123;</span><br><span class="line">                      //        isDateTime = true;</span><br><span class="line">                      //    &#125;</span><br><span class="line">                      //&#125;</span><br><span class="line">                      //else</span><br><span class="line">                      //    isDateTime = false;</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line">                  catch (Exception)</span><br><span class="line">                  &#123;</span><br><span class="line">                      isDateTime = false;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  if (isDateTime)</span><br><span class="line">                  &#123;</span><br><span class="line">                      oracleSyntax = oracleSyntax.Remove(pos, pos2 - pos + 1);</span><br><span class="line">                      string strNewDt = &quot;to_date(&apos;&quot; + temp + &quot;&apos;,&apos;yyyy-mm-dd hh24:mi:ss&apos;) &quot;;</span><br><span class="line"></span><br><span class="line">                      string strpre = oracleSyntax.Substring(0, pos);</span><br><span class="line">                      string strpost = oracleSyntax.Substring(pos);</span><br><span class="line">                      oracleSyntax = strpre + strNewDt + strpost;</span><br><span class="line"></span><br><span class="line">                      startPos = pos + strNewDt.Length;</span><br><span class="line">                  &#125;</span><br><span class="line">                  else</span><br><span class="line">                      startPos = pos2 + 1;</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">              &#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">          &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      #endregion</span><br><span class="line"></span><br><span class="line">      if (oracleSyntax.IndexOf(&quot; Worklist&quot;) &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">          oracleSyntax = oracleSyntax.Replace(&quot;ScheduledProcedureStepStartDate&quot;, &quot;SpsStartDate&quot;);</span><br><span class="line">          oracleSyntax = oracleSyntax.Replace(&quot;ScheduledProcedureStepStartTime&quot;, &quot;SpsStartTime&quot;);</span><br><span class="line">          oracleSyntax = oracleSyntax.Replace(&quot;ScheduledPerformingPhysiciansName&quot;, &quot;ScheduledPerfPhysiciansName&quot;);</span><br><span class="line">          oracleSyntax = oracleSyntax.Replace(&quot;ScheduledPerformingPhysiciansChineseName&quot;, &quot;ScheduledPerfPhysiciansChName&quot;);</span><br><span class="line">          oracleSyntax = oracleSyntax.Replace(&quot;ScheduledActionItemCodingSchemeDesignator&quot;, &quot;SpsItemDesignator&quot;);</span><br><span class="line">          oracleSyntax = oracleSyntax.Replace(&quot;Confidentialityconstraintonpatientdata&quot;, &quot;ConfConstraintPatData&quot;);</span><br><span class="line">          oracleSyntax = oracleSyntax.Replace(&quot;ScheduledProcedureStepDescription&quot;, &quot;SpsDescription&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      oracleSyntax = oracleSyntax.Replace(&quot;[&quot;, string.Empty);</span><br><span class="line">      oracleSyntax = oracleSyntax.Replace(&quot;]&quot;, string.Empty);</span><br><span class="line"></span><br><span class="line">      return oracleSyntax;</span><br><span class="line">  &#125;</span><br><span class="line">  #endregion</span><br><span class="line"></span><br><span class="line">  #endregion</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/db/hol08/sqldev_migration/mssqlserver/migrate_microsoft_sqlserver_otn.htm" target="_blank" rel="noopener">Migrating a Microsoft SQL Server Database to Oracle Database 11g</a></li><li><a href="https://blog.csdn.net/rootcn/article/details/8894130" target="_blank" rel="noopener">用 SQL Developer 3.2 将 SQL Server 2008 数据库离线迁移到 Oracle 11g</a></li><li><a href="https://www.cnblogs.com/benbenfishfish/p/8675075.html" target="_blank" rel="noopener">Oracle和sqlserver数据类型对应</a></li><li><a href="https://www.cnblogs.com/Jashinck/p/8652058.html" target="_blank" rel="noopener">Oracle 和SQL Server 中的SQL语句使用区别</a></li><li><a href="https://blog.csdn.net/leftfist/article/details/71133570" target="_blank" rel="noopener">sql server t-sql脚本转成oracle plsql</a></li><li><a href="https://www.cnblogs.com/memory4young/p/use-null-empty-space-in-oracle.html" target="_blank" rel="noopener">Oracle中的NULL、’’（空字符串）以及’_’（空格）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-情景&quot;&gt;&lt;a href=&quot;#1-情景&quot; class=&quot;headerlink&quot; title=&quot;1. 情景&quot;&gt;&lt;/a&gt;1. 情景&lt;/h2&gt;&lt;p&gt;公司项目的新客户数据库为 Oracle，故需将项目的 SQL Server 库转换为 Oracle 库。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="02.数据库" scheme="http://www.venux.cn/categories/02-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL Server" scheme="http://www.venux.cn/tags/SQL-Server/"/>
    
      <category term="Oracle" scheme="http://www.venux.cn/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>12.重构-总结</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/12.%E9%87%8D%E6%9E%84-%E6%80%BB%E7%BB%93/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/12.重构-总结/</id>
    <published>2018-06-14T11:06:26.000Z</published>
    <updated>2018-10-09T08:43:20.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>前面的篇幅只是一个介绍，一个起点，如果没有这些技术，就无法对程序进行改动。有了这些技术，你仍然做不到，但起码可以开始尝试。</p><ul><li>何时应该使用、何时不应该使用；</li><li>何时开始、何时停止；</li><li>何时前进、何时等待；</li></ul><a id="more"></a><h2 id="2-得道"><a href="#2-得道" class="headerlink" title="2. 得道"></a>2. 得道</h2><p>可以自信地停止重构。</p><h2 id="3-学习"><a href="#3-学习" class="headerlink" title="3. 学习"></a>3. 学习</h2><ul><li>随时挑选一个目标；</li><li>没把握就停下来；</li><li>学习原路返回；</li><li>二重奏（多人协作重构、结对编程）；</li></ul><h2 id="4-要点"><a href="#4-要点" class="headerlink" title="4. 要点"></a>4. 要点</h2><ul><li>若代码无法方便添加新特性，请先重构；</li><li>重构技术就是以微小的步伐修改程序；</li><li>傻瓜都能编写计算机可以理解的代码，而唯有能编写人类容易理解的代码才是优秀的程序员；</li><li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本；</li><li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构；</li><li>事不过三，三则重构；</li><li>不要过早发布接口（API），修改代码所有权政策，使得重构更顺畅；</li><li>过多注释情况，请先重构；</li><li>大家都认为会出错的地方，检测是否抛出了预期的异常；</li><li><strong>测试、测试、测试！！！</strong>：<ul><li>重构前，先检查是否有一套可靠的测试机制，且具备自我检验能力；</li><li>自动化测试；</li><li>频繁运行测试；</li><li>单元测试；</li><li>考虑可能的出错边界条件，多测试；</li></ul></li></ul><h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h2><ul><li>大规模的重构只会带来灾难；</li><li>沟通：团队朝着同一个方向一起努力；</li><li>永远不要忘记“两顶帽子”：保持代码的功能完全不变，既不多又不少。对于需要修改的问题，先记下来。重构结束无误后，再进行修改。</li><li><strong>千万别打乱工作。</strong></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第15章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1. 问题&quot;&gt;&lt;/a&gt;1. 问题&lt;/h2&gt;&lt;p&gt;前面的篇幅只是一个介绍，一个起点，如果没有这些技术，就无法对程序进行改动。有了这些技术，你仍然做不到，但起码可以开始尝试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何时应该使用、何时不应该使用；&lt;/li&gt;
&lt;li&gt;何时开始、何时停止；&lt;/li&gt;
&lt;li&gt;何时前进、何时等待；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Gradle</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Gradle/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Gradle/</id>
    <published>2018-06-10T14:05:19.000Z</published>
    <updated>2018-10-09T08:43:20.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>一个自动化构建工具，用于加速开发者生产率，特点：</p><ul><li>Build Anything;</li><li>Automate Everything;</li><li>Deliver Faster;</li></ul><a id="more"></a><h2 id="2-安装-amp-配置-amp-测试-amp-升级"><a href="#2-安装-amp-配置-amp-测试-amp-升级" class="headerlink" title="2. 安装 &amp; 配置 &amp; 测试 &amp; 升级"></a>2. 安装 &amp; 配置 &amp; 测试 &amp; 升级</h2><h3 id="2-1-前提"><a href="#2-1-前提" class="headerlink" title="2.1 前提"></a>2.1 前提</h3><p>JDK 1.7 版本以上。</p><h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><ul><li>通过包管理工具（SDKMAN、Homebrew、Scoop、Chocolatey、MacPorts）安装，具体参加<a href="https://gradle.org/install/#helpful-information" target="_blank" rel="noopener">官网</a>；</li><li>手动安装，下载二进制压缩包、解压到指定目录；</li></ul><h3 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h3><p>将 $GradlePaht\bin 添加到 Path 环境变量中；</p><h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><p>gradle -v</p><h3 id="2-5-升级"><a href="#2-5-升级" class="headerlink" title="2.5 升级"></a>2.5 升级</h3><p>使用 Gradle Wrapper 可方便快捷升级 Gradle。具体命令：<code>gradle wrapper --gradle-version=4.8 --distribution-type=bin</code>。</p><h3 id="2-6-Gradle-文件结构"><a href="#2-6-Gradle-文件结构" class="headerlink" title="2.6 Gradle 文件结构"></a>2.6 Gradle 文件结构</h3><ul><li>build.gradle：构建 Gradle 脚本；</li><li>settings.gradle：指定哪些项目需要构建，可配置多个项目；</li><li>gradle<ul><li>wrapper<ul><li>gradle-wrapper.jar：包含下载 Gradle 发布包的编译后代码；</li><li>gradle-wrapper.properties：运行时配置；</li></ul></li></ul></li><li>gradlew：Unix 系统的启动脚本；</li><li>gradlew.bat：Windows 系统的启动脚本；</li></ul><h2 id="3-Gradle-Wrapper（简称-Wrapper）"><a href="#3-Gradle-Wrapper（简称-Wrapper）" class="headerlink" title="3. Gradle Wrapper（简称 Wrapper）"></a>3. Gradle Wrapper（简称 Wrapper）</h2><p><strong>推荐使用 Gradle Wrapper 来执行 Gradle 构建。</strong>它是一串脚本用于动态调用指定版本的 Gradle，若不存在，则先下载。这样，开发者可快速开始和运行 Gradle 项目，而不必按照手册安装流程，从而节约时间和金钱。具体流程如下图：<br><img src="https://docs.gradle.org/4.8/userguide/img/wrapper-workflow.png" alt="Gradle Wrapper"></p><h3 id="3-1-优点"><a href="#3-1-优点" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><ul><li>标准化指定 Gradle 版本的项目，使得构建更加可靠和健壮。</li><li>在不同环境或不同用户之间，提供多个版本 Gradle，更加简单方便；</li><li>标准化；</li><li>可靠性；</li><li>可控制性；</li><li>健壮性；</li></ul><h3 id="3-2-新建-Gradle-Wrapper"><a href="#3-2-新建-Gradle-Wrapper" class="headerlink" title="3.2 新建 Gradle Wrapper"></a>3.2 新建 Gradle Wrapper</h3><p>通常要生成 Wrapper 文件需要向安装一个 Gradle，庆幸的是这是一次性的。每个 Gradle 都自带一个叫 wrapper 的任务。<br>运行 <code>gradle wrapper</code> 命令用以生成 Wrapper 文件，具体路径 <code>gradle/wrapper</code>。</p><p><code>注意：</code>若所有开发者和环境均需使用 Wrapper 文件，请将其添加到版本管理工具中。部分公司不允许将二进制文件添加到版本管理工具，这样就没其他解决方案了。</p><h4 id="3-2-1-参数配置选项："><a href="#3-2-1-参数配置选项：" class="headerlink" title="3.2.1 参数配置选项："></a>3.2.1 参数配置选项：</h4><ul><li><code>--gradle-version</code>：指定 Gradle 版本。</li><li><code>--distribution-type</code>：发布包类型，可选择 <strong>bin</strong> 和 <strong>all</strong>。默认为 <strong>bin</strong>。</li><li><code>--gradle-distribution-url</code>：发布包地址，该选项会忽略<code>--gradle-version</code>和<code>--distribution-type</code>参数。</li><li><code>--gradle-distribution-sha256-sum</code>：校验发布包 SHA256 HASH 码。</li></ul><p><code>示例</code>：gradle wrapper –gradle-version 4.0 –distribution-type all </p><h4 id="3-2-2-gradle-wrapper-properties文件"><a href="#3-2-2-gradle-wrapper-properties文件" class="headerlink" title="3.2.2 gradle-wrapper.properties文件"></a>3.2.2 gradle-wrapper.properties文件</h4><p>主要用以存储 Gradle 发布包信息，具体如下：</p><ul><li>Gradle 发布包的服务网路路径；</li><li>Gradle 发布包的类型，默认为 <code>-bin</code> 二进制包，只包括运行时而不包括示例代码和文档；</li><li>Gradle 发布包的版本，默认为生成 Wrapper 文件时的版本；</li></ul><h3 id="3-3-使用-Gradle-Wrapper"><a href="#3-3-使用-Gradle-Wrapper" class="headerlink" title="3.3 使用 Gradle Wrapper"></a>3.3 使用 Gradle Wrapper</h3><p>根据不同系统，运行 <code>gradlew</code> 或 <code>gradlew.bat</code> 脚本来取代 <code>gradle</code> 命令。<br><code>ps</code>：</p><ul><li>若本机未装配置版本的 Gradle，则会自动下载并保持到本机中。若配置未变，则复用。</li><li>多个项目可能分别有 Wrapper 脚本，请确认执行正确的脚本。</li></ul><h3 id="3-4-升级-Gradle-Wrapper"><a href="#3-4-升级-Gradle-Wrapper" class="headerlink" title="3.4 升级 Gradle Wrapper"></a>3.4 升级 Gradle Wrapper</h3><ul><li>手动修改配置文件<code>gradle-wrapper.properties</code>的<code>distributionUrl</code>属性；</li><li><strong>推荐</strong>执行<code>gradle wrapper</code> task 时，指定版本信息，默认为当前版本；</li></ul><h3 id="3-5-自定义-Gradle-Wrapper"><a href="#3-5-自定义-Gradle-Wrapper" class="headerlink" title="3.5 自定义 Gradle Wrapper"></a>3.5 自定义 Gradle Wrapper</h3><p>默认设置可满足大多数要求，然而可通过修改<code>build.gradle</code>配置来自定义相关配置。<br>块节点为<code>wrapper</code>，具体参数详情请参考<a href="https://docs.gradle.org/4.8/dsl/org.gradle.api.tasks.wrapper.Wrapper.html" target="_blank" rel="noopener">Wrapper</a>。</p><h2 id="4-创建一个新的-Gradle-构建"><a href="#4-创建一个新的-Gradle-构建" class="headerlink" title="4. 创建一个新的 Gradle 构建"></a>4. 创建一个新的 Gradle 构建</h2><h3 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h3><p><code>gradle init</code>命令，该命令可<a href="https://docs.gradle.org/4.7/userguide/build_init_plugin.html?&amp;_ga=2.66304238.1375004092.1528446888-1875152485.1526436983#sec:build_init_types" target="_blank" rel="noopener">创建不同类型的项目</a>，且可将 Maven 项目（pom.xml）转换为 Gradle 项目。</p><h3 id="4-2-创建-task"><a href="#4-2-创建-task" class="headerlink" title="4.2 创建 task"></a>4.2 创建 task</h3><p>Gradle 提供一系列 API（使用 Groovy 或 基于 Kotlin 的 DSL 语言） 用于创建和配置 task。一个 Project 包括一个 Task 集合，每个单独提供一些基础功能。<a href="https://docs.gradle.org/4.7/userguide/more_about_tasks.html" target="_blank" rel="noopener">具体详情</a><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> <span class="keyword">copy</span>(type: <span class="keyword">Copy</span>, <span class="keyword">group</span>: <span class="string">"Custom"</span>, <span class="keyword">description</span>: <span class="string">"Copies sources to the dest directory"</span>) &#123;</span><br><span class="line">    <span class="keyword">from</span> <span class="string">"src"</span></span><br><span class="line">    <span class="keyword">into</span> <span class="string">"dest"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-3-应用插件"><a href="#4-3-应用插件" class="headerlink" title="4.3 应用插件"></a>4.3 应用插件</h3><p>Gradle 提供一系列<a href="http://plugins.gradle.org/?_ga=2.27464572.1375004092.1528446888-1875152485.1526436983" target="_blank" rel="noopener">插件</a>。<br><code>ps</code>：plugins{} 代码块放置在配置文件最上方。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins&#123;</span><br><span class="line">    id <span class="string">"base"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-查看可用的-task"><a href="#4-4-查看可用的-task" class="headerlink" title="4.4 查看可用的 task"></a>4.4 查看可用的 task</h3><p><code>gradle tasks</code> 命令</p><h3 id="4-5-分析-amp-调试构建"><a href="#4-5-分析-amp-调试构建" class="headerlink" title="4.5 分析 &amp; 调试构建"></a>4.5 分析 &amp; 调试构建</h3><p>Gradle 提供一个叫<code>build scan</code>（专业版功能）的方式用于构建过程可视化。通过使用<code>--scan</code>命令或者对项目应用<code>scan</code>插件即可。</p><h3 id="4-6-查看可用的-properties"><a href="#4-6-查看可用的-properties" class="headerlink" title="4.6 查看可用的 properties"></a>4.6 查看可用的 properties</h3><p><code>gradle properties</code> 命令</p><h2 id="5-创建构建浏览（Build-Scans）"><a href="#5-创建构建浏览（Build-Scans）" class="headerlink" title="5. 创建构建浏览（Build Scans）"></a>5. 创建构建浏览（Build Scans）</h2><p>构建浏览是一个用于展示构建的 what happened and why 的工具，具有可分享，集中管理特性。可免费发布到 <a href="https://scans.gradle.com" target="_blank" rel="noopener">https://scans.gradle.com</a>。方式：</p><ul><li><code>--scan</code>命令参数；</li><li>插件  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.gradle.build-scan'</span> version <span class="string">'1.13.3'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>同意许可协议，或者直接配置好<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buildScan &#123;</span><br><span class="line">    termsOfServiceUrl = <span class="string">'https://gradle.com/terms-of-service'</span></span><br><span class="line">    termsOfServiceAgree = <span class="string">'yes'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对所有构建进行默认配置 build scan，在<code>~/.gradle/init.d</code>目录中创建 gradle 文件用于默认 build。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">initscript &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.gradle:build-scan-plugin:1.13.3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rootProject &#123;</span><br><span class="line">    apply plugin: com.gradle.scan.plugin.BuildScanPlugin</span><br><span class="line"></span><br><span class="line">    buildScan &#123;</span><br><span class="line">        termsOfServiceUrl = <span class="string">'https://gradle.com/terms-of-service'</span></span><br><span class="line">        termsOfServiceAgree = <span class="string">'yes'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://docs.gradle.com/build-scan-plugin" target="_blank" rel="noopener">官方用户手册</a></p><h2 id="6-迁移-Maven-至-Gradle"><a href="#6-迁移-Maven-至-Gradle" class="headerlink" title="6. 迁移 Maven 至 Gradle"></a>6. 迁移 Maven 至 Gradle</h2><h3 id="6-1-自动转换"><a href="#6-1-自动转换" class="headerlink" title="6.1 自动转换"></a>6.1 自动转换</h3><p><code>gradle init</code>命令：该命令允许自动将 Maven 项目转换为 Gradle 项目。<br><code>ps</code>：</p><ul><li>自动转换中组件不会自动转换，或有问题，需手动处理。</li><li>如果幸运地转换成功，可使用<code>gradle build</code>测试。</li></ul><p>具体迁移信息详见<a href="https://guides.gradle.org/migrating-from-maven" target="_blank" rel="noopener">迁移 Maven 至 Gradle</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;一个自动化构建工具，用于加速开发者生产率，特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build Anything;&lt;/li&gt;
&lt;li&gt;Automate Everything;&lt;/li&gt;
&lt;li&gt;Deliver Faster;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
      <category term="工具" scheme="http://www.venux.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>10.重构-重构、复用与现实（William Opdyke）</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/10.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E3%80%81%E5%A4%8D%E7%94%A8%E4%B8%8E%E7%8E%B0%E5%AE%9E/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/10.重构-重构、复用与现实/</id>
    <published>2018-06-10T11:06:26.000Z</published>
    <updated>2018-10-09T08:43:20.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-重构"><a href="#1-重构" class="headerlink" title="1. 重构"></a>1. 重构</h2><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h3><ul><li>生产进度的压力：<ul><li>重写整个程序（理想情况）；</li><li>复制、修改现有系统；  </li></ul></li><li>不知道如何重构；</li><li>如果利益是长远的，为什么现在做呢？可能收获利益之时，就已经不在职位上了；</li><li>代码重构是额外工作，老板看不到付出；</li><li>重构可能破坏现有程序；</li></ul><h3 id="1-2-回答"><a href="#1-2-回答" class="headerlink" title="1.2 回答"></a>1.2 回答</h3><ul><li>重构可以带来短期利益和长期利益。</li><li>已有重构工具和技术，可快速，无痛苦完成；</li><li>重构虽然花费精力和时间开销，当可在其他阶段减小相应开销；</li><li>当重构成为软件开发规则的一部分时，人们就觉得它必不可少；</li></ul><a id="more"></a><h2 id="2-做法"><a href="#2-做法" class="headerlink" title="2. 做法"></a>2. 做法</h2><ul><li>了解如何重构、在哪儿重构；</li><li>合理利用重构工具；</li><li>遵守重构规则；</li><li>团队保持共识；</li></ul><h2 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h2><p>安全性是令人关系的议题，特别是大型系统。许多应用程序由于财政、法律和道德伦理的压力，需要不间断、可靠、不出错的提供服务。</p><h2 id="3-1-如何进行安全重构"><a href="#3-1-如何进行安全重构" class="headerlink" title="3.1 如何进行安全重构"></a>3.1 如何进行安全重构</h2><ul><li>选择：<ul><li>相信编码功力；</li><li>相信编译器能捕捉错误；</li><li>相信测试能测出错误；</li><li>相信代码复审能捕捉错误；</li></ul></li><li>局限性：<ul><li>人人都可能犯错；</li><li>一些微妙错误编译器无法捕捉；</li><li>测试不可能覆盖所有情况，测出所有问题；</li><li>代码复审很可能没有，或出错，或没找到错误；</li></ul></li><li>方案：<ul><li>定义并快速实现一个重构工具的原型，用以检查某项重构是否可以安全地施加于程序上。若可能，则重构。这避免了大量可能因为人为错误引入的 bug。</li></ul></li></ul><h2 id="4-复用"><a href="#4-复用" class="headerlink" title="4. 复用"></a>4. 复用</h2><h3 id="4-1-问题（类似于重构）"><a href="#4-1-问题（类似于重构）" class="headerlink" title="4.1 问题（类似于重构）"></a>4.1 问题（类似于重构）</h3><ul><li>不知道“该复用什么”或“如何复用”；</li><li>对采用复用方法缺乏动力，除非有短期利益；</li><li>开销、学习曲线和探索成本；</li><li>项目压力；</li></ul><h3 id="4-2-回答（原则）"><a href="#4-2-回答（原则）" class="headerlink" title="4.2 回答（原则）"></a>4.2 回答（原则）</h3><ul><li>对员工进行培训；</li><li>尽量获取短期利益；</li><li>减少开销；</li><li>安全引入新技术；<br><code>ps</code>：这些不仅仅可用于重构和软件复用，还可用于技术传播。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第13章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-重构&quot;&gt;&lt;a href=&quot;#1-重构&quot; class=&quot;headerlink&quot; title=&quot;1. 重构&quot;&gt;&lt;/a&gt;1. 重构&lt;/h2&gt;&lt;h3 id=&quot;1-1-问题&quot;&gt;&lt;a href=&quot;#1-1-问题&quot; class=&quot;headerlink&quot; title=&quot;1.1 问题&quot;&gt;&lt;/a&gt;1.1 问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;生产进度的压力：&lt;ul&gt;
&lt;li&gt;重写整个程序（理想情况）；&lt;/li&gt;
&lt;li&gt;复制、修改现有系统；  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不知道如何重构；&lt;/li&gt;
&lt;li&gt;如果利益是长远的，为什么现在做呢？可能收获利益之时，就已经不在职位上了；&lt;/li&gt;
&lt;li&gt;代码重构是额外工作，老板看不到付出；&lt;/li&gt;
&lt;li&gt;重构可能破坏现有程序；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-回答&quot;&gt;&lt;a href=&quot;#1-2-回答&quot; class=&quot;headerlink&quot; title=&quot;1.2 回答&quot;&gt;&lt;/a&gt;1.2 回答&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;重构可以带来短期利益和长期利益。&lt;/li&gt;
&lt;li&gt;已有重构工具和技术，可快速，无痛苦完成；&lt;/li&gt;
&lt;li&gt;重构虽然花费精力和时间开销，当可在其他阶段减小相应开销；&lt;/li&gt;
&lt;li&gt;当重构成为软件开发规则的一部分时，人们就觉得它必不可少；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>11.重构-重构工具（Don Roberts 和 John Brant）</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/11.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/11.重构-重构工具/</id>
    <published>2018-06-10T11:06:26.000Z</published>
    <updated>2018-10-09T08:43:20.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1. 总结"></a>1. 总结</h2><p>作者那时写《重构》一书时，还未像现如今一样。现在，各类 IDE 都提供重构工具辅助重构，而不用自己去实现一整套重构工具或手动重构了。所以，现在程序员自然而然的乐意像整理代码一样去整理系统，即重构。这样，对代码的可维护性、可复用性和可理解性大大加强。</p><a id="more"></a><h2 id="2-辅助工具"><a href="#2-辅助工具" class="headerlink" title="2. 辅助工具"></a>2. 辅助工具</h2><ul><li>自动化重构工具；</li><li>自动化测试工具；</li></ul><h2 id="3-重构工具的技术标准"><a href="#3-重构工具的技术标准" class="headerlink" title="3. 重构工具的技术标准"></a>3. 重构工具的技术标准</h2><ul><li>程序数据库；</li><li>解析树；</li><li>准确性；</li></ul><h2 id="4-重构工具的实用标准"><a href="#4-重构工具的实用标准" class="headerlink" title="4. 重构工具的实用标准"></a>4. 重构工具的实用标准</h2><ul><li>速度；</li><li>撤销；</li><li>与其他工具集成；</li><li>易用性（个人添加）；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第14章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-总结&quot;&gt;&lt;a href=&quot;#1-总结&quot; class=&quot;headerlink&quot; title=&quot;1. 总结&quot;&gt;&lt;/a&gt;1. 总结&lt;/h2&gt;&lt;p&gt;作者那时写《重构》一书时，还未像现如今一样。现在，各类 IDE 都提供重构工具辅助重构，而不用自己去实现一整套重构工具或手动重构了。所以，现在程序员自然而然的乐意像整理代码一样去整理系统，即重构。这样，对代码的可维护性、可复用性和可理解性大大加强。&lt;/p&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>09.重构-大型重构</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/09.%E9%87%8D%E6%9E%84-%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/09.重构-大型重构/</id>
    <published>2018-06-08T15:06:26.000Z</published>
    <updated>2018-10-09T08:43:20.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-重构特点"><a href="#1-重构特点" class="headerlink" title="1. 重构特点"></a>1. 重构特点</h2><ul><li>大型重构中，情况复杂，变化多样性，没有准确的重构步骤，只能根据实际情况考虑分析；</li><li>大型重构耗时长，需合理安排工作，只在需要添加新功能或修补错误时才重构；</li><li>不必一开始就完成整个系统的重构，而应该只需满足任务需求就可；</li><li>大规模重构时，整个团队需建立共识。</li></ul><a id="more"></a><h2 id="2-问题及方案"><a href="#2-问题及方案" class="headerlink" title="2. 问题及方案"></a>2. 问题及方案</h2><ul><li>混乱的继承体系：Tease Apart Inheritance（梳理并分解继承体系）；</li><li>过程式代码：Convert Procedural Design to Objects（将面向过程设计改为面向对象设计）；</li><li>传统两层结构（用户界面和数据库），业务代码和界面耦合：Separate Domain from Presentation；</li><li>过于复杂的类：Extract Hierarchy；</li></ul><h2 id="3-Tease-Apart-Inheritance（梳理并分解继承体系）"><a href="#3-Tease-Apart-Inheritance（梳理并分解继承体系）" class="headerlink" title="3. Tease Apart Inheritance（梳理并分解继承体系）"></a>3. Tease Apart Inheritance（梳理并分解继承体系）</h2><p>问题：某个继承体系同时承担多种职责。<br>建立多个继承体系，并使用委托（依赖）关系用于调用。<br><code>ps</code>：</p><ul><li>参考抽象工厂模式（创建型）、桥接模式（结构性、抽象与实现分离）；</li><li>注意耦合关系；</li></ul><h2 id="4-Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）"><a href="#4-Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）" class="headerlink" title="4. Convert Procedural Design to Objects（将过程化设计转换为对象设计）"></a>4. Convert Procedural Design to Objects（将过程化设计转换为对象设计）</h2><p>将数据记录变为对象，将大块的行为拆分成小块，并将行为移动到对象中。</p><h2 id="5-Separate-Domain-from-Presentation（将领域和表现分离）"><a href="#5-Separate-Domain-from-Presentation（将领域和表现分离）" class="headerlink" title="5. Separate Domain from Presentation（将领域和表现分离）"></a>5. Separate Domain from Presentation（将领域和表现分离）</h2><p>将领域逻辑和表现界面分离。<br><code>ps</code>：</p><ul><li>MVC（模型-视图-控制器）模式：最核心价值在于将用户界面（视图、展现层）和领域逻辑（模型）分离。</li></ul><h2 id="6-Extract-Hierarchy（提炼继承体系）"><a href="#6-Extract-Hierarchy（提炼继承体系）" class="headerlink" title="6. Extract Hierarchy（提炼继承体系）"></a>6. Extract Hierarchy（提炼继承体系）</h2><p>问题：一个类承担了太多职责，其中一部分工作是以大量的条件表达式来完成的。<br>建立继承体系，以一个子类来表示一种特殊情况。<br><code>ps</code>：</p><ul><li>只有当条件逻辑在对象的整个生命周期保持不变时，才可使用该策略。</li><li>该策略是一项大型重构，请先梳理清晰，明确步骤后，再动手处理。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第12章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-重构特点&quot;&gt;&lt;a href=&quot;#1-重构特点&quot; class=&quot;headerlink&quot; title=&quot;1. 重构特点&quot;&gt;&lt;/a&gt;1. 重构特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;大型重构中，情况复杂，变化多样性，没有准确的重构步骤，只能根据实际情况考虑分析；&lt;/li&gt;
&lt;li&gt;大型重构耗时长，需合理安排工作，只在需要添加新功能或修补错误时才重构；&lt;/li&gt;
&lt;li&gt;不必一开始就完成整个系统的重构，而应该只需满足任务需求就可；&lt;/li&gt;
&lt;li&gt;大规模重构时，整个团队需建立共识。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>08.重构-处理类的继承关系(generalization)</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/08.%E9%87%8D%E6%9E%84-%E5%A4%84%E7%90%86%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/08.重构-处理类的继承关系/</id>
    <published>2018-06-07T15:06:26.000Z</published>
    <updated>2018-10-09T08:43:20.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>字段位置不正确：Pull Up Field、Pull Down Field；</li><li>函数位置不正确：Pull Up Method、Pull Down Method；</li><li>构造函数：Pull Up Constructor Body（向上）、Replace Constructor with Factory Method；</li><li>函数大体相同、细节不同：Form Template Method；</li><li>改变继承体系：Extract Subclass、Extract Superclass、Extract Interface；</li><li>继承体系部分类无用：Collapse（瓦解） Hierarchy（层次结构）；</li><li>委托替代继承：Replace Inheritance with Delegation；</li><li>继承替代委托：Replace Delegation with Inheritance；</li></ul><a id="more"></a><h2 id="2-Pull-Up-Field-Method（字段-函数上移）"><a href="#2-Pull-Up-Field-Method（字段-函数上移）" class="headerlink" title="2. Pull Up Field/Method（字段/函数上移）"></a>2. Pull Up Field/Method（字段/函数上移）</h2><p>将多个子类的相同字段/函数移到超类。</p><h2 id="3-Pull-Down-Field-Method（字段-函数下移）"><a href="#3-Pull-Down-Field-Method（字段-函数下移）" class="headerlink" title="3. Pull Down Field/Method（字段/函数下移）"></a>3. Pull Down Field/Method（字段/函数下移）</h2><p>超类的字段/函数只与部分（而非全部）子类有关，移动到相关子类中。</p><h2 id="4-Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#4-Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="4. Pull Up Constructor Body（构造函数本体上移）"></a>4. Pull Up Constructor Body（构造函数本体上移）</h2><p>多个子类的构造函数相同，将主体移动到超类构造函数中，并在子类中调用它。</p><h2 id="5-Replace-Constructor-with-Factory-Method（使用工厂方法替代构造函数）"><a href="#5-Replace-Constructor-with-Factory-Method（使用工厂方法替代构造函数）" class="headerlink" title="5. Replace Constructor with Factory Method（使用工厂方法替代构造函数）"></a>5. Replace Constructor with Factory Method（使用工厂方法替代构造函数）</h2><p>由于无法将构造函数本体下移，故改为使用工厂方法模式。</p><h2 id="6-Extract-Subclass（提炼子类）"><a href="#6-Extract-Subclass（提炼子类）" class="headerlink" title="6. Extract Subclass（提炼子类）"></a>6. Extract Subclass（提炼子类）</h2><p>问题：类中的某些特性只被某些（而非全部）实例使用。<br>新建一个子类，移动特性到子类中。<br><code>ps</code>：Extract Class 是另一种选择，两者抉择之处在于委托和继承之间的选择。</p><h2 id="7-Extract-SuperClass（提炼超类）"><a href="#7-Extract-SuperClass（提炼超类）" class="headerlink" title="7. Extract SuperClass（提炼超类）"></a>7. Extract SuperClass（提炼超类）</h2><p>为两个相似的类建立一个超类，将相同特性移至超类。</p><h2 id="8-Extract-Interface（提炼接口）"><a href="#8-Extract-Interface（提炼接口）" class="headerlink" title="8. Extract Interface（提炼接口）"></a>8. Extract Interface（提炼接口）</h2><p>多个类有相似的行为，或多个类的接口有相似部分，将相同的行为提炼到一个独立的接口中。</p><h2 id="9-Collapse-Hierarchy（折叠继承体系）"><a href="#9-Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="9. Collapse Hierarchy（折叠继承体系）"></a>9. Collapse Hierarchy（折叠继承体系）</h2><p>问题：超类和子类之间无太大区别。<br>将它们合为一体。</p><h2 id="10-Form-Template-Method（塑造模板函数）"><a href="#10-Form-Template-Method（塑造模板函数）" class="headerlink" title="10. Form Template Method（塑造模板函数）"></a>10. Form Template Method（塑造模板函数）</h2><p>问题：子类的某些函数以相同顺序执行类似操作，细节有所不同。<br>将这些操作分别放进独立函数中，并保持相同签名。而后将原函数提炼到超类中。<br><code>ps</code>：即模板方法模式。</p><h2 id="11-Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#11-Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="11. Replace Inheritance with Delegation（以委托取代继承）"></a>11. Replace Inheritance with Delegation（以委托取代继承）</h2><p>问题：某个子类只使用超类的一部分，或根本不需要继承而来的数据。<br>在子类中新建一个字段引用超类，调整子类函数，而后让它调用超类，最后去除两者之间的继承关系。<br><code>ps</code>：此处的委托其实应该理解为委托调用关系，即依赖关系，而非 C# 的委托。</p><h2 id="12-Replace-Delegation-with-Inheritance（以继承取代委托）"><a href="#12-Replace-Delegation-with-Inheritance（以继承取代委托）" class="headerlink" title="12. Replace Delegation with Inheritance（以继承取代委托）"></a>12. Replace Delegation with Inheritance（以继承取代委托）</h2><p>问题：两个类之间使用委托关系，并经常为了<strong>整个接口（即所有函数）</strong>编写许多极其简单的委托函数。<br>让委托类继承被委托类。<br><code>ps</code>：</p><ul><li>该重构手法与 Replace Inheritance with Delegation 恰恰相反。</li><li>如果你并没有使用被委托类的所有函数，就不该使用该重构手法。</li><li>被委托对象被不止一个对象共享，而且被委托对象是可变的，此时就不该使用该重构手法。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第11章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;字段位置不正确：Pull Up Field、Pull Down Field；&lt;/li&gt;
&lt;li&gt;函数位置不正确：Pull Up Method、Pull Down Method；&lt;/li&gt;
&lt;li&gt;构造函数：Pull Up Constructor Body（向上）、Replace Constructor with Factory Method；&lt;/li&gt;
&lt;li&gt;函数大体相同、细节不同：Form Template Method；&lt;/li&gt;
&lt;li&gt;改变继承体系：Extract Subclass、Extract Superclass、Extract Interface；&lt;/li&gt;
&lt;li&gt;继承体系部分类无用：Collapse（瓦解） Hierarchy（层次结构）；&lt;/li&gt;
&lt;li&gt;委托替代继承：Replace Inheritance with Delegation；&lt;/li&gt;
&lt;li&gt;继承替代委托：Replace Delegation with Inheritance；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>07.重构-简化函数调用</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/07.%E9%87%8D%E6%9E%84-%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/07.重构-简化函数调用/</id>
    <published>2018-06-06T15:06:26.000Z</published>
    <updated>2018-10-09T08:43:20.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>函数名称不清晰：Rename Method；</li><li>参数不明确：Add Parameter、Remove Parameter；</li><li>参数过多：Preserve Whole Object、Introduce Parameter Object； </li><li>函数参数来自该函数可以获取的对象：Replace Parameter with Method；</li><li>参数被用于条件表达式：Replace Parameter with Explicit Method；</li><li>多个相似函数添加参数：Parameterize Method；</li><li>查询命令函数分离：Separate Query from Modifier；</li><li>不必要的暴露：Hide Method、Remove Setting Method；</li><li>隐藏创建对象：Replace Constructor with Factory Method；</li><li>转型：Encapsulate Downcast；</li><li>错误码、异常、测试：Replace Error Code with Exception、Replace Exception with Test；</li></ul><a id="more"></a><h2 id="2-Rename-Method（函数改名）"><a href="#2-Rename-Method（函数改名）" class="headerlink" title="2. Rename Method（函数改名）"></a>2. Rename Method（函数改名）</h2><p>修改函数名称，更加清晰明了。</p><h2 id="3-Add-Parameter（添加参数）"><a href="#3-Add-Parameter（添加参数）" class="headerlink" title="3. Add Parameter（添加参数）"></a>3. Add Parameter（添加参数）</h2><p>为函数添加参数，带进所需信息。</p><h3 id="3-1-动机"><a href="#3-1-动机" class="headerlink" title="3.1 动机"></a>3.1 动机</h3><p>请先确认是否一定需要添加新参数：</p><ul><li>你能从已有参数得到所需信息么？</li><li>有可能通过某个函数得到所需信息么？</li><li>这个函数是否应该属于拥有该信息的对象所有？</li><li>现有参数过多，是否考虑使用 Introduce Parameter Object？<br><code>ps</code>：若旧函数是接口一部分，不好删除，请标记为 deprecated（不赞成）。</li></ul><h2 id="4-Remove-Parameter（移除参数）"><a href="#4-Remove-Parameter（移除参数）" class="headerlink" title="4. Remove Parameter（移除参数）"></a>4. Remove Parameter（移除参数）</h2><p>将不需要的参数移除。</p><h2 id="5-Separate-Query-from-Modifer（将查询函数和修改函数分离）"><a href="#5-Separate-Query-from-Modifer（将查询函数和修改函数分离）" class="headerlink" title="5. Separate Query from Modifer（将查询函数和修改函数分离）"></a>5. Separate Query from Modifer（将查询函数和修改函数分离）</h2><p>建立两个不同的函数，一个负责查询，另一个负责修改。</p><h3 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h3><ul><li>明确表示“有副作用”和“无副作用”两种函数之间的差异；</li><li>任何有返回值的函数，都不应该有<strong>看得到</strong>（提取出查询函数，将结果缓存到某个字段）的副作用。<br><code>ps</code>：多线程环境下，建立第三个函数来做“查询-修改”，该还是调用独立的查询函数和修改函数，并被声明为 synchronized。若为声明为 synchronized，则将它们的可见范围限制在包级别或 private 级别。如此就能保证安全、同步的操作。</li></ul><h2 id="6-Parameterize-Method（令函数携带参数）"><a href="#6-Parameterize-Method（令函数携带参数）" class="headerlink" title="6. Parameterize Method（令函数携带参数）"></a>6. Parameterize Method（令函数携带参数）</h2><p>建立单一函数，以参数表达那些不同的值。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><p>多个函数处理类似工作，仅因为值不同而略有不同。</p><h2 id="7-Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#7-Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="7. Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>7. Replace Parameter with Explicit Methods（以明确函数取代参数）</h2><p>问题：函数完全取决于参数值而采取不同行为。<br>针对该参数的的每一个可能值，建立一个独立函数。<br><code>ps</code>：</p><ul><li>与 Parameterize Method 正好相反。</li><li>若参数值对函数行为没太多影像，就不该使用该重构手法。</li><li>若需要条件判断，考虑使用 Replace Conditional with Polymorphism。</li></ul><h2 id="8-Preserve-Whole-Object（保持对象完整）"><a href="#8-Preserve-Whole-Object（保持对象完整）" class="headerlink" title="8. Preserve Whole Object（保持对象完整）"></a>8. Preserve Whole Object（保持对象完整）</h2><p>将从某个对象取出某些值作为参数传递改为直接传递整个对象。<br><code>ps</code>：</p><ul><li>两面性，该重构手法会产生依赖关系，请考虑后在使用。</li><li>先考虑 Move Method。</li></ul><h2 id="9-Replace-Parameter-with-Methods（以函数取代参数）"><a href="#9-Replace-Parameter-with-Methods（以函数取代参数）" class="headerlink" title="9. Replace Parameter with Methods（以函数取代参数）"></a>9. Replace Parameter with Methods（以函数取代参数）</h2><p>问题：对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能调用前一个函数。<br>让参数接受者去除该项参数，直接调用前一个函数。</p><h3 id="9-1-动机"><a href="#9-1-动机" class="headerlink" title="9.1 动机"></a>9.1 动机</h3><p>如果函数可以通过其他途径获取参数，就不应该通过参数传递。应尽可能缩短参数列的长度。</p><h2 id="10-Introduce-Parameter-Object（引入参数对象）"><a href="#10-Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="10. Introduce Parameter Object（引入参数对象）"></a>10. Introduce Parameter Object（引入参数对象）</h2><p>以一个对象取代这些参数。</p><h3 id="10-1-动机"><a href="#10-1-动机" class="headerlink" title="10.1 动机"></a>10.1 动机</h3><p>特定的一组参数总是被一起传递，好几个函数都使用这组参数。这就是所谓的 Data Clumps（数据泥团）。</p><h2 id="11-Remove-Setting-Method（移除设值函数）"><a href="#11-Remove-Setting-Method（移除设值函数）" class="headerlink" title="11. Remove Setting Method（移除设值函数）"></a>11. Remove Setting Method（移除设值函数）</h2><p>若某个字段在对象创建后就不再改变，则应移除该字段的所有设值函数。</p><h2 id="12-Hide-Method（隐藏函数）"><a href="#12-Hide-Method（隐藏函数）" class="headerlink" title="12. Hide Method（隐藏函数）"></a>12. Hide Method（隐藏函数）</h2><p>该函数不被外界使用，请设为 private。</p><h2 id="13-Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#13-Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="13. Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>13. Replace Constructor with Factory Method（以工厂函数取代构造函数）</h2><p>将构造函数替换为工厂函数。</p><h3 id="13-1-动机"><a href="#13-1-动机" class="headerlink" title="13.1 动机"></a>13.1 动机</h3><ul><li>在派生类中以工程函数取代类型码；</li><li>以明确函数创建子类；</li></ul><h2 id="14-Encapsulate-Downcast（封装向下转型）"><a href="#14-Encapsulate-Downcast（封装向下转型）" class="headerlink" title="14. Encapsulate Downcast（封装向下转型）"></a>14. Encapsulate Downcast（封装向下转型）</h2><p>将向下转型动作移到函数中。</p><h2 id="15-Replace-Error-Code-with-Exception（以异常取代错误码）"><a href="#15-Replace-Error-Code-with-Exception（以异常取代错误码）" class="headerlink" title="15. Replace Error Code with Exception（以异常取代错误码）"></a>15. Replace Error Code with Exception（以异常取代错误码）</h2><p>某个函数返回一个特定的代码，用以表示某种错误情况。改用异常。</p><h2 id="16-Replace-Exception-with-Test（以测试取代异常）"><a href="#16-Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="16. Replace Exception with Test（以测试取代异常）"></a>16. Replace Exception with Test（以测试取代异常）</h2><p>问题：面对一个调用者可以预先检查的条件，你抛出了一个异常。<br>修改调用者，使它在调用函数之前先做检查。</p><h3 id="16-1-动机"><a href="#16-1-动机" class="headerlink" title="16.1 动机"></a>16.1 动机</h3><ul><li>异常滥用情况，异常只应该被用于意料之外的错误行为，而不应该成为条件检查的替代品。<br><code>ps</code>：我自己的坏习惯就是滥用异常，而且统一捕获。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第10章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;函数名称不清晰：Rename Method；&lt;/li&gt;
&lt;li&gt;参数不明确：Add Parameter、Remove Parameter；&lt;/li&gt;
&lt;li&gt;参数过多：Preserve Whole Object、Introduce Parameter Object； &lt;/li&gt;
&lt;li&gt;函数参数来自该函数可以获取的对象：Replace Parameter with Method；&lt;/li&gt;
&lt;li&gt;参数被用于条件表达式：Replace Parameter with Explicit Method；&lt;/li&gt;
&lt;li&gt;多个相似函数添加参数：Parameterize Method；&lt;/li&gt;
&lt;li&gt;查询命令函数分离：Separate Query from Modifier；&lt;/li&gt;
&lt;li&gt;不必要的暴露：Hide Method、Remove Setting Method；&lt;/li&gt;
&lt;li&gt;隐藏创建对象：Replace Constructor with Factory Method；&lt;/li&gt;
&lt;li&gt;转型：Encapsulate Downcast；&lt;/li&gt;
&lt;li&gt;错误码、异常、测试：Replace Error Code with Exception、Replace Exception with Test；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>其他</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%85%B6%E4%BB%96/"/>
    <id>http://www.venux.cn//posts/05.编程思想/其他/</id>
    <published>2018-06-06T11:34:46.000Z</published>
    <updated>2018-10-09T08:43:19.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查询命令职责分离（CQRS）"><a href="#1-查询命令职责分离（CQRS）" class="headerlink" title="1. 查询命令职责分离（CQRS）"></a>1. 查询命令职责分离（CQRS）</h2><p>明确地将“修改对象状态”的函数（修改函数）和“查询对象状态”的函数（查询函数）分开设计。</p><h2 id="2-将复杂的处理过程分解为小函数。"><a href="#2-将复杂的处理过程分解为小函数。" class="headerlink" title="2. 将复杂的处理过程分解为小函数。"></a>2. 将复杂的处理过程分解为小函数。</h2><h2 id="3-任何有返回值的函数，都不应该有看得到的副作用。"><a href="#3-任何有返回值的函数，都不应该有看得到的副作用。" class="headerlink" title="3.任何有返回值的函数，都不应该有看得到的副作用。"></a>3.任何有返回值的函数，都不应该有看得到的副作用。</h2><h2 id="4-Range-模式"><a href="#4-Range-模式" class="headerlink" title="4. Range 模式"></a>4. Range 模式</h2><p>使用范围对象替代多个参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-查询命令职责分离（CQRS）&quot;&gt;&lt;a href=&quot;#1-查询命令职责分离（CQRS）&quot; class=&quot;headerlink&quot; title=&quot;1. 查询命令职责分离（CQRS）&quot;&gt;&lt;/a&gt;1. 查询命令职责分离（CQRS）&lt;/h2&gt;&lt;p&gt;明确地将“修改对象状态”
      
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="设计模式" scheme="http://www.venux.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>06.重构-简化条件表达式</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/06.%E9%87%8D%E6%9E%84-%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/06.重构-简化条件表达式/</id>
    <published>2018-06-05T15:06:26.000Z</published>
    <updated>2018-10-09T08:43:20.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>复杂条件逻辑拆分：Decompose（分解） Conditional；</li><li>代码多次测试结果相同：Consolidate（合并） Conditional Expression；</li><li>条件代码重复：Consolidate Duplicate Conditional Fragments（碎片）；</li><li>“单一出口”特殊情况：Replace Nested Conditional with Guard Clauses；</li><li>去除控制标记：Remove Control Flag；</li><li>switch 语句：Replace Conditional with Polymorphism（多态）；</li><li>去除 Null 检验：Introduce Null Object；</li></ul><a id="more"></a><h2 id="2-Decompose-Conditional（分解条件表达式）"><a href="#2-Decompose-Conditional（分解条件表达式）" class="headerlink" title="2. Decompose Conditional（分解条件表达式）"></a>2. Decompose Conditional（分解条件表达式）</h2><p>从 if-then-else 中分别提炼到独立函数；</p><h2 id="3-Consolidate-Conditional-Expression（合并条件表达式）"><a href="#3-Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="3. Consolidate Conditional Expression（合并条件表达式）"></a>3. Consolidate Conditional Expression（合并条件表达式）</h2><p>将同样结果的条件测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。<br><code>ps</code>:</p><ul><li>类似多个 case 使用同样的代码。</li><li>如果你认为这些检查的确需要彼此独立，就可以不要使用该项重构，不过必须表示清楚自己的意义。</li></ul><h2 id="4-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#4-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="4. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>4. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h2><p>将重复代码提取到条件表达式之外。</p><h2 id="5-Remove-Control-Flag（移除控制标记）"><a href="#5-Remove-Control-Flag（移除控制标记）" class="headerlink" title="5. Remove Control Flag（移除控制标记）"></a>5. Remove Control Flag（移除控制标记）</h2><p>以 break、continue、return 语句取代控制标记。</p><h2 id="6-Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式，防御编程）"><a href="#6-Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式，防御编程）" class="headerlink" title="6. Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式，防御编程）"></a>6. Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式，防御编程）</h2><p>使用卫语句表现所有特殊情况。<br><strong>精髓</strong>：给某一条分支以特别的重视。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><ul><li>条件表达式不同形式：<ul><li>所有分支都是正常行为：使用 if-else；</li><li>只有一种是正常行为，其他都是不正常情况：if-return,XXX；</li></ul></li><li>将条件反转，而后使用该重构手法；</li></ul><h3 id="6-2-示例"><a href="#6-2-示例" class="headerlink" title="6.2 示例"></a>6.2 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">false</span> &amp;&amp; B==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="comment">//Do Here</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">true</span> &amp;&amp; B==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#7-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="7. Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>7. Replace Conditional with Polymorphism（以多态取代条件表达式）</h2><p>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。<br><code>ps</code>：多态最根本的好处：根据对象的不同类型（形态）采用不同的行为，而不必编写明显的条件表达式。</p><h3 id="7-1-做法"><a href="#7-1-做法" class="headerlink" title="7.1 做法"></a>7.1 做法</h3><ul><li>建立继承结构<ul><li>Replace Type Code with Subclasses；</li><li>Replace Type Code with State/Strategy；</li></ul></li></ul><h2 id="8-Introduce-Null-Object（引入-Null-对象）"><a href="#8-Introduce-Null-Object（引入-Null-对象）" class="headerlink" title="8. Introduce Null Object（引入 Null 对象）"></a>8. Introduce Null Object（引入 Null 对象）</h2><p>将 null 值替换为 null 对象。<br><code>ps</code>：</p><ul><li>空对象一定是常量，它们的任何成分都不会发生变化。因此，可考虑使用单例模式保证唯一实例。</li><li>本质上来说，Null object 模式属于 Special Case 模式。</li></ul><h2 id="9-Introduce-Assertion（引入断言）"><a href="#9-Introduce-Assertion（引入断言）" class="headerlink" title="9. Introduce Assertion（引入断言）"></a>9. Introduce Assertion（引入断言）</h2><p>以断言明确表现某些用以对程序状态的假设。<br><code>ps</code>：</p><ul><li>断言是个条件表达式，应该总是为真。若失败，则表示程序员犯错了，所以断言的失败会导致一个非受控异常（unchecked exception）。</li><li>断言绝对不能被系统其它部分使用，实际上，最后成品往往需删除断言。</li><li>不要滥用断言，请不要使用它来检查“你认为应该为真”的条件，请只是用它来检查“一定必须为真”的条件。</li><li>如果断言所指示的约束条件不能满足，代码是否仍能正常运行？若可以，则移除断言。</li><li>断言的价值在于：帮助程序员理解代码正确运行的必要条件。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第9章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;复杂条件逻辑拆分：Decompose（分解） Conditional；&lt;/li&gt;
&lt;li&gt;代码多次测试结果相同：Consolidate（合并） Conditional Expression；&lt;/li&gt;
&lt;li&gt;条件代码重复：Consolidate Duplicate Conditional Fragments（碎片）；&lt;/li&gt;
&lt;li&gt;“单一出口”特殊情况：Replace Nested Conditional with Guard Clauses；&lt;/li&gt;
&lt;li&gt;去除控制标记：Remove Control Flag；&lt;/li&gt;
&lt;li&gt;switch 语句：Replace Conditional with Polymorphism（多态）；&lt;/li&gt;
&lt;li&gt;去除 Null 检验：Introduce Null Object；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
</feed>
