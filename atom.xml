<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>祥_venux</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.venux.cn/"/>
  <updated>2018-06-11T06:09:03.417Z</updated>
  <id>http://www.venux.cn/</id>
  
  <author>
    <name>祥_venux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>12.重构-总结</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/12.%E9%87%8D%E6%9E%84-%E6%80%BB%E7%BB%93/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/12.重构-总结/</id>
    <published>2018-06-14T11:06:26.000Z</published>
    <updated>2018-06-11T06:09:03.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>前面的篇幅只是一个介绍，一个起点，如果没有这些技术，就无法对程序进行改动。有了这些技术，你仍然做不到，但起码可以开始尝试。</p><ul><li>何时应该使用、何时不应该使用；</li><li>何时开始、何时停止；</li><li>何时前进、何时等待；</li></ul><a id="more"></a><h2 id="2-得道"><a href="#2-得道" class="headerlink" title="2. 得道"></a>2. 得道</h2><p>可以自信地停止重构。</p><h2 id="3-学习"><a href="#3-学习" class="headerlink" title="3. 学习"></a>3. 学习</h2><ul><li>随时挑选一个目标；</li><li>没把握就停下来；</li><li>学习原路返回；</li><li>二重奏（多人协作重构、结对编程）；</li></ul><h2 id="4-要点"><a href="#4-要点" class="headerlink" title="4. 要点"></a>4. 要点</h2><ul><li>若代码无法方便添加新特性，请先重构；</li><li>重构技术就是以微小的步伐修改程序；</li><li>傻瓜都能编写计算机可以理解的代码，而唯有能编写人类容易理解的代码才是优秀的程序员；</li><li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本；</li><li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构；</li><li>事不过三，三则重构；</li><li>不要过早发布接口（API），修改代码所有权政策，使得重构更顺畅；</li><li>过多注释情况，请先重构；</li><li>大家都认为会出错的地方，检测是否抛出了预期的异常；</li><li><strong>测试、测试、测试！！！</strong>：<ul><li>重构前，先检查是否有一套可靠的测试机制，且具备自我检验能力；</li><li>自动化测试；</li><li>频繁运行测试；</li><li>单元测试；</li><li>考虑可能的出错边界条件，多测试；</li></ul></li></ul><h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h2><ul><li>大规模的重构只会带来灾难；</li><li>沟通：团队朝着同一个方向一起努力；</li><li>永远不要忘记“两顶帽子”：保持代码的功能完全不变，既不多又不少。对于需要修改的问题，先记下来。重构结束无误后，再进行修改。</li><li><strong>千万别打乱工作。</strong></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第15章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1. 问题&quot;&gt;&lt;/a&gt;1. 问题&lt;/h2&gt;&lt;p&gt;前面的篇幅只是一个介绍，一个起点，如果没有这些技术，就无法对程序进行改动。有了这些技术，你仍然做不到，但起码可以开始尝试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何时应该使用、何时不应该使用；&lt;/li&gt;
&lt;li&gt;何时开始、何时停止；&lt;/li&gt;
&lt;li&gt;何时前进、何时等待；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Gradle</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Gradle/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Gradle/</id>
    <published>2018-06-10T14:05:19.000Z</published>
    <updated>2018-06-21T03:06:44.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>一个自动化构建工具，用于加速开发者生产率，特点：</p><ul><li>Build Anything;</li><li>Automate Everything;</li><li>Deliver Faster;</li></ul><a id="more"></a><h2 id="2-安装-amp-配置-amp-测试-amp-升级"><a href="#2-安装-amp-配置-amp-测试-amp-升级" class="headerlink" title="2. 安装 &amp; 配置 &amp; 测试 &amp; 升级"></a>2. 安装 &amp; 配置 &amp; 测试 &amp; 升级</h2><h3 id="2-1-前提"><a href="#2-1-前提" class="headerlink" title="2.1 前提"></a>2.1 前提</h3><p>JDK 1.7 版本以上。</p><h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><ul><li>通过包管理工具（SDKMAN、Homebrew、Scoop、Chocolatey、MacPorts）安装，具体参加<a href="https://gradle.org/install/#helpful-information" target="_blank" rel="noopener">官网</a>；</li><li>手动安装，下载二进制压缩包、解压到指定目录；</li></ul><h3 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h3><p>将 $GradlePaht\bin 添加到 Path 环境变量中；</p><h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><p>gradle -v</p><h3 id="2-5-升级"><a href="#2-5-升级" class="headerlink" title="2.5 升级"></a>2.5 升级</h3><p>使用 Gradle Wrapper 可方便快捷升级 Gradle。具体命令：<code>gradle wrapper --gradle-version=4.8 --distribution-type=bin</code>。</p><h3 id="2-6-Gradle-文件结构"><a href="#2-6-Gradle-文件结构" class="headerlink" title="2.6 Gradle 文件结构"></a>2.6 Gradle 文件结构</h3><ul><li>build.gradle：构建 Gradle 脚本；</li><li>settings.gradle：指定哪些项目需要构建，可配置多个项目；</li><li>gradle<ul><li>wrapper<ul><li>gradle-wrapper.jar：包含下载 Gradle 发布包的编译后代码；</li><li>gradle-wrapper.properties：运行时配置；</li></ul></li></ul></li><li>gradlew：Unix 系统的启动脚本；</li><li>gradlew.bat：Windows 系统的启动脚本；</li></ul><h2 id="3-Gradle-Wrapper（简称-Wrapper）"><a href="#3-Gradle-Wrapper（简称-Wrapper）" class="headerlink" title="3. Gradle Wrapper（简称 Wrapper）"></a>3. Gradle Wrapper（简称 Wrapper）</h2><p><strong>推荐使用 Gradle Wrapper 来执行 Gradle 构建。</strong>它是一串脚本用于动态调用指定版本的 Gradle，若不存在，则先下载。这样，开发者可快速开始和运行 Gradle 项目，而不必按照手册安装流程，从而节约时间和金钱。具体流程如下图：<br><img src="https://docs.gradle.org/4.8/userguide/img/wrapper-workflow.png" alt="Gradle Wrapper"></p><h3 id="3-1-优点"><a href="#3-1-优点" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><ul><li>标准化指定 Gradle 版本的项目，使得构建更加可靠和健壮。</li><li>在不同环境或不同用户之间，提供多个版本 Gradle，更加简单方便；</li><li>标准化；</li><li>可靠性；</li><li>可控制性；</li><li>健壮性；</li></ul><h3 id="3-2-新建-Gradle-Wrapper"><a href="#3-2-新建-Gradle-Wrapper" class="headerlink" title="3.2 新建 Gradle Wrapper"></a>3.2 新建 Gradle Wrapper</h3><p>通常要生成 Wrapper 文件需要向安装一个 Gradle，庆幸的是这是一次性的。每个 Gradle 都自带一个叫 wrapper 的任务。<br>运行 <code>gradle wrapper</code> 命令用以生成 Wrapper 文件，具体路径 <code>gradle/wrapper</code>。</p><p><code>注意：</code>若所有开发者和环境均需使用 Wrapper 文件，请将其添加到版本管理工具中。部分公司不允许将二进制文件添加到版本管理工具，这样就没其他解决方案了。</p><h4 id="3-2-1-参数配置选项："><a href="#3-2-1-参数配置选项：" class="headerlink" title="3.2.1 参数配置选项："></a>3.2.1 参数配置选项：</h4><ul><li><code>--gradle-version</code>：指定 Gradle 版本。</li><li><code>--distribution-type</code>：发布包类型，可选择 <strong>bin</strong> 和 <strong>all</strong>。默认为 <strong>bin</strong>。</li><li><code>--gradle-distribution-url</code>：发布包地址，该选项会忽略<code>--gradle-version</code>和<code>--distribution-type</code>参数。</li><li><code>--gradle-distribution-sha256-sum</code>：校验发布包 SHA256 HASH 码。</li></ul><p><code>示例</code>：gradle wrapper –gradle-version 4.0 –distribution-type all </p><h4 id="3-2-2-gradle-wrapper-properties文件"><a href="#3-2-2-gradle-wrapper-properties文件" class="headerlink" title="3.2.2 gradle-wrapper.properties文件"></a>3.2.2 gradle-wrapper.properties文件</h4><p>主要用以存储 Gradle 发布包信息，具体如下：</p><ul><li>Gradle 发布包的服务网路路径；</li><li>Gradle 发布包的类型，默认为 <code>-bin</code> 二进制包，只包括运行时而不包括示例代码和文档；</li><li>Gradle 发布包的版本，默认为生成 Wrapper 文件时的版本；</li></ul><h3 id="3-3-使用-Gradle-Wrapper"><a href="#3-3-使用-Gradle-Wrapper" class="headerlink" title="3.3 使用 Gradle Wrapper"></a>3.3 使用 Gradle Wrapper</h3><p>根据不同系统，运行 <code>gradlew</code> 或 <code>gradlew.bat</code> 脚本来取代 <code>gradle</code> 命令。<br><code>ps</code>：</p><ul><li>若本机未装配置版本的 Gradle，则会自动下载并保持到本机中。若配置未变，则复用。</li><li>多个项目可能分别有 Wrapper 脚本，请确认执行正确的脚本。</li></ul><h3 id="3-4-升级-Gradle-Wrapper"><a href="#3-4-升级-Gradle-Wrapper" class="headerlink" title="3.4 升级 Gradle Wrapper"></a>3.4 升级 Gradle Wrapper</h3><ul><li>手动修改配置文件<code>gradle-wrapper.properties</code>的<code>distributionUrl</code>属性；</li><li><strong>推荐</strong>执行<code>gradle wrapper</code> task 时，指定版本信息，默认为当前版本；</li></ul><h3 id="3-5-自定义-Gradle-Wrapper"><a href="#3-5-自定义-Gradle-Wrapper" class="headerlink" title="3.5 自定义 Gradle Wrapper"></a>3.5 自定义 Gradle Wrapper</h3><p>默认设置可满足大多数要求，然而可通过修改<code>build.gradle</code>配置来自定义相关配置。<br>块节点为<code>wrapper</code>，具体参数详情请参考<a href="https://docs.gradle.org/4.8/dsl/org.gradle.api.tasks.wrapper.Wrapper.html" target="_blank" rel="noopener">Wrapper</a>。</p><h2 id="4-创建一个新的-Gradle-构建"><a href="#4-创建一个新的-Gradle-构建" class="headerlink" title="4. 创建一个新的 Gradle 构建"></a>4. 创建一个新的 Gradle 构建</h2><h3 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h3><p><code>gradle init</code>命令，该命令可<a href="https://docs.gradle.org/4.7/userguide/build_init_plugin.html?&amp;_ga=2.66304238.1375004092.1528446888-1875152485.1526436983#sec:build_init_types" target="_blank" rel="noopener">创建不同类型的项目</a>，且可将 Maven 项目（pom.xml）转换为 Gradle 项目。</p><h3 id="4-2-创建-task"><a href="#4-2-创建-task" class="headerlink" title="4.2 创建 task"></a>4.2 创建 task</h3><p>Gradle 提供一系列 API（使用 Groovy 或 基于 Kotlin 的 DSL 语言） 用于创建和配置 task。一个 Project 包括一个 Task 集合，每个单独提供一些基础功能。<a href="https://docs.gradle.org/4.7/userguide/more_about_tasks.html" target="_blank" rel="noopener">具体详情</a><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> <span class="keyword">copy</span>(type: <span class="keyword">Copy</span>, <span class="keyword">group</span>: <span class="string">"Custom"</span>, <span class="keyword">description</span>: <span class="string">"Copies sources to the dest directory"</span>) &#123;</span><br><span class="line">    <span class="keyword">from</span> <span class="string">"src"</span></span><br><span class="line">    <span class="keyword">into</span> <span class="string">"dest"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-3-应用插件"><a href="#4-3-应用插件" class="headerlink" title="4.3 应用插件"></a>4.3 应用插件</h3><p>Gradle 提供一系列<a href="http://plugins.gradle.org/?_ga=2.27464572.1375004092.1528446888-1875152485.1526436983" target="_blank" rel="noopener">插件</a>。<br><code>ps</code>：plugins{} 代码块放置在配置文件最上方。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins&#123;</span><br><span class="line">    id <span class="string">"base"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-查看可用的-task"><a href="#4-4-查看可用的-task" class="headerlink" title="4.4 查看可用的 task"></a>4.4 查看可用的 task</h3><p><code>gradle tasks</code> 命令</p><h3 id="4-5-分析-amp-调试构建"><a href="#4-5-分析-amp-调试构建" class="headerlink" title="4.5 分析 &amp; 调试构建"></a>4.5 分析 &amp; 调试构建</h3><p>Gradle 提供一个叫<code>build scan</code>（专业版功能）的方式用于构建过程可视化。通过使用<code>--scan</code>命令或者对项目应用<code>scan</code>插件即可。</p><h3 id="4-6-查看可用的-properties"><a href="#4-6-查看可用的-properties" class="headerlink" title="4.6 查看可用的 properties"></a>4.6 查看可用的 properties</h3><p><code>gradle properties</code> 命令</p><h2 id="5-创建构建浏览（Build-Scans）"><a href="#5-创建构建浏览（Build-Scans）" class="headerlink" title="5. 创建构建浏览（Build Scans）"></a>5. 创建构建浏览（Build Scans）</h2><p>构建浏览是一个用于展示构建的 what happened and why 的工具，具有可分享，集中管理特性。可免费发布到 <a href="https://scans.gradle.com" target="_blank" rel="noopener">https://scans.gradle.com</a>。方式：</p><ul><li><code>--scan</code>命令参数；</li><li>插件  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.gradle.build-scan'</span> version <span class="string">'1.13.3'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>同意许可协议，或者直接配置好<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buildScan &#123;</span><br><span class="line">    termsOfServiceUrl = <span class="string">'https://gradle.com/terms-of-service'</span></span><br><span class="line">    termsOfServiceAgree = <span class="string">'yes'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对所有构建进行默认配置 build scan，在<code>~/.gradle/init.d</code>目录中创建 gradle 文件用于默认 build。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">initscript &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.gradle:build-scan-plugin:1.13.3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rootProject &#123;</span><br><span class="line">    apply plugin: com.gradle.scan.plugin.BuildScanPlugin</span><br><span class="line"></span><br><span class="line">    buildScan &#123;</span><br><span class="line">        termsOfServiceUrl = <span class="string">'https://gradle.com/terms-of-service'</span></span><br><span class="line">        termsOfServiceAgree = <span class="string">'yes'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://docs.gradle.com/build-scan-plugin" target="_blank" rel="noopener">官方用户手册</a></p><h2 id="6-迁移-Maven-至-Gradle"><a href="#6-迁移-Maven-至-Gradle" class="headerlink" title="6. 迁移 Maven 至 Gradle"></a>6. 迁移 Maven 至 Gradle</h2><h3 id="6-1-自动转换"><a href="#6-1-自动转换" class="headerlink" title="6.1 自动转换"></a>6.1 自动转换</h3><p><code>gradle init</code>命令：该命令允许自动将 Maven 项目转换为 Gradle 项目。<br><code>ps</code>：</p><ul><li>自动转换中组件不会自动转换，或有问题，需手动处理。</li><li>如果幸运地转换成功，可使用<code>gradle build</code>测试。</li></ul><p>具体迁移信息详见<a href="https://guides.gradle.org/migrating-from-maven" target="_blank" rel="noopener">迁移 Maven 至 Gradle</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;一个自动化构建工具，用于加速开发者生产率，特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build Anything;&lt;/li&gt;
&lt;li&gt;Automate Everything;&lt;/li&gt;
&lt;li&gt;Deliver Faster;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
      <category term="工具" scheme="http://www.venux.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>10.重构-重构、复用与现实（William Opdyke）</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/10.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E3%80%81%E5%A4%8D%E7%94%A8%E4%B8%8E%E7%8E%B0%E5%AE%9E/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/10.重构-重构、复用与现实/</id>
    <published>2018-06-10T11:06:26.000Z</published>
    <updated>2018-06-11T06:09:03.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-重构"><a href="#1-重构" class="headerlink" title="1. 重构"></a>1. 重构</h2><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h3><ul><li>生产进度的压力：<ul><li>重写整个程序（理想情况）；</li><li>复制、修改现有系统；  </li></ul></li><li>不知道如何重构；</li><li>如果利益是长远的，为什么现在做呢？可能收获利益之时，就已经不在职位上了；</li><li>代码重构是额外工作，老板看不到付出；</li><li>重构可能破坏现有程序；</li></ul><h3 id="1-2-回答"><a href="#1-2-回答" class="headerlink" title="1.2 回答"></a>1.2 回答</h3><ul><li>重构可以带来短期利益和长期利益。</li><li>已有重构工具和技术，可快速，无痛苦完成；</li><li>重构虽然花费精力和时间开销，当可在其他阶段减小相应开销；</li><li>当重构成为软件开发规则的一部分时，人们就觉得它必不可少；</li></ul><a id="more"></a><h2 id="2-做法"><a href="#2-做法" class="headerlink" title="2. 做法"></a>2. 做法</h2><ul><li>了解如何重构、在哪儿重构；</li><li>合理利用重构工具；</li><li>遵守重构规则；</li><li>团队保持共识；</li></ul><h2 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h2><p>安全性是令人关系的议题，特别是大型系统。许多应用程序由于财政、法律和道德伦理的压力，需要不间断、可靠、不出错的提供服务。</p><h2 id="3-1-如何进行安全重构"><a href="#3-1-如何进行安全重构" class="headerlink" title="3.1 如何进行安全重构"></a>3.1 如何进行安全重构</h2><ul><li>选择：<ul><li>相信编码功力；</li><li>相信编译器能捕捉错误；</li><li>相信测试能测出错误；</li><li>相信代码复审能捕捉错误；</li></ul></li><li>局限性：<ul><li>人人都可能犯错；</li><li>一些微妙错误编译器无法捕捉；</li><li>测试不可能覆盖所有情况，测出所有问题；</li><li>代码复审很可能没有，或出错，或没找到错误；</li></ul></li><li>方案：<ul><li>定义并快速实现一个重构工具的原型，用以检查某项重构是否可以安全地施加于程序上。若可能，则重构。这避免了大量可能因为人为错误引入的 bug。</li></ul></li></ul><h2 id="4-复用"><a href="#4-复用" class="headerlink" title="4. 复用"></a>4. 复用</h2><h3 id="4-1-问题（类似于重构）"><a href="#4-1-问题（类似于重构）" class="headerlink" title="4.1 问题（类似于重构）"></a>4.1 问题（类似于重构）</h3><ul><li>不知道“该复用什么”或“如何复用”；</li><li>对采用复用方法缺乏动力，除非有短期利益；</li><li>开销、学习曲线和探索成本；</li><li>项目压力；</li></ul><h3 id="4-2-回答（原则）"><a href="#4-2-回答（原则）" class="headerlink" title="4.2 回答（原则）"></a>4.2 回答（原则）</h3><ul><li>对员工进行培训；</li><li>尽量获取短期利益；</li><li>减少开销；</li><li>安全引入新技术；<br><code>ps</code>：这些不仅仅可用于重构和软件复用，还可用于技术传播。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第13章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-重构&quot;&gt;&lt;a href=&quot;#1-重构&quot; class=&quot;headerlink&quot; title=&quot;1. 重构&quot;&gt;&lt;/a&gt;1. 重构&lt;/h2&gt;&lt;h3 id=&quot;1-1-问题&quot;&gt;&lt;a href=&quot;#1-1-问题&quot; class=&quot;headerlink&quot; title=&quot;1.1 问题&quot;&gt;&lt;/a&gt;1.1 问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;生产进度的压力：&lt;ul&gt;
&lt;li&gt;重写整个程序（理想情况）；&lt;/li&gt;
&lt;li&gt;复制、修改现有系统；  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不知道如何重构；&lt;/li&gt;
&lt;li&gt;如果利益是长远的，为什么现在做呢？可能收获利益之时，就已经不在职位上了；&lt;/li&gt;
&lt;li&gt;代码重构是额外工作，老板看不到付出；&lt;/li&gt;
&lt;li&gt;重构可能破坏现有程序；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-回答&quot;&gt;&lt;a href=&quot;#1-2-回答&quot; class=&quot;headerlink&quot; title=&quot;1.2 回答&quot;&gt;&lt;/a&gt;1.2 回答&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;重构可以带来短期利益和长期利益。&lt;/li&gt;
&lt;li&gt;已有重构工具和技术，可快速，无痛苦完成；&lt;/li&gt;
&lt;li&gt;重构虽然花费精力和时间开销，当可在其他阶段减小相应开销；&lt;/li&gt;
&lt;li&gt;当重构成为软件开发规则的一部分时，人们就觉得它必不可少；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>11.重构-重构工具（Don Roberts 和 John Brant）</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/11.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/11.重构-重构工具/</id>
    <published>2018-06-10T11:06:26.000Z</published>
    <updated>2018-06-11T06:09:03.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1. 总结"></a>1. 总结</h2><p>作者那时写《重构》一书时，还未像现如今一样。现在，各类 IDE 都提供重构工具辅助重构，而不用自己去实现一整套重构工具或手动重构了。所以，现在程序员自然而然的乐意像整理代码一样去整理系统，即重构。这样，对代码的可维护性、可复用性和可理解性大大加强。</p><a id="more"></a><h2 id="2-辅助工具"><a href="#2-辅助工具" class="headerlink" title="2. 辅助工具"></a>2. 辅助工具</h2><ul><li>自动化重构工具；</li><li>自动化测试工具；</li></ul><h2 id="3-重构工具的技术标准"><a href="#3-重构工具的技术标准" class="headerlink" title="3. 重构工具的技术标准"></a>3. 重构工具的技术标准</h2><ul><li>程序数据库；</li><li>解析树；</li><li>准确性；</li></ul><h2 id="4-重构工具的实用标准"><a href="#4-重构工具的实用标准" class="headerlink" title="4. 重构工具的实用标准"></a>4. 重构工具的实用标准</h2><ul><li>速度；</li><li>撤销；</li><li>与其他工具集成；</li><li>易用性（个人添加）；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第14章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-总结&quot;&gt;&lt;a href=&quot;#1-总结&quot; class=&quot;headerlink&quot; title=&quot;1. 总结&quot;&gt;&lt;/a&gt;1. 总结&lt;/h2&gt;&lt;p&gt;作者那时写《重构》一书时，还未像现如今一样。现在，各类 IDE 都提供重构工具辅助重构，而不用自己去实现一整套重构工具或手动重构了。所以，现在程序员自然而然的乐意像整理代码一样去整理系统，即重构。这样，对代码的可维护性、可复用性和可理解性大大加强。&lt;/p&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>09.重构-大型重构</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/09.%E9%87%8D%E6%9E%84-%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/09.重构-大型重构/</id>
    <published>2018-06-08T15:06:26.000Z</published>
    <updated>2018-06-11T06:09:03.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-重构特点"><a href="#1-重构特点" class="headerlink" title="1. 重构特点"></a>1. 重构特点</h2><ul><li>大型重构中，情况复杂，变化多样性，没有准确的重构步骤，只能根据实际情况考虑分析；</li><li>大型重构耗时长，需合理安排工作，只在需要添加新功能或修补错误时才重构；</li><li>不必一开始就完成整个系统的重构，而应该只需满足任务需求就可；</li><li>大规模重构时，整个团队需建立共识。</li></ul><a id="more"></a><h2 id="2-问题及方案"><a href="#2-问题及方案" class="headerlink" title="2. 问题及方案"></a>2. 问题及方案</h2><ul><li>混乱的继承体系：Tease Apart Inheritance（梳理并分解继承体系）；</li><li>过程式代码：Convert Procedural Design to Objects（将面向过程设计改为面向对象设计）；</li><li>传统两层结构（用户界面和数据库），业务代码和界面耦合：Separate Domain from Presentation；</li><li>过于复杂的类：Extract Hierarchy；</li></ul><h2 id="3-Tease-Apart-Inheritance（梳理并分解继承体系）"><a href="#3-Tease-Apart-Inheritance（梳理并分解继承体系）" class="headerlink" title="3. Tease Apart Inheritance（梳理并分解继承体系）"></a>3. Tease Apart Inheritance（梳理并分解继承体系）</h2><p>问题：某个继承体系同时承担多种职责。<br>建立多个继承体系，并使用委托（依赖）关系用于调用。<br><code>ps</code>：</p><ul><li>参考抽象工厂模式（创建型）、桥接模式（结构性、抽象与实现分离）；</li><li>注意耦合关系；</li></ul><h2 id="4-Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）"><a href="#4-Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）" class="headerlink" title="4. Convert Procedural Design to Objects（将过程化设计转换为对象设计）"></a>4. Convert Procedural Design to Objects（将过程化设计转换为对象设计）</h2><p>将数据记录变为对象，将大块的行为拆分成小块，并将行为移动到对象中。</p><h2 id="5-Separate-Domain-from-Presentation（将领域和表现分离）"><a href="#5-Separate-Domain-from-Presentation（将领域和表现分离）" class="headerlink" title="5. Separate Domain from Presentation（将领域和表现分离）"></a>5. Separate Domain from Presentation（将领域和表现分离）</h2><p>将领域逻辑和表现界面分离。<br><code>ps</code>：</p><ul><li>MVC（模型-视图-控制器）模式：最核心价值在于将用户界面（视图、展现层）和领域逻辑（模型）分离。</li></ul><h2 id="6-Extract-Hierarchy（提炼继承体系）"><a href="#6-Extract-Hierarchy（提炼继承体系）" class="headerlink" title="6. Extract Hierarchy（提炼继承体系）"></a>6. Extract Hierarchy（提炼继承体系）</h2><p>问题：一个类承担了太多职责，其中一部分工作是以大量的条件表达式来完成的。<br>建立继承体系，以一个子类来表示一种特殊情况。<br><code>ps</code>：</p><ul><li>只有当条件逻辑在对象的整个生命周期保持不变时，才可使用该策略。</li><li>该策略是一项大型重构，请先梳理清晰，明确步骤后，再动手处理。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第12章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-重构特点&quot;&gt;&lt;a href=&quot;#1-重构特点&quot; class=&quot;headerlink&quot; title=&quot;1. 重构特点&quot;&gt;&lt;/a&gt;1. 重构特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;大型重构中，情况复杂，变化多样性，没有准确的重构步骤，只能根据实际情况考虑分析；&lt;/li&gt;
&lt;li&gt;大型重构耗时长，需合理安排工作，只在需要添加新功能或修补错误时才重构；&lt;/li&gt;
&lt;li&gt;不必一开始就完成整个系统的重构，而应该只需满足任务需求就可；&lt;/li&gt;
&lt;li&gt;大规模重构时，整个团队需建立共识。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>08.重构-处理类的继承关系(generalization)</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/08.%E9%87%8D%E6%9E%84-%E5%A4%84%E7%90%86%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/08.重构-处理类的继承关系/</id>
    <published>2018-06-07T15:06:26.000Z</published>
    <updated>2018-06-11T06:09:03.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>字段位置不正确：Pull Up Field、Pull Down Field；</li><li>函数位置不正确：Pull Up Method、Pull Down Method；</li><li>构造函数：Pull Up Constructor Body（向上）、Replace Constructor with Factory Method；</li><li>函数大体相同、细节不同：Form Template Method；</li><li>改变继承体系：Extract Subclass、Extract Superclass、Extract Interface；</li><li>继承体系部分类无用：Collapse（瓦解） Hierarchy（层次结构）；</li><li>委托替代继承：Replace Inheritance with Delegation；</li><li>继承替代委托：Replace Delegation with Inheritance；</li></ul><a id="more"></a><h2 id="2-Pull-Up-Field-Method（字段-函数上移）"><a href="#2-Pull-Up-Field-Method（字段-函数上移）" class="headerlink" title="2. Pull Up Field/Method（字段/函数上移）"></a>2. Pull Up Field/Method（字段/函数上移）</h2><p>将多个子类的相同字段/函数移到超类。</p><h2 id="3-Pull-Down-Field-Method（字段-函数下移）"><a href="#3-Pull-Down-Field-Method（字段-函数下移）" class="headerlink" title="3. Pull Down Field/Method（字段/函数下移）"></a>3. Pull Down Field/Method（字段/函数下移）</h2><p>超类的字段/函数只与部分（而非全部）子类有关，移动到相关子类中。</p><h2 id="4-Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#4-Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="4. Pull Up Constructor Body（构造函数本体上移）"></a>4. Pull Up Constructor Body（构造函数本体上移）</h2><p>多个子类的构造函数相同，将主体移动到超类构造函数中，并在子类中调用它。</p><h2 id="5-Replace-Constructor-with-Factory-Method（使用工厂方法替代构造函数）"><a href="#5-Replace-Constructor-with-Factory-Method（使用工厂方法替代构造函数）" class="headerlink" title="5. Replace Constructor with Factory Method（使用工厂方法替代构造函数）"></a>5. Replace Constructor with Factory Method（使用工厂方法替代构造函数）</h2><p>由于无法将构造函数本体下移，故改为使用工厂方法模式。</p><h2 id="6-Extract-Subclass（提炼子类）"><a href="#6-Extract-Subclass（提炼子类）" class="headerlink" title="6. Extract Subclass（提炼子类）"></a>6. Extract Subclass（提炼子类）</h2><p>问题：类中的某些特性只被某些（而非全部）实例使用。<br>新建一个子类，移动特性到子类中。<br><code>ps</code>：Extract Class 是另一种选择，两者抉择之处在于委托和继承之间的选择。</p><h2 id="7-Extract-SuperClass（提炼超类）"><a href="#7-Extract-SuperClass（提炼超类）" class="headerlink" title="7. Extract SuperClass（提炼超类）"></a>7. Extract SuperClass（提炼超类）</h2><p>为两个相似的类建立一个超类，将相同特性移至超类。</p><h2 id="8-Extract-Interface（提炼接口）"><a href="#8-Extract-Interface（提炼接口）" class="headerlink" title="8. Extract Interface（提炼接口）"></a>8. Extract Interface（提炼接口）</h2><p>多个类有相似的行为，或多个类的接口有相似部分，将相同的行为提炼到一个独立的接口中。</p><h2 id="9-Collapse-Hierarchy（折叠继承体系）"><a href="#9-Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="9. Collapse Hierarchy（折叠继承体系）"></a>9. Collapse Hierarchy（折叠继承体系）</h2><p>问题：超类和子类之间无太大区别。<br>将它们合为一体。</p><h2 id="10-Form-Template-Method（塑造模板函数）"><a href="#10-Form-Template-Method（塑造模板函数）" class="headerlink" title="10. Form Template Method（塑造模板函数）"></a>10. Form Template Method（塑造模板函数）</h2><p>问题：子类的某些函数以相同顺序执行类似操作，细节有所不同。<br>将这些操作分别放进独立函数中，并保持相同签名。而后将原函数提炼到超类中。<br><code>ps</code>：即模板方法模式。</p><h2 id="11-Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#11-Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="11. Replace Inheritance with Delegation（以委托取代继承）"></a>11. Replace Inheritance with Delegation（以委托取代继承）</h2><p>问题：某个子类只使用超类的一部分，或根本不需要继承而来的数据。<br>在子类中新建一个字段引用超类，调整子类函数，而后让它调用超类，最后去除两者之间的继承关系。<br><code>ps</code>：此处的委托其实应该理解为委托调用关系，即依赖关系，而非 C# 的委托。</p><h2 id="12-Replace-Delegation-with-Inheritance（以继承取代委托）"><a href="#12-Replace-Delegation-with-Inheritance（以继承取代委托）" class="headerlink" title="12. Replace Delegation with Inheritance（以继承取代委托）"></a>12. Replace Delegation with Inheritance（以继承取代委托）</h2><p>问题：两个类之间使用委托关系，并经常为了<strong>整个接口（即所有函数）</strong>编写许多极其简单的委托函数。<br>让委托类继承被委托类。<br><code>ps</code>：</p><ul><li>该重构手法与 Replace Inheritance with Delegation 恰恰相反。</li><li>如果你并没有使用被委托类的所有函数，就不该使用该重构手法。</li><li>被委托对象被不止一个对象共享，而且被委托对象是可变的，此时就不该使用该重构手法。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第11章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;字段位置不正确：Pull Up Field、Pull Down Field；&lt;/li&gt;
&lt;li&gt;函数位置不正确：Pull Up Method、Pull Down Method；&lt;/li&gt;
&lt;li&gt;构造函数：Pull Up Constructor Body（向上）、Replace Constructor with Factory Method；&lt;/li&gt;
&lt;li&gt;函数大体相同、细节不同：Form Template Method；&lt;/li&gt;
&lt;li&gt;改变继承体系：Extract Subclass、Extract Superclass、Extract Interface；&lt;/li&gt;
&lt;li&gt;继承体系部分类无用：Collapse（瓦解） Hierarchy（层次结构）；&lt;/li&gt;
&lt;li&gt;委托替代继承：Replace Inheritance with Delegation；&lt;/li&gt;
&lt;li&gt;继承替代委托：Replace Delegation with Inheritance；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>07.重构-简化函数调用</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/07.%E9%87%8D%E6%9E%84-%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/07.重构-简化函数调用/</id>
    <published>2018-06-06T15:06:26.000Z</published>
    <updated>2018-06-11T06:09:03.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>函数名称不清晰：Rename Method；</li><li>参数不明确：Add Parameter、Remove Parameter；</li><li>参数过多：Preserve Whole Object、Introduce Parameter Object； </li><li>函数参数来自该函数可以获取的对象：Replace Parameter with Method；</li><li>参数被用于条件表达式：Replace Parameter with Explicit Method；</li><li>多个相似函数添加参数：Parameterize Method；</li><li>查询命令函数分离：Separate Query from Modifier；</li><li>不必要的暴露：Hide Method、Remove Setting Method；</li><li>隐藏创建对象：Replace Constructor with Factory Method；</li><li>转型：Encapsulate Downcast；</li><li>错误码、异常、测试：Replace Error Code with Exception、Replace Exception with Test；</li></ul><a id="more"></a><h2 id="2-Rename-Method（函数改名）"><a href="#2-Rename-Method（函数改名）" class="headerlink" title="2. Rename Method（函数改名）"></a>2. Rename Method（函数改名）</h2><p>修改函数名称，更加清晰明了。</p><h2 id="3-Add-Parameter（添加参数）"><a href="#3-Add-Parameter（添加参数）" class="headerlink" title="3. Add Parameter（添加参数）"></a>3. Add Parameter（添加参数）</h2><p>为函数添加参数，带进所需信息。</p><h3 id="3-1-动机"><a href="#3-1-动机" class="headerlink" title="3.1 动机"></a>3.1 动机</h3><p>请先确认是否一定需要添加新参数：</p><ul><li>你能从已有参数得到所需信息么？</li><li>有可能通过某个函数得到所需信息么？</li><li>这个函数是否应该属于拥有该信息的对象所有？</li><li>现有参数过多，是否考虑使用 Introduce Parameter Object？<br><code>ps</code>：若旧函数是接口一部分，不好删除，请标记为 deprecated（不赞成）。</li></ul><h2 id="4-Remove-Parameter（移除参数）"><a href="#4-Remove-Parameter（移除参数）" class="headerlink" title="4. Remove Parameter（移除参数）"></a>4. Remove Parameter（移除参数）</h2><p>将不需要的参数移除。</p><h2 id="5-Separate-Query-from-Modifer（将查询函数和修改函数分离）"><a href="#5-Separate-Query-from-Modifer（将查询函数和修改函数分离）" class="headerlink" title="5. Separate Query from Modifer（将查询函数和修改函数分离）"></a>5. Separate Query from Modifer（将查询函数和修改函数分离）</h2><p>建立两个不同的函数，一个负责查询，另一个负责修改。</p><h3 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h3><ul><li>明确表示“有副作用”和“无副作用”两种函数之间的差异；</li><li>任何有返回值的函数，都不应该有<strong>看得到</strong>（提取出查询函数，将结果缓存到某个字段）的副作用。<br><code>ps</code>：多线程环境下，建立第三个函数来做“查询-修改”，该还是调用独立的查询函数和修改函数，并被声明为 synchronized。若为声明为 synchronized，则将它们的可见范围限制在包级别或 private 级别。如此就能保证安全、同步的操作。</li></ul><h2 id="6-Parameterize-Method（令函数携带参数）"><a href="#6-Parameterize-Method（令函数携带参数）" class="headerlink" title="6. Parameterize Method（令函数携带参数）"></a>6. Parameterize Method（令函数携带参数）</h2><p>建立单一函数，以参数表达那些不同的值。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><p>多个函数处理类似工作，仅因为值不同而略有不同。</p><h2 id="7-Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#7-Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="7. Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>7. Replace Parameter with Explicit Methods（以明确函数取代参数）</h2><p>问题：函数完全取决于参数值而采取不同行为。<br>针对该参数的的每一个可能值，建立一个独立函数。<br><code>ps</code>：</p><ul><li>与 Parameterize Method 正好相反。</li><li>若参数值对函数行为没太多影像，就不该使用该重构手法。</li><li>若需要条件判断，考虑使用 Replace Conditional with Polymorphism。</li></ul><h2 id="8-Preserve-Whole-Object（保持对象完整）"><a href="#8-Preserve-Whole-Object（保持对象完整）" class="headerlink" title="8. Preserve Whole Object（保持对象完整）"></a>8. Preserve Whole Object（保持对象完整）</h2><p>将从某个对象取出某些值作为参数传递改为直接传递整个对象。<br><code>ps</code>：</p><ul><li>两面性，该重构手法会产生依赖关系，请考虑后在使用。</li><li>先考虑 Move Method。</li></ul><h2 id="9-Replace-Parameter-with-Methods（以函数取代参数）"><a href="#9-Replace-Parameter-with-Methods（以函数取代参数）" class="headerlink" title="9. Replace Parameter with Methods（以函数取代参数）"></a>9. Replace Parameter with Methods（以函数取代参数）</h2><p>问题：对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能调用前一个函数。<br>让参数接受者去除该项参数，直接调用前一个函数。</p><h3 id="9-1-动机"><a href="#9-1-动机" class="headerlink" title="9.1 动机"></a>9.1 动机</h3><p>如果函数可以通过其他途径获取参数，就不应该通过参数传递。应尽可能缩短参数列的长度。</p><h2 id="10-Introduce-Parameter-Object（引入参数对象）"><a href="#10-Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="10. Introduce Parameter Object（引入参数对象）"></a>10. Introduce Parameter Object（引入参数对象）</h2><p>以一个对象取代这些参数。</p><h3 id="10-1-动机"><a href="#10-1-动机" class="headerlink" title="10.1 动机"></a>10.1 动机</h3><p>特定的一组参数总是被一起传递，好几个函数都使用这组参数。这就是所谓的 Data Clumps（数据泥团）。</p><h2 id="11-Remove-Setting-Method（移除设值函数）"><a href="#11-Remove-Setting-Method（移除设值函数）" class="headerlink" title="11. Remove Setting Method（移除设值函数）"></a>11. Remove Setting Method（移除设值函数）</h2><p>若某个字段在对象创建后就不再改变，则应移除该字段的所有设值函数。</p><h2 id="12-Hide-Method（隐藏函数）"><a href="#12-Hide-Method（隐藏函数）" class="headerlink" title="12. Hide Method（隐藏函数）"></a>12. Hide Method（隐藏函数）</h2><p>该函数不被外界使用，请设为 private。</p><h2 id="13-Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#13-Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="13. Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>13. Replace Constructor with Factory Method（以工厂函数取代构造函数）</h2><p>将构造函数替换为工厂函数。</p><h3 id="13-1-动机"><a href="#13-1-动机" class="headerlink" title="13.1 动机"></a>13.1 动机</h3><ul><li>在派生类中以工程函数取代类型码；</li><li>以明确函数创建子类；</li></ul><h2 id="14-Encapsulate-Downcast（封装向下转型）"><a href="#14-Encapsulate-Downcast（封装向下转型）" class="headerlink" title="14. Encapsulate Downcast（封装向下转型）"></a>14. Encapsulate Downcast（封装向下转型）</h2><p>将向下转型动作移到函数中。</p><h2 id="15-Replace-Error-Code-with-Exception（以异常取代错误码）"><a href="#15-Replace-Error-Code-with-Exception（以异常取代错误码）" class="headerlink" title="15. Replace Error Code with Exception（以异常取代错误码）"></a>15. Replace Error Code with Exception（以异常取代错误码）</h2><p>某个函数返回一个特定的代码，用以表示某种错误情况。改用异常。</p><h2 id="16-Replace-Exception-with-Test（以测试取代异常）"><a href="#16-Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="16. Replace Exception with Test（以测试取代异常）"></a>16. Replace Exception with Test（以测试取代异常）</h2><p>问题：面对一个调用者可以预先检查的条件，你抛出了一个异常。<br>修改调用者，使它在调用函数之前先做检查。</p><h3 id="16-1-动机"><a href="#16-1-动机" class="headerlink" title="16.1 动机"></a>16.1 动机</h3><ul><li>异常滥用情况，异常只应该被用于意料之外的错误行为，而不应该成为条件检查的替代品。<br><code>ps</code>：我自己的坏习惯就是滥用异常，而且统一捕获。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第10章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;函数名称不清晰：Rename Method；&lt;/li&gt;
&lt;li&gt;参数不明确：Add Parameter、Remove Parameter；&lt;/li&gt;
&lt;li&gt;参数过多：Preserve Whole Object、Introduce Parameter Object； &lt;/li&gt;
&lt;li&gt;函数参数来自该函数可以获取的对象：Replace Parameter with Method；&lt;/li&gt;
&lt;li&gt;参数被用于条件表达式：Replace Parameter with Explicit Method；&lt;/li&gt;
&lt;li&gt;多个相似函数添加参数：Parameterize Method；&lt;/li&gt;
&lt;li&gt;查询命令函数分离：Separate Query from Modifier；&lt;/li&gt;
&lt;li&gt;不必要的暴露：Hide Method、Remove Setting Method；&lt;/li&gt;
&lt;li&gt;隐藏创建对象：Replace Constructor with Factory Method；&lt;/li&gt;
&lt;li&gt;转型：Encapsulate Downcast；&lt;/li&gt;
&lt;li&gt;错误码、异常、测试：Replace Error Code with Exception、Replace Exception with Test；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>其他</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%85%B6%E4%BB%96/"/>
    <id>http://www.venux.cn//posts/05.编程思想/其他/</id>
    <published>2018-06-06T11:34:46.000Z</published>
    <updated>2018-06-11T06:09:00.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查询命令职责分离（CQRS）"><a href="#1-查询命令职责分离（CQRS）" class="headerlink" title="1. 查询命令职责分离（CQRS）"></a>1. 查询命令职责分离（CQRS）</h2><p>明确地将“修改对象状态”的函数（修改函数）和“查询对象状态”的函数（查询函数）分开设计。</p><h2 id="2-将复杂的处理过程分解为小函数。"><a href="#2-将复杂的处理过程分解为小函数。" class="headerlink" title="2. 将复杂的处理过程分解为小函数。"></a>2. 将复杂的处理过程分解为小函数。</h2><h2 id="3-任何有返回值的函数，都不应该有看得到的副作用。"><a href="#3-任何有返回值的函数，都不应该有看得到的副作用。" class="headerlink" title="3.任何有返回值的函数，都不应该有看得到的副作用。"></a>3.任何有返回值的函数，都不应该有看得到的副作用。</h2><h2 id="4-Range-模式"><a href="#4-Range-模式" class="headerlink" title="4. Range 模式"></a>4. Range 模式</h2><p>使用范围对象替代多个参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-查询命令职责分离（CQRS）&quot;&gt;&lt;a href=&quot;#1-查询命令职责分离（CQRS）&quot; class=&quot;headerlink&quot; title=&quot;1. 查询命令职责分离（CQRS）&quot;&gt;&lt;/a&gt;1. 查询命令职责分离（CQRS）&lt;/h2&gt;&lt;p&gt;明确地将“修改对象状态”
      
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="设计模式" scheme="http://www.venux.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>06.重构-简化条件表达式</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/06.%E9%87%8D%E6%9E%84-%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/06.重构-简化条件表达式/</id>
    <published>2018-06-05T15:06:26.000Z</published>
    <updated>2018-06-11T06:09:02.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>复杂条件逻辑拆分：Decompose（分解） Conditional；</li><li>代码多次测试结果相同：Consolidate（合并） Conditional Expression；</li><li>条件代码重复：Consolidate Duplicate Conditional Fragments（碎片）；</li><li>“单一出口”特殊情况：Replace Nested Conditional with Guard Clauses；</li><li>去除控制标记：Remove Control Flag；</li><li>switch 语句：Replace Conditional with Polymorphism（多态）；</li><li>去除 Null 检验：Introduce Null Object；</li></ul><a id="more"></a><h2 id="2-Decompose-Conditional（分解条件表达式）"><a href="#2-Decompose-Conditional（分解条件表达式）" class="headerlink" title="2. Decompose Conditional（分解条件表达式）"></a>2. Decompose Conditional（分解条件表达式）</h2><p>从 if-then-else 中分别提炼到独立函数；</p><h2 id="3-Consolidate-Conditional-Expression（合并条件表达式）"><a href="#3-Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="3. Consolidate Conditional Expression（合并条件表达式）"></a>3. Consolidate Conditional Expression（合并条件表达式）</h2><p>将同样结果的条件测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。<br><code>ps</code>:</p><ul><li>类似多个 case 使用同样的代码。</li><li>如果你认为这些检查的确需要彼此独立，就可以不要使用该项重构，不过必须表示清楚自己的意义。</li></ul><h2 id="4-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#4-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="4. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>4. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h2><p>将重复代码提取到条件表达式之外。</p><h2 id="5-Remove-Control-Flag（移除控制标记）"><a href="#5-Remove-Control-Flag（移除控制标记）" class="headerlink" title="5. Remove Control Flag（移除控制标记）"></a>5. Remove Control Flag（移除控制标记）</h2><p>以 break、continue、return 语句取代控制标记。</p><h2 id="6-Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式，防御编程）"><a href="#6-Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式，防御编程）" class="headerlink" title="6. Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式，防御编程）"></a>6. Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式，防御编程）</h2><p>使用卫语句表现所有特殊情况。<br><strong>精髓</strong>：给某一条分支以特别的重视。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><ul><li>条件表达式不同形式：<ul><li>所有分支都是正常行为：使用 if-else；</li><li>只有一种是正常行为，其他都是不正常情况：if-return,XXX；</li></ul></li><li>将条件反转，而后使用该重构手法；</li></ul><h3 id="6-2-示例"><a href="#6-2-示例" class="headerlink" title="6.2 示例"></a>6.2 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">false</span> &amp;&amp; B==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="comment">//Do Here</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(A==<span class="keyword">true</span> &amp;&amp; B==<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#7-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="7. Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>7. Replace Conditional with Polymorphism（以多态取代条件表达式）</h2><p>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。<br><code>ps</code>：多态最根本的好处：根据对象的不同类型（形态）采用不同的行为，而不必编写明显的条件表达式。</p><h3 id="7-1-做法"><a href="#7-1-做法" class="headerlink" title="7.1 做法"></a>7.1 做法</h3><ul><li>建立继承结构<ul><li>Replace Type Code with Subclasses；</li><li>Replace Type Code with State/Strategy；</li></ul></li></ul><h2 id="8-Introduce-Null-Object（引入-Null-对象）"><a href="#8-Introduce-Null-Object（引入-Null-对象）" class="headerlink" title="8. Introduce Null Object（引入 Null 对象）"></a>8. Introduce Null Object（引入 Null 对象）</h2><p>将 null 值替换为 null 对象。<br><code>ps</code>：</p><ul><li>空对象一定是常量，它们的任何成分都不会发生变化。因此，可考虑使用单例模式保证唯一实例。</li><li>本质上来说，Null object 模式属于 Special Case 模式。</li></ul><h2 id="9-Introduce-Assertion（引入断言）"><a href="#9-Introduce-Assertion（引入断言）" class="headerlink" title="9. Introduce Assertion（引入断言）"></a>9. Introduce Assertion（引入断言）</h2><p>以断言明确表现某些用以对程序状态的假设。<br><code>ps</code>：</p><ul><li>断言是个条件表达式，应该总是为真。若失败，则表示程序员犯错了，所以断言的失败会导致一个非受控异常（unchecked exception）。</li><li>断言绝对不能被系统其它部分使用，实际上，最后成品往往需删除断言。</li><li>不要滥用断言，请不要使用它来检查“你认为应该为真”的条件，请只是用它来检查“一定必须为真”的条件。</li><li>如果断言所指示的约束条件不能满足，代码是否仍能正常运行？若可以，则移除断言。</li><li>断言的价值在于：帮助程序员理解代码正确运行的必要条件。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第9章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;复杂条件逻辑拆分：Decompose（分解） Conditional；&lt;/li&gt;
&lt;li&gt;代码多次测试结果相同：Consolidate（合并） Conditional Expression；&lt;/li&gt;
&lt;li&gt;条件代码重复：Consolidate Duplicate Conditional Fragments（碎片）；&lt;/li&gt;
&lt;li&gt;“单一出口”特殊情况：Replace Nested Conditional with Guard Clauses；&lt;/li&gt;
&lt;li&gt;去除控制标记：Remove Control Flag；&lt;/li&gt;
&lt;li&gt;switch 语句：Replace Conditional with Polymorphism（多态）；&lt;/li&gt;
&lt;li&gt;去除 Null 检验：Introduce Null Object；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>04.重构-在对象之间搬移特性</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/04.%E9%87%8D%E6%9E%84-%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/04.重构-在对象之间搬移特性/</id>
    <published>2018-05-31T15:06:26.000Z</published>
    <updated>2018-06-11T06:09:02.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>职责不清晰：Move Field、Move Method；</li><li>类承担过多职责：Extract Class；</li><li>类职责过少：Inline Class；</li><li>类之间关联：Hide Delegate、Remove Middle Man；</li><li>不能访问类的源码，却又想添加职责：Introduce Foreign Method、Introduce Local Extension；</li></ul><a id="more"></a><h2 id="2-Move-Method（搬移函数）"><a href="#2-Move-Method（搬移函数）" class="headerlink" title="2. Move Method（搬移函数）"></a>2. Move Method（搬移函数）</h2><p>问题：类中，有个函数与另一类过多交互。<br>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是直接移除。</p><h3 id="2-1-动机"><a href="#2-1-动机" class="headerlink" title="2.1 动机"></a>2.1 动机</h3><ul><li>类中有太多行为职责；</li><li>类之间太多合作导致高度耦合；</li></ul><h2 id="3-Move-Field（搬移字段）"><a href="#3-Move-Field（搬移字段）" class="headerlink" title="3. Move Field（搬移字段）"></a>3. Move Field（搬移字段）</h2><p>问题：类中，某个字段被另外一个类更多的使用。<br>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。</p><h3 id="3-2-做法"><a href="#3-2-做法" class="headerlink" title="3.2 做法"></a>3.2 做法</h3><ul><li>Self Encapsulate Field：即对字段进行包装，提高 get、set 操作；</li></ul><h2 id="4-Extract-Class（提炼类）"><a href="#4-Extract-Class（提炼类）" class="headerlink" title="4. Extract Class（提炼类）"></a>4. Extract Class（提炼类）</h2><p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p><h3 id="4-1-动机"><a href="#4-1-动机" class="headerlink" title="4.1 动机"></a>4.1 动机</h3><ul><li>类的职责过多；</li><li>类有部分特性需子类化；</li></ul><h2 id="5-Inline-Class（类内联化）"><a href="#5-Inline-Class（类内联化）" class="headerlink" title="5. Inline Class（类内联化）"></a>5. Inline Class（类内联化）</h2><p>将这个类的所有特性搬移到另一个类中，然后移除原类。此手法正好与 Extract Class 相反。</p><h3 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h3><p>一个类不再承担足够职责，不再有单独存在的里有。</p><h2 id="6-Hide-Delegate（隐藏“委托关系”）"><a href="#6-Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="6. Hide Delegate（隐藏“委托关系”）"></a>6. Hide Delegate（隐藏“委托关系”）</h2><p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><p>“封装”意味着每个对象都应该尽可能少了解系统的其他部分。</p><h2 id="7-Remove-Middle-Man（移除中间人）"><a href="#7-Remove-Middle-Man（移除中间人）" class="headerlink" title="7. Remove Middle Man（移除中间人）"></a>7. Remove Middle Man（移除中间人）</h2><p>问题：某个类做了过多的简单委托动作。<br>让客户直接调用委托类。</p><h3 id="7-1-动机"><a href="#7-1-动机" class="headerlink" title="7.1 动机"></a>7.1 动机</h3><ul><li>合适的隐藏程度；</li><li>与 Hide Delegate 相反；</li></ul><h2 id="8-Introduce-Foreign-Method（引入外部函数）"><a href="#8-Introduce-Foreign-Method（引入外部函数）" class="headerlink" title="8. Introduce Foreign Method（引入外部函数）"></a>8. Introduce Foreign Method（引入外部函数）</h2><p>问题：你需要为提供服务的类增加一个函数，但无法修改这个类。<br>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</p><h3 id="8-1-动机"><a href="#8-1-动机" class="headerlink" title="8.1 动机"></a>8.1 动机</h3><ul><li>同样功能防止重复代码。</li><li>若许多类都需要同样的外加函数，则应提取出来，使用 Introduce Local Extension。<br><code>ps:</code>类似 C# 的扩展函数。</li><li>坚持“函数与数据应该被统一封装”的原则。</li></ul><h2 id="9-Introduce-Local-Extension（引入本地扩展）"><a href="#9-Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="9. Introduce Local Extension（引入本地扩展）"></a>9. Introduce Local Extension（引入本地扩展）</h2><p>问题：你需要为提供服务的类增加一些函数，但无法修改这个类。<br>建立一个新类，使它包含这些额外函数。让这个扩展品成为原类的子类或包装类。<br>  <code>ps:</code>C# 的扩展方法更简单易用，若编程语言不支持扩展方法，则使用子类或包装类形式。</p><h3 id="9-1-注意事项"><a href="#9-1-注意事项" class="headerlink" title="9.1 注意事项"></a>9.1 注意事项</h3><ul><li>优先级：扩展方法 &gt; 子类 &gt; 包装类；</li><li>添加“转型构造函数”，即源类型作为参数的构造函数；</li><li>子类问题：必须在对象创建期实施、必须创建子类对象（若旧对象一直使用，则有两个对象保存原数据，数据修改会有问题）；</li><li>包装类 Wrapper；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第7章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;职责不清晰：Move Field、Move Method；&lt;/li&gt;
&lt;li&gt;类承担过多职责：Extract Class；&lt;/li&gt;
&lt;li&gt;类职责过少：Inline Class；&lt;/li&gt;
&lt;li&gt;类之间关联：Hide Delegate、Remove Middle Man；&lt;/li&gt;
&lt;li&gt;不能访问类的源码，却又想添加职责：Introduce Foreign Method、Introduce Local Extension；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>05.重构-重新组织数据</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/05.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/05.重构-重新组织数据/</id>
    <published>2018-05-31T15:06:26.000Z</published>
    <updated>2018-06-11T06:09:02.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>表示方式：Replace Value with Object、Change Value to Reference；</li><li>数组的行为方式很像一种数据结构：Replace Array with Object；</li><li>魔法数：Replace Magic Number with Symbolic Constant；</li><li>对象关联方向：Change Unidirectional Association to Bidirectional（单向-&gt;双向）、Change Bidirectional Association to Unidirectional（双向-&gt;单向）；</li><li>非公开数据：Encapsulate Field、Encapsulate Collection；</li><li>记录暴露在外：Replace Record with Data Class；</li><li>类型码（type code）：Replace Type Code with Class、Replace Type Code with Subclasses、Replace Type Code with State/Strategy；</li></ul><a id="more"></a><h2 id="2-Self-Encapsulate-Field（自封装字段）"><a href="#2-Self-Encapsulate-Field（自封装字段）" class="headerlink" title="2. Self Encapsulate Field（自封装字段）"></a>2. Self Encapsulate Field（自封装字段）</h2><p>为这个字段设置取值、设值函数，并只能通过该函数访问。</p><h2 id="3-Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#3-Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="3. Replace Data Value with Object（以对象取代数据值）"></a>3. Replace Data Value with Object（以对象取代数据值）</h2><p>将数据项变成对象。</p><h2 id="4-Change-Value-to-Reference（将值对象改为引用对象）"><a href="#4-Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="4. Change Value to Reference（将值对象改为引用对象）"></a>4. Change Value to Reference（将值对象改为引用对象）</h2><p>问题：你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。<br>将这个值对象改为引用对象。</p><h3 id="4-1-动机"><a href="#4-1-动机" class="headerlink" title="4.1 动机"></a>4.1 动机</h3><ul><li>实例共享，防止多份拷贝；</li><li>解决方案：如单例模式、静态函数等；</li></ul><h2 id="5-Change-Reference-to-Value（将引用对象改为值对象）"><a href="#5-Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="5. Change Reference to Value（将引用对象改为值对象）"></a>5. Change Reference to Value（将引用对象改为值对象）</h2><p>问题：你有一个引用对象，很小且不可变，而且不易管理。<br>将这个引用对象改为值对象。</p><h3 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h3><ul><li>值对象特性：不可变；</li><li>提供 equals() 和 hashCode() 等实现；</li></ul><h2 id="6-Replace-Array-with-Object（以对象取代数组）"><a href="#6-Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="6. Replace Array with Object（以对象取代数组）"></a>6. Replace Array with Object（以对象取代数组）</h2><p>问题：你有一个数组，其中的元素每个都代表不同的东西。<br><code>ps</code>：Martin Flower 写《重构》一书时，基于 Java1.0 -&gt; Java1.1 版本，那时还没有泛型一说。现如今应该不会出现这种数组存储完全不同类型的问题，否则就是需求分析建模出错。<br>以对象取代数组，对于数组中的每个元素，都使用一个字段表示。</p><h2 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h2><ul><li>数组存储不同类型数据；</li><li>个人理解另一个问题：数组数据涉及到相关操作，可考虑将属性修改为直接继承已有列表类型的对象，而后扩展相应操作。</li></ul><h2 id="7-Duplicate-Observed-Data（复制“被监视数据”）"><a href="#7-Duplicate-Observed-Data（复制“被监视数据”）" class="headerlink" title="7. Duplicate Observed Data（复制“被监视数据”）"></a>7. Duplicate Observed Data（复制“被监视数据”）</h2><p>将数据复制到一个领域对象中。建立一个 Observer 模式，用以同步领域对象和 GUI 对象内的重复数据。</p><h3 id="7-1-动机"><a href="#7-1-动机" class="headerlink" title="7.1 动机"></a>7.1 动机</h3><ul><li>UI 和业务逻辑代码分离；</li></ul><h2 id="8-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#8-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="8. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>8. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h2><p>添加一个反向指针，并使修改函数能够同时更新两条连接。</p><h3 id="8-1-动机"><a href="#8-1-动机" class="headerlink" title="8.1 动机"></a>8.1 动机</h3><ul><li>被引用类需要其引用者以便进行某些处理。</li></ul><h2 id="9-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）"><a href="#9-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）" class="headerlink" title="9. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）"></a>9. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）</h2><p>去除不必要的关联。</p><h3 id="9-1-动机"><a href="#9-1-动机" class="headerlink" title="9.1 动机"></a>9.1 动机</h3><ul><li>双向关联维护复杂，引用垃圾回收不了；</li><li>依赖关系太强，导致紧耦合；</li></ul><h2 id="10-Replace-Magic-Number-with-Symbolic-Constant（使用字面常量替换魔法数）"><a href="#10-Replace-Magic-Number-with-Symbolic-Constant（使用字面常量替换魔法数）" class="headerlink" title="10. Replace Magic Number with Symbolic Constant（使用字面常量替换魔法数）"></a>10. Replace Magic Number with Symbolic Constant（使用字面常量替换魔法数）</h2><p>创造一个变量，根据其意义为它命名，并将上述的字面数值替换为这个常量。<br><code>ps</code>：</p><ul><li>常量不会造成任何性能开销，却可以大大提高代码可读性。</li><li>若魔法数是类型码，考虑使用 Replace Type Code with Class；</li></ul><h2 id="11-Encapsulate-Field（封装字段）"><a href="#11-Encapsulate-Field（封装字段）" class="headerlink" title="11. Encapsulate Field（封装字段）"></a>11. Encapsulate Field（封装字段）</h2><p>将字段声明为 private，并提供 get/set 方法。<br><code>ps</code>：面向对象的原则之一就是封装，或称为“数据隐藏”。故数据不应该声明为 public，而通过（函数）行为暴露。</p><h2 id="12-Encapsulate-Collection（封装集合）"><a href="#12-Encapsulate-Collection（封装集合）" class="headerlink" title="12. Encapsulate Collection（封装集合）"></a>12. Encapsulate Collection（封装集合）</h2><p>让这个函数返回该集合的一个只读副本，并在这个类中提供添加/删除集合元素的函数。</p><h3 id="12-1-动机"><a href="#12-1-动机" class="headerlink" title="12.1 动机"></a>12.1 动机</h3><ul><li>集合用来保存一组实例，并提供取值/设值函数；</li><li>取值函数不应该返回集合本身，因为这会使得用户修改集合内容而集合拥有者却不知晓，过多暴露对象内部数据结构的信息；</li><li>不应该为集合提供一个设置函数，而应该提供添加/删除元素的函数；</li><li>封装数组，直接将数组替换为其他集合；</li></ul><h2 id="13-Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#13-Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="13. Replace Record with Data Class（以数据类取代记录）"></a>13. Replace Record with Data Class（以数据类取代记录）</h2><p>为该记录创建一个“哑”数据对象。<br><code>ps</code>：其实就是单独建立一个实体（Model/Entity），只有取值/设值函数。</p><h2 id="14-Replace-Type-Code-with-Class（以类取代状态码）"><a href="#14-Replace-Type-Code-with-Class（以类取代状态码）" class="headerlink" title="14. Replace Type Code with Class（以类取代状态码）"></a>14. Replace Type Code with Class（以类取代状态码）</h2><p>以一个新的类替换该数值类型码。<br><code>ps</code>：</p><ul><li>现如今有枚举类型，强类型检查，可优先考虑。</li><li>或者单独建立一个类，提供相应的状态码的静态字段，类似于 C# 中 Encoding 类的实现。</li></ul><h2 id="15-Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#15-Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="15. Replace Type Code with Subclasses（以子类取代类型码）"></a>15. Replace Type Code with Subclasses（以子类取代类型码）</h2><p>以子类取代这个类型码。<br><code>ps</code>：</p><ul><li>主要作用是为 Replace Conditional with Polymorphism 搭建平台。</li><li>若宿主类中无条件表达式，推荐使用 Replace Type Code with Class。</li></ul><h3 id="15-1-动机"><a href="#15-1-动机" class="headerlink" title="15.1 动机"></a>15.1 动机</h3><ul><li>以类型码的宿主类作为基类，针对每种类型码建立相应子类；</li><li>把“对不同行为的了解”从类用户转移到类自身；</li><li>不适用情况，需使用 Replace Type Code with State/Strategy：<ul><li>类型码在对象创建后发生改变；</li><li>由于某种原因，类型码宿主已有子类；</li></ul></li></ul><h2 id="16-Replace-Type-Code-with-State-Strategy（使用-State-Strategy-模式取代类型码）"><a href="#16-Replace-Type-Code-with-State-Strategy（使用-State-Strategy-模式取代类型码）" class="headerlink" title="16. Replace Type Code with State/Strategy（使用 State/Strategy 模式取代类型码）"></a>16. Replace Type Code with State/Strategy（使用 State/Strategy 模式取代类型码）</h2><p>以状态对象取代类型码。</p><ul><li>状态：State；</li><li>算法：Strategy；</li></ul><h2 id="17-Replace-Subclass-with-Fields（以字段取代子类）"><a href="#17-Replace-Subclass-with-Fields（以字段取代子类）" class="headerlink" title="17. Replace Subclass with Fields（以字段取代子类）"></a>17. Replace Subclass with Fields（以字段取代子类）</h2><p>问题：各个子类的唯一差别在于“返回常量数据”的函数上。<br>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。</p><h3 id="17-1-动机"><a href="#17-1-动机" class="headerlink" title="17.1 动机"></a>17.1 动机</h3><p>建立子类的目的是为了增加新特性或变化行为。其中，有一类行为变化被称为“常量函数”，它们会返回一个硬编码的值，使得不同子类的同一个函数返回不同的值。<br><strong>若子类只有常量函数，则没存在的价值。可直接在超类中使用字段表示类型（如 C# 中的 Encoding 类）</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第8章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;表示方式：Replace Value with Object、Change Value to Reference；&lt;/li&gt;
&lt;li&gt;数组的行为方式很像一种数据结构：Replace Array with Object；&lt;/li&gt;
&lt;li&gt;魔法数：Replace Magic Number with Symbolic Constant；&lt;/li&gt;
&lt;li&gt;对象关联方向：Change Unidirectional Association to Bidirectional（单向-&amp;gt;双向）、Change Bidirectional Association to Unidirectional（双向-&amp;gt;单向）；&lt;/li&gt;
&lt;li&gt;非公开数据：Encapsulate Field、Encapsulate Collection；&lt;/li&gt;
&lt;li&gt;记录暴露在外：Replace Record with Data Class；&lt;/li&gt;
&lt;li&gt;类型码（type code）：Replace Type Code with Class、Replace Type Code with Subclasses、Replace Type Code with State/Strategy；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>03.重构-重新组织函数</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/03.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/03.重构-重新组织函数/</id>
    <published>2018-05-31T10:06:26.000Z</published>
    <updated>2018-06-11T06:09:02.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题及方案"><a href="#1-问题及方案" class="headerlink" title="1. 问题及方案"></a>1. 问题及方案</h2><ul><li>Long Methods（过长函数）：Extract Method；</li><li>某些函数没做什么太多事情：Inline Method；</li><li>临时变量：Replace Temp with Query、Split Temporary Variable、Replace Method with Method Object；</li><li>参数问题：Remove Assignments to Parameters；</li><li>改进算法：Substitute Algorithm；</li></ul><a id="more"></a><h2 id="2-Extract-Method（提炼函数）"><a href="#2-Extract-Method（提炼函数）" class="headerlink" title="2. Extract Method（提炼函数）"></a>2. Extract Method（提炼函数）</h2><p>将一段代码放进一个独立函数中，并让函数名称解释其用途。</p><h3 id="2-1-动机"><a href="#2-1-动机" class="headerlink" title="2.1 动机"></a>2.1 动机</h3><ul><li>函数粒度小，易于复用和覆写；</li><li>高层函数更像注释；</li></ul><h3 id="2-2-做法"><a href="#2-2-做法" class="headerlink" title="2.2 做法"></a>2.2 做法</h3><ul><li>无局部变量：直接挪移</li><li>有局部变量，但不修改它或局部变量是对象：局部变量当做参数传递</li><li>对局部变量再赋值（Remove Assignments to Parameters）<ul><li>若只有被提炼代码使用：挪移局部变量</li><li>否则：返回值</li><li>返回变量不止一个：推荐只返回一个值，使用多个函数；若编程语言支持“出参数”（output parameter），则可使用。（类似 C# 的 ref 和 out，可考虑新特性元组 Tuple）<br>详见书P133。</li></ul></li></ul><h2 id="3-Inline-Method（内联函数）"><a href="#3-Inline-Method（内联函数）" class="headerlink" title="3. Inline Method（内联函数）"></a>3. Inline Method（内联函数）</h2><p>在函数调用点插入函数本体，然后移除该函数。</p><h3 id="3-1-动机"><a href="#3-1-动机" class="headerlink" title="3.1 动机"></a>3.1 动机</h3><ul><li>短小函数只有一处调用，过多导致复杂性太高，移动不方便等等；</li><li>防止间接层过多，晕头转向；</li></ul><h3 id="3-2-做法"><a href="#3-2-做法" class="headerlink" title="3.2 做法"></a>3.2 做法</h3><ul><li>检查函数，确定不具备多态性<ul><li>若子类继承该函数，就不能内联；<br>详见书P140</li></ul></li></ul><h2 id="4-Inline-Temp（内联临时变量）"><a href="#4-Inline-Temp（内联临时变量）" class="headerlink" title="4. Inline Temp（内联临时变量）"></a>4. Inline Temp（内联临时变量）</h2><p>将所有对该变量的引用操作，替换为对它赋值的那个表达式自身。</p><h3 id="4-1-动机"><a href="#4-1-动机" class="headerlink" title="4.1 动机"></a>4.1 动机</h3><ul><li>临时变量被赋予某个函数调用的返回值。<br><code>ps</code>：个人感觉部分情况还是可使用临时变量，以便调试使用，更清晰。</li></ul><h2 id="5-Replace-Temp-with-Query（以查询替代临时变量）"><a href="#5-Replace-Temp-with-Query（以查询替代临时变量）" class="headerlink" title="5. Replace Temp with Query（以查询替代临时变量）"></a>5. Replace Temp with Query（以查询替代临时变量）</h2><p>将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用。<br><code>ps</code>：该操作会导致函数执行多次，故为了效率考虑，若执行速度慢的查询，还是需使用临时变量。</p><h2 id="6-Introduce-Explaining-Variable（引入解释下变量）"><a href="#6-Introduce-Explaining-Variable（引入解释下变量）" class="headerlink" title="6. Introduce Explaining Variable（引入解释下变量）"></a>6. Introduce Explaining Variable（引入解释下变量）</h2><p>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</p><h3 id="6-1-动机"><a href="#6-1-动机" class="headerlink" title="6.1 动机"></a>6.1 动机</h3><ul><li>与 Inline Temp（内联临时变量）相反；</li><li>表达式可能非常复杂而难以阅读，临时变量可帮助拆分，提高阅读性；<br><code>ps</code>：作者推荐使用 Extract Method，以便复用。</li></ul><h2 id="7-Split-Temporary-Variable（分解临时变量）"><a href="#7-Split-Temporary-Variable（分解临时变量）" class="headerlink" title="7. Split Temporary Variable（分解临时变量）"></a>7. Split Temporary Variable（分解临时变量）</h2><p>针对每次赋值，创造一个独立、对应的临时变量。</p><h3 id="7-1-动机"><a href="#7-1-动机" class="headerlink" title="7.1 动机"></a>7.1 动机</h3><p>某个临时变量被赋值超过一次，它既不是<strong>循环变量</strong>，又不是<strong>搜集计算结果</strong>。除了这两种情况，其他意味着临时变量承担了多个责任，应该被替换为多个临时变量，每个变量只承担一个责任。</p><h2 id="8-Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#8-Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="8. Remove Assignments to Parameters（移除对参数的赋值）"></a>8. Remove Assignments to Parameters（移除对参数的赋值）</h2><p>以一个临时变量取代该参数的位置。</p><h3 id="8-1-动机"><a href="#8-1-动机" class="headerlink" title="8.1 动机"></a>8.1 动机</h3><ul><li>防止混用<strong>按值传递</strong>和<strong>按引用传递</strong>；</li><li>不要对参数赋值（特别是 Java、C# 这类只采用值传递的编程语言），出参数（ref、out）除外；</li><li>可以为参数加上 final 修饰符，强制不对参数赋值；<br><code>ps</code>：在按值传递的情况下，对参数的任何修改，都不会对调用端造成任何影响。</li></ul><h2 id="9-Replace-Method-with-Method-Object（以函数对象取代函数）"><a href="#9-Replace-Method-with-Method-Object（以函数对象取代函数）" class="headerlink" title="9. Replace Method with Method Object（以函数对象取代函数）"></a>9. Replace Method with Method Object（以函数对象取代函数）</h2><p>问题：你有一个大型函数，其中对局部变量的使用使你无法采用 Extract Method。<br>将这个函数放进一个单独对象中，这样该局部变量就成为了这个对象的字段，然后就可拆分。</p><h2 id="10-Substitute-Algorithm（替换算法）"><a href="#10-Substitute-Algorithm（替换算法）" class="headerlink" title="10. Substitute Algorithm（替换算法）"></a>10. Substitute Algorithm（替换算法）</h2><p>将函数本体替换为另一个算法。</p><h3 id="10-1-动机"><a href="#10-1-动机" class="headerlink" title="10.1 动机"></a>10.1 动机</h3><p>解决问题有好几种方法，其中某些方法会比另一些简单。<br>使用这项重构手法之前，请先确定自己已经尽可能分解了原先函数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第6章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题及方案&quot;&gt;&lt;a href=&quot;#1-问题及方案&quot; class=&quot;headerlink&quot; title=&quot;1. 问题及方案&quot;&gt;&lt;/a&gt;1. 问题及方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Long Methods（过长函数）：Extract Method；&lt;/li&gt;
&lt;li&gt;某些函数没做什么太多事情：Inline Method；&lt;/li&gt;
&lt;li&gt;临时变量：Replace Temp with Query、Split Temporary Variable、Replace Method with Method Object；&lt;/li&gt;
&lt;li&gt;参数问题：Remove Assignments to Parameters；&lt;/li&gt;
&lt;li&gt;改进算法：Substitute Algorithm；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>02.重构-重构手法</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/02.%E9%87%8D%E6%9E%84-%E9%87%8D%E6%9E%84%E6%89%8B%E6%B3%95/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/02.重构-重构手法/</id>
    <published>2018-05-30T10:06:26.000Z</published>
    <updated>2018-06-11T06:09:02.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-重构的记录格式"><a href="#1-重构的记录格式" class="headerlink" title="1. 重构的记录格式"></a>1. 重构的记录格式</h2><ul><li>名称（name）</li><li>简短概要（summary）：介绍重构手法的适用场景，以及它所做的事情。</li><li>动机（motivation）：Why，介绍“为什么需要这个重构”和“什么情况下不该适用这个重构”。</li><li>做法（mechanics）：How。</li><li>范例（examples）</li></ul><a id="more"></a><h2 id="2-寻找引用点"><a href="#2-寻找引用点" class="headerlink" title="2. 寻找引用点"></a>2. 寻找引用点</h2><ul><li>文本查找工具，不要盲目地查找-替换；</li><li>编译器，缺点：<ul><li>被删除的部分在继承体系中不知声明一次；</li><li>效率太慢；</li><li>无法找到反射机制的引用点；</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第5章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-重构的记录格式&quot;&gt;&lt;a href=&quot;#1-重构的记录格式&quot; class=&quot;headerlink&quot; title=&quot;1. 重构的记录格式&quot;&gt;&lt;/a&gt;1. 重构的记录格式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;名称（name）&lt;/li&gt;
&lt;li&gt;简短概要（summary）：介绍重构手法的适用场景，以及它所做的事情。&lt;/li&gt;
&lt;li&gt;动机（motivation）：Why，介绍“为什么需要这个重构”和“什么情况下不该适用这个重构”。&lt;/li&gt;
&lt;li&gt;做法（mechanics）：How。&lt;/li&gt;
&lt;li&gt;范例（examples）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>01.重构-介绍</title>
    <link href="http://www.venux.cn//posts/05.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02.%E9%87%8D%E6%9E%84/01.%E9%87%8D%E6%9E%84-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.venux.cn//posts/05.编程思想/02.重构/01.重构-介绍/</id>
    <published>2018-05-29T10:06:26.000Z</published>
    <updated>2018-06-11T06:09:02.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul><li>重构（refactoring）是在不改变软件可观察行为的前提下改善其内部结构。</li><li>重构是这样一个过程：在不改变代码外在行为的前提下，对代码进行修改，以改进程序的内部结构。</li><li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高可理解性，降低其修改成本。</li><li>重构（动词）：使用一系列重构首发，在不改变软件可观察行为的前提下，调整其结构。</li></ul><a id="more"></a><h2 id="2-原则"><a href="#2-原则" class="headerlink" title="2. 原则"></a>2. 原则</h2><ul><li>不改变软件行为只是重构的最基本要求；</li><li>不需了解软件行为才是目的；</li><li>个人理解：封装完整性？调用 API 而无需了解 API 内部实现和行为。</li><li>设计模式为重构提供了目标；</li><li>判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据放在一起。<ul><li><code>ps:</code>有些设计模式破坏这个原则，如 Strategy 和 Visitor，Self Delegation，这是为了对抗坏味道 Divergent Change。</li><li>最根本的原则：将总是一起变化的东西放在一起。</li></ul></li></ul><h2 id="3-目的"><a href="#3-目的" class="headerlink" title="3. 目的"></a>3. 目的</h2><ul><li>重构改进软件设计<ul><li>消除重复代码</li></ul></li><li>重构使软件更容易理解</li><li>重构帮助找到 bug</li><li>重构提高编程速度</li><li>重构使得设计思路更详细明确；</li><li>重构被用于开发框架、抽取可复用组件、使软件架构更清晰、使新功能增加更容易；</li><li>重构可以减少重复劳动，使得程序更加简洁有力；</li></ul><h2 id="4-经验"><a href="#4-经验" class="headerlink" title="4. 经验"></a>4. 经验</h2><ul><li>重构前需建立一组可靠的测试环境，且必须能自我检验；</li><li>重构技术就是以微小的步伐修改程序，如果出错，可以很容易发现；</li><li>良好的名称是代码清晰的关键；</li><li>尽量除去临时变量；</li><li>最好不要在另一个对象的属性基础上运用 switch 语句，如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用；</li><li>技术复审是减少错误、提高开发速度的一条重要途径。</li></ul><h2 id="5-何时重构"><a href="#5-何时重构" class="headerlink" title="5. 何时重构"></a>5. 何时重构</h2><ul><li>反对专门拨出时间进行重构；</li><li>重构应该随时随地进行；</li><li>不应该为了重构而重构；</li><li>三次法则（事不过三，三则重构）<ul><li>第一次做某件事时只管去做；</li><li>第二次做类似的事会产生反感，但无论如何还是可以去做；</li><li>第三次再做类似的事，就应该重构。</li></ul></li><li>添加功能时重构；</li><li>修补错误时重构；</li><li>复审代码时重构；</li></ul><h2 id="6-为什么重构有用-–-Kent-Beck"><a href="#6-为什么重构有用-–-Kent-Beck" class="headerlink" title="6. 为什么重构有用 – Kent Beck"></a>6. 为什么重构有用 – Kent Beck</h2><h3 id="6-1-问题"><a href="#6-1-问题" class="headerlink" title="6.1 问题"></a>6.1 问题</h3><ul><li>难以阅读的程序，难以修改；</li><li>逻辑重复的程序，难以修改；</li><li>添加新行为时需要修改已有代码的程序，难以修改；</li><li>带复杂条件逻辑的程序，难以修改；</li></ul><h3 id="6-2-期望"><a href="#6-2-期望" class="headerlink" title="6.2 期望"></a>6.2 期望</h3><ul><li>容易阅读；</li><li>所有逻辑都只在唯一地点指定；</li><li>新的改动不会危及现有行为；</li><li>尽可能简单表达条件逻辑；</li></ul><h2 id="7-间接层"><a href="#7-间接层" class="headerlink" title="7. 间接层"></a>7. 间接层</h2><blockquote><p>计算机科学是这样一门科学：它相信所有问题都可以通过增加一个间接层来解决。</p><footer><strong>Dennis DeBruler</strong></footer></blockquote><h2 id="8-重构难题"><a href="#8-重构难题" class="headerlink" title="8. 重构难题"></a>8. 重构难题</h2><h3 id="8-1-数据库"><a href="#8-1-数据库" class="headerlink" title="8.1 数据库"></a>8.1 数据库</h3><ul><li>绝大多数程序都与其背后的数据库结构紧密耦合在一起；</li><li>数据迁移（migration）；</li><li>在非对象数据库中，解决办法之一是：在对象模型和数据库模型之间插入一个分割层，隔离两个模型各自的编号；</li></ul><h3 id="8-2-修改接口"><a href="#8-2-修改接口" class="headerlink" title="8.2 修改接口"></a>8.2 修改接口</h3><p>只有当需要修改的接口被哪些“找不到，即使找到也不能修改”的代码使用时，接口的修改才会成为问题。此时，这个接口是个已发布接口（published interface），比公开接口（public interface）更进一步。</p><ul><li>必须同时维护新旧两个接口，直到所有用户都有时间对这个变化做出反应；<ul><li>让旧接口调用新接口，千万不要复制函数实现；</li><li>将旧接口标记为 deprecated（java 的已过时），例如 Java 容器类；</li></ul></li><li>尽量不要发布接口，除非真的有必要；</li><li>Java 还有一种特别的接口修改：在 throws 子句中增加一个异常。此时，需要新建函数，然后在旧函数调用它，并处理这个异常。</li></ul><p><code>ps:</code>不要过早发布接口。请修改你的代码所有权政策，使重构更顺畅。</p><h3 id="8-3-难以通过重构手法完成的设计改动"><a href="#8-3-难以通过重构手法完成的设计改动" class="headerlink" title="8.3 难以通过重构手法完成的设计改动"></a>8.3 难以通过重构手法完成的设计改动</h3><p>先想象重构的情况，考虑候选设计方案难度，而后在设计上投入更多力气。</p><h2 id="9-何时不该重构"><a href="#9-何时不该重构" class="headerlink" title="9. 何时不该重构"></a>9. 何时不该重构</h2><ul><li>有时候代码是在太混乱，重构还不如重新重写一个；</li><li>重写（而非重构）的一个清楚讯号就是：现有代码根本不能正常运作；</li><li>折中办法：将“大块头软件”重构为封装良好的小型组件；</li><li>项目已近最后期限，此刻应该避免重构；</li></ul><h2 id="10-代码的坏味道（Bad-Smell）"><a href="#10-代码的坏味道（Bad-Smell）" class="headerlink" title="10. 代码的坏味道（Bad Smell）"></a>10. 代码的坏味道（Bad Smell）</h2><h3 id="10-1-Duplicated-Code（重复代码）"><a href="#10-1-Duplicated-Code（重复代码）" class="headerlink" title="10.1 Duplicated Code（重复代码）"></a>10.1 Duplicated Code（重复代码）</h3><ul><li>Extract（提取） Method：重复代码；</li><li>Pull Up Method：多个子类重复代码，提取代码放到超类；</li><li>Form Template Method：各个子类有所差异，使用 Template Method（模板方法）模式；</li><li>Substitute（替代） Algorithm：不同算法做同样的事；</li><li>Extract Class：若两个毫不相关的类出现，则将重复代码提炼到一个独立类；</li></ul><h3 id="10-2-Long-Method（过长函数）"><a href="#10-2-Long-Method（过长函数）" class="headerlink" title="10.2 Long Method（过长函数）"></a>10.2 Long Method（过长函数）</h3><p>“间接层”所能带来的全部利益–解释能力、共享能力、选择能力–都是由小型函数支持的。小函数真正容易理解的关键之处在于一个好名字。</p><ul><li>Extract Method</li><li>Replace Temp with Query</li><li>Introduce Parameter Object</li><li>Preserve（保持） Whole Object</li><li>Replace Method with Method Object</li><li>Decompose（分解） Conditional</li></ul><h3 id="10-3-Large-Class（过大的类）"><a href="#10-3-Large-Class（过大的类）" class="headerlink" title="10.3 Large Class（过大的类）"></a>10.3 Large Class（过大的类）</h3><ul><li>Extract Class</li><li>Extract Subclass</li><li>Extract Interface：先确定客户端如何使用它们，而后为每种使用方式提炼出一个接口。</li><li>Duplicate Observed Data</li></ul><h3 id="10-4-Long-Parameter-List（过长参数列）"><a href="#10-4-Long-Parameter-List（过长参数列）" class="headerlink" title="10.4 Long Parameter List（过长参数列）"></a>10.4 Long Parameter List（过长参数列）</h3><ul><li>Replace Parameter with Method</li><li>Preserve Whole Object</li><li>Introduce Parameter Object：如果某些数据缺乏合理的对象归属，可为它们制造一个“参数对象”；<br>-<code>ps:</code>例外情况，有时候不希望造成“被调用对象”与“较大对象”间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情合理。但需注意引发的代价。若参数列太长或变化太频繁，就需要重新考虑依赖结构。</li></ul><h3 id="10-5-Divergent-Change（发散式变化）"><a href="#10-5-Divergent-Change（发散式变化）" class="headerlink" title="10.5 Divergent Change（发散式变化）"></a>10.5 Divergent Change（发散式变化）</h3><p>某个类因为不同原因在不同方向发生变化。此时也许将对象拆分更好，这么一来每个对象就可以只因一种变化而修改。</p><ul><li>Extract Class</li></ul><h3 id="10-6-Shotgun-Surgery（散弹式修改）"><a href="#10-6-Shotgun-Surgery（散弹式修改）" class="headerlink" title="10.6 Shotgun Surgery（散弹式修改）"></a>10.6 Shotgun Surgery（散弹式修改）</h3><p>某种变化引发在许多不同的类内做出许多小修改。考虑把所有需要修改的代码放进同一个类。</p><ul><li>Move Method</li><li>Move Field</li><li>Inline Class</li></ul><p><code>ps:</code>Divergent Change 是指“一个类受多种变化的影响”，Shotgun Surgery 则是指“一种变化引发多个类相应修改”。</p><h3 id="10-7-Feature-Envy（依恋情结）"><a href="#10-7-Feature-Envy（依恋情结）" class="headerlink" title="10.7 Feature Envy（依恋情结）"></a>10.7 Feature Envy（依恋情结）</h3><ul><li>Extract Method</li><li>Move Method</li></ul><h3 id="10-8-Data-Clumps（数据泥团）"><a href="#10-8-Data-Clumps（数据泥团）" class="headerlink" title="10.8 Data Clumps（数据泥团）"></a>10.8 Data Clumps（数据泥团）</h3><p>两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有数据它们自己的对象。</p><ul><li>Extract Class</li><li>Introduce Parameter Object</li><li>Preserve Whole Object</li></ul><h3 id="10-9-Primitive-Obsession（基本类型偏执）"><a href="#10-9-Primitive-Obsession（基本类型偏执）" class="headerlink" title="10.9 Primitive Obsession（基本类型偏执）"></a>10.9 Primitive Obsession（基本类型偏执）</h3><ul><li>Replace Data Value with Object</li><li>Replace Type Code with Class</li><li>Replace Type Code with Subclass</li><li>Replace Type Code with State/Strategy</li><li>Extract Class</li><li>Introduce Parameter Object</li><li>Replace Array with Object</li></ul><h3 id="10-10-Switch-Statements（switch表达式）"><a href="#10-10-Switch-Statements（switch表达式）" class="headerlink" title="10.10 Switch Statements（switch表达式）"></a>10.10 Switch Statements（switch表达式）</h3><p>面向对象程序的一个最明显的特征就是：少用 switch（或 case）语句，问题在于重复，同样 switch 语句散布不同地方，需同时修改。解决方案是<strong>多态</strong>。</p><ul><li>Extract Method</li><li>Extract Class</li><li>Replace Type Code with Subclass</li><li>Replace Type Code with State/Strategy</li><li>Replace Conditional with Polymorphism（多态性）</li><li>Replace Parameter with Explicit（明确的） Methods</li><li>Introduce Null Object</li></ul><h3 id="10-11-Paraller-Inheritance-Hierarchies（平行继承体系）"><a href="#10-11-Paraller-Inheritance-Hierarchies（平行继承体系）" class="headerlink" title="10.11 Paraller Inheritance Hierarchies（平行继承体系）"></a>10.11 Paraller Inheritance Hierarchies（平行继承体系）</h3><p>Shotgun Surgery 的特殊情况，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。<br><strong>策略</strong>：让一个继承体系的实例引用另一个继承体系的实例。</p><ul><li>Move Method</li><li>Move Field</li></ul><h3 id="10-12-Lazy-Class（冗赘类）"><a href="#10-12-Lazy-Class（冗赘类）" class="headerlink" title="10.12 Lazy Class（冗赘类）"></a>10.12 Lazy Class（冗赘类）</h3><p>你所创建的每一个类，都得有人去理解和维护它，若一个类重构后完全没啥意义，就应该考虑删除它。</p><ul><li>Collapse（崩溃、折叠） Hierarchy</li><li>Inline Class</li></ul><h3 id="10-13-Speculative-Generality（夸夸其谈未来性）"><a href="#10-13-Speculative-Generality（夸夸其谈未来性）" class="headerlink" title="10.13 Speculative Generality（夸夸其谈未来性）"></a>10.13 Speculative Generality（夸夸其谈未来性）</h3><ul><li>Collapse Hierarchy</li><li>Inline Class</li><li>Remove Parameter</li><li>Rename Method</li></ul><h3 id="10-14-Temporary-Field（令人迷惑的临时字段）"><a href="#10-14-Temporary-Field（令人迷惑的临时字段）" class="headerlink" title="10.14 Temporary Field（令人迷惑的临时字段）"></a>10.14 Temporary Field（令人迷惑的临时字段）</h3><ul><li>Extract Class</li><li>Introduce Null Object</li></ul><h3 id="10-15-Message-Chains（过度耦合的消息链）"><a href="#10-15-Message-Chains（过度耦合的消息链）" class="headerlink" title="10.15 Message Chains（过度耦合的消息链）"></a>10.15 Message Chains（过度耦合的消息链）</h3><ul><li>Hide Delegate</li><li>Extract Method</li><li>Move Method</li></ul><h3 id="10-16-Middle-Man（中间人）"><a href="#10-16-Middle-Man（中间人）" class="headerlink" title="10.16 Middle Man（中间人）"></a>10.16 Middle Man（中间人）</h3><p>过度委托</p><ul><li>Remove Middle Man</li><li>Inline Method</li><li>Replace Delegation with Inheritance</li></ul><h3 id="10-17-Inappropriate-Intimacy（不恰当的亲密关系，即狎昵关系）"><a href="#10-17-Inappropriate-Intimacy（不恰当的亲密关系，即狎昵关系）" class="headerlink" title="10.17 Inappropriate Intimacy（不恰当的亲密关系，即狎昵关系）"></a>10.17 Inappropriate Intimacy（不恰当的亲密关系，即狎昵关系）</h3><ul><li>Move Method</li><li>Move Field</li><li>Change Bidirectional（双向） Association（关联） to Unidirectional（单向）</li><li>Extract Class</li><li>Hide Delegate</li><li>Replace Inheritance with Delegation</li></ul><h3 id="10-18-Alternative-Classes-with-Different-Interfaces（异曲同工的类）"><a href="#10-18-Alternative-Classes-with-Different-Interfaces（异曲同工的类）" class="headerlink" title="10.18 Alternative Classes with Different Interfaces（异曲同工的类）"></a>10.18 Alternative Classes with Different Interfaces（异曲同工的类）</h3><ul><li>Rename Method</li><li>Move Method</li><li>Extract SuperClass</li></ul><h3 id="10-19-Incomplete-Library-Class（不完美的类库）"><a href="#10-19-Incomplete-Library-Class（不完美的类库）" class="headerlink" title="10.19 Incomplete Library Class（不完美的类库）"></a>10.19 Incomplete Library Class（不完美的类库）</h3><ul><li>Introduce Foreign Method</li><li>Introduce Local Extension</li></ul><h3 id="10-20-Data-Class（纯粹的数据类）"><a href="#10-20-Data-Class（纯粹的数据类）" class="headerlink" title="10.20 Data Class（纯粹的数据类）"></a>10.20 Data Class（纯粹的数据类）</h3><p>指拥有一些字段以及访问（读写）这些字段的函数的类，即 Model 实体类。</p><ul><li>Encapsulate（封装） Field</li><li>Encapsulate Collection</li><li>Remove Setting Method</li><li>Move Method</li><li>Extract Method</li><li>Hide Method</li></ul><h3 id="10-21-Refused-Bequest（被拒绝的遗赠）"><a href="#10-21-Refused-Bequest（被拒绝的遗赠）" class="headerlink" title="10.21 Refused Bequest（被拒绝的遗赠）"></a>10.21 Refused Bequest（被拒绝的遗赠）</h3><p>子类不需要超类的函数和数据，意味着继承体系设计错误。</p><ul><li>Push Down Method</li><li>Push Down Field</li><li>Replace Iniheritance with Delegation</li></ul><h3 id="10-22-Comments（过多的注释）"><a href="#10-22-Comments（过多的注释）" class="headerlink" title="10.22 Comments（过多的注释）"></a>10.22 Comments（过多的注释）</h3><p>注释太长太多意味着代码很糟糕。</p><ul><li>Extract Method</li><li>Rename Method</li><li>Introduce Assertion<br><code>ps:</code>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</li></ul><h2 id="11-测试"><a href="#11-测试" class="headerlink" title="11 测试"></a>11 测试</h2><p>如果你想进行重构，首要前提就是拥有一个可靠的测试环境。<br><code>ps</code>：</p><ul><li>确保所有测试都完全自动化，让它们检查自己的测试结果。</li><li>一套测试就是一个强大的 bug 侦测器，能够大大缩减查找 bug 所需要的时间。</li><li>当事情被认为应该会出错时，别忘了检查是否抛出预期的异常。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>Replace Type Code with State/Strategy</li><li>Move Method</li><li>Replace Conditional with Polymorphism</li><li>Form Template Method</li><li>Replace Temp with Query</li><li>Extract Method</li><li>Self Encapsulate(自封装) Field</li></ul><h3 id="重构-vs-性能优化"><a href="#重构-vs-性能优化" class="headerlink" title="重构 vs 性能优化"></a>重构 vs 性能优化</h3><table><thead><tr><th>类型</th><th>重构</th><th>性能优化</th></tr></thead><tbody><tr><td>内部结构</td><td>改变</td><td>改变</td></tr><tr><td>外部行为</td><td>不改变或很小改变</td><td>不改变（除了执行速度）</td></tr><tr><td>目的</td><td>软件更容易被理解和修改，性能没有变化</td><td>性能提升，但往往使代码较难理解</td></tr></tbody></table><h3 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h3><ul><li><strong>怎么对经理说重构</strong>：很多经理嘴巴上说自己“质量驱动”，实际是“进度驱动”，这种情况建议是：不要告诉经理！</li><li>学习一种可以大幅提高生产力的新技术时，你总是难以察觉其不适用的场合。通常你在一个特定场景中学习它，这个场景往往是个项目。这种情况下你很难看出什么会造成这种新技术成效不彰或形成危害。</li><li><blockquote><p>他把未完成的重构工作形容为“债务”。很多公司都需要借债来使自己更有效的运转，但借债就得付利息，过于复杂的代码所造成的维护和扩展的额外成本就是利息。你可以承受一定程度的利息，但如果利息太高，你就会被压垮。把债务管理好是很重要的，你应该随时通过重构来偿还一部分债务。</p><footer><strong>Ward Cunningham</strong></footer></blockquote></li><li>重构与设计互补。</li><li>如果在所有可能的变化出现地点都建立起灵活性，整个系统的复杂度和维护难度都会大大提高。当然，如果最后发现所有这些灵活性都毫无必要，这才是最大的失败。</li><li>重构可以带来更简单的设计，同时又不损失灵活性，也降低了设计过程的难度，减轻了设计压力。</li><li><blockquote><p>哪怕你完全了解系统，也请实际度量它的性能，不要瞎猜。瞎猜可能会让你学到一些东西，但十有八九是错的。</p><footer><strong>Ron Jeffries</strong></footer></blockquote></li><li>如何确定该提炼哪一段代码：寻找注释，它们通常能指出代码用途和实现手法之间的语义距离。</li><li>对象技术的全部要点：将数据和对数据的操作行为包装到一起。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《重构-改善既有代码的设计》（第1-4章）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;重构（refactoring）是在不改变软件可观察行为的前提下改善其内部结构。&lt;/li&gt;
&lt;li&gt;重构是这样一个过程：在不改变代码外在行为的前提下，对代码进行修改，以改进程序的内部结构。&lt;/li&gt;
&lt;li&gt;重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高可理解性，降低其修改成本。&lt;/li&gt;
&lt;li&gt;重构（动词）：使用一系列重构首发，在不改变软件可观察行为的前提下，调整其结构。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="05.编程思想" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="02.重构" scheme="http://www.venux.cn/categories/05-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="编程思想" scheme="http://www.venux.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="重构" scheme="http://www.venux.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器</title>
    <link href="http://www.venux.cn//posts/03.%E5%B7%A5%E5%85%B7/01.Linux/01.CentOS/vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://www.venux.cn//posts/03.工具/01.Linux/01.CentOS/vim编辑器/</id>
    <published>2018-05-28T10:06:26.000Z</published>
    <updated>2018-06-11T06:09:03.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h2 id="2-退出"><a href="#2-退出" class="headerlink" title="2. 退出"></a>2. 退出</h2><p>先按<code>Esc</code>切换命令模式，而后在<code>:</code>后输入相关命令：</p><ul><li><strong>wq</strong>：写入退出，等同于 <strong>x</strong>；</li><li><strong>q!</strong>：不保存退出；</li><li><strong>!</strong>：强制退出，并在提示后回车。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>Linux 命令要小写。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;h2 id=&quot;2-退出&quot;&gt;&lt;a href=&quot;#2-退出&quot; class=&quot;headerlink&quot; title=&quot;2. 退出&quot;&gt;
      
    
    </summary>
    
      <category term="03.工具" scheme="http://www.venux.cn/categories/03-%E5%B7%A5%E5%85%B7/"/>
    
      <category term="01.Linux" scheme="http://www.venux.cn/categories/03-%E5%B7%A5%E5%85%B7/01-Linux/"/>
    
      <category term="01.CentOS" scheme="http://www.venux.cn/categories/03-%E5%B7%A5%E5%85%B7/01-Linux/01-CentOS/"/>
    
    
      <category term="Linux" scheme="http://www.venux.cn/tags/Linux/"/>
    
      <category term="CentOS" scheme="http://www.venux.cn/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>CSharp与Java对比</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/04.%E5%85%B6%E4%BB%96/CSharp%E4%B8%8EJava%E5%AF%B9%E6%AF%94/"/>
    <id>http://www.venux.cn//posts/01.编程语言/04.其他/CSharp与Java对比/</id>
    <published>2018-05-25T12:05:42.000Z</published>
    <updated>2018-06-11T06:09:02.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-代码风格"><a href="#1-代码风格" class="headerlink" title="1.代码风格"></a>1.代码风格</h2><h3 id="1-1-命名规范"><a href="#1-1-命名规范" class="headerlink" title="1.1 命名规范"></a>1.1 命名规范</h3><h4 id="1-1-1-接口"><a href="#1-1-1-接口" class="headerlink" title="1.1.1 接口"></a>1.1.1 接口</h4><table><thead><tr><th>分类</th><th>详细</th><th>C#</th><th>Java</th></tr></thead><tbody><tr><td>命名</td><td>接口</td><td>前缀I</td><td>无</td></tr><tr><td>命名</td><td>接口实现</td><td>无</td><td>后缀Impl</td></tr><tr><td>命名</td><td>抽象类</td><td>前缀Base</td><td>前缀Abstract</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-代码风格&quot;&gt;&lt;a href=&quot;#1-代码风格&quot; class=&quot;headerlink&quot; title=&quot;1.代码风格&quot;&gt;&lt;/a&gt;1.代码风格&lt;/h2&gt;&lt;h3 id=&quot;1-1-命名规范&quot;&gt;&lt;a href=&quot;#1-1-命名规范&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="04.其他" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/04-%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="C#" scheme="http://www.venux.cn/tags/C/"/>
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C#代码规范</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.CSharp/CSharp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://www.venux.cn//posts/01.编程语言/01.CSharp/CSharp代码规范/</id>
    <published>2018-05-25T10:06:26.000Z</published>
    <updated>2018-06-11T06:09:01.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-规范制定原则"><a href="#1-规范制定原则" class="headerlink" title="1.    规范制定原则"></a>1.    规范制定原则</h2><ul><li>方便代码的交流和维护。</li><li>不影响编码的效率，不与大众习惯冲突。</li><li>使代码更美观、阅读更方便。</li><li>使代码的逻辑更清晰、更易于理解。</li></ul><h2 id="2-术语定义"><a href="#2-术语定义" class="headerlink" title="2.    术语定义"></a>2.    术语定义</h2><h3 id="2-1-Pascal-大小写"><a href="#2-1-Pascal-大小写" class="headerlink" title="2.1 Pascal 大小写"></a>2.1 Pascal 大小写</h3><p>将标识符的首字母和后面连接的每个单词的首字母都大写。可以对三字符或更多字符的标识符使用Pascal 大小写。例如： BackColor。</p><h3 id="2-2-Camel-大小写"><a href="#2-2-Camel-大小写" class="headerlink" title="2.2 Camel 大小写"></a>2.2 Camel 大小写</h3><p>标识符的首字母小写，而每个后面连接的单词的首字母都大写。例如：backColor。</p><h2 id="3-代码外观"><a href="#3-代码外观" class="headerlink" title="3. 代码外观"></a>3. 代码外观</h2><h3 id="3-1-列宽"><a href="#3-1-列宽" class="headerlink" title="3.1 列宽"></a>3.1 列宽</h3><p>控制在 120 字符左右。</p><h3 id="3-2-换行"><a href="#3-2-换行" class="headerlink" title="3.2 换行"></a>3.2 换行</h3><ul><li>在逗号后换行。</li><li>在操作符前换行。</li><li>规则1优先于规则2。</li></ul><h3 id="3-3-缩进"><a href="#3-3-缩进" class="headerlink" title="3.3    缩进"></a>3.3    缩进</h3><p>缩进应该是每行一个Tab(4个空格)，不要在代码中使用Tab字符。<br><code>VS设置</code>：工具-&gt;选项-&gt;文本编辑器-&gt;C#-&gt;制表符-&gt;插入空格</p><h3 id="3-4-空行"><a href="#3-4-空行" class="headerlink" title="3.4    空行"></a>3.4    空行</h3><p>空行是为了将逻辑上相关联的代码分块，以便提高代码的可阅读性。</p><ul><li><p>在以下情况下使用两个空行</p><ul><li>接口和类的定义之间。</li><li>枚举和类的定义之间。</li><li>类与类的定义之间.</li></ul></li><li><p>在以下情况下使用一个空行</p><ul><li>方法与方法、属性与属性之间。</li><li>方法中变量声明与语句之间。</li><li>方法与方法之间。</li><li>方法中不同的逻辑块之间。</li><li>方法中的返回语句与其他的语句之间。</li><li>属性与方法、属性与字段、方法与字段之间。</li><li>注释与它注释的语句间不空行，但与其他的语句间空一行。</li></ul></li></ul><h3 id="3-5-程序注释"><a href="#3-5-程序注释" class="headerlink" title="3.5 程序注释"></a>3.5 程序注释</h3><h4 id="3-5-1-文件注释"><a href="#3-5-1-文件注释" class="headerlink" title="3.5.1 文件注释"></a>3.5.1 文件注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//===========================================================</span><br><span class="line">// Copyright (c) $年份 $公司名称.  </span><br><span class="line">// 版权所有.</span><br><span class="line">//===========================================================</span><br></pre></td></tr></table></figure><h4 id="3-5-2-对象注释（类、接口、枚举、结构等）"><a href="#3-5-2-对象注释（类、接口、枚举、结构等）" class="headerlink" title="3.5.2 对象注释（类、接口、枚举、结构等）"></a>3.5.2 对象注释（类、接口、枚举、结构等）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// $功能描述</span><br><span class="line">/// 作者：$作者</span><br><span class="line">/// 日期：$创建日期</span><br><span class="line">/// 版本：$版本号</span><br><span class="line">/// &lt;/summary&gt;</span><br></pre></td></tr></table></figure><h4 id="3-5-3-其他注释（单行注释、多行注释、方法注释）"><a href="#3-5-3-其他注释（单行注释、多行注释、方法注释）" class="headerlink" title="3.5.3 其他注释（单行注释、多行注释、方法注释）"></a>3.5.3 其他注释（单行注释、多行注释、方法注释）</h4><ul><li>方法注释<strong>必须</strong>；</li><li>其他根据情况自行添加。</li></ul><h2 id="4-命名规范"><a href="#4-命名规范" class="headerlink" title="4. 命名规范"></a>4. 命名规范</h2><h3 id="4-1-命名原则"><a href="#4-1-命名原则" class="headerlink" title="4.1 命名原则"></a>4.1 命名原则</h3><ul><li>使名称足够长以便有一定的意义，并且足够短以避免冗长。</li><li>唯一名称在编程上仅用于将各项区分开。</li><li>表现力强的名称是为了帮助人们阅读，提供人们可以理解的名称是有意义的。</li><li>请确保选择的名称符合适用语言的规则和标准。</li></ul><h3 id="4-2-命名空间"><a href="#4-2-命名空间" class="headerlink" title="4.2    命名空间"></a>4.2    命名空间</h3><p>命名命名空间时的一般性规则是使用公司名称，后跟项目名称和可选的功能与设计。<br><code>示例</code>：namespace CompanyName.ProjectName.ModuleName</p><h3 id="4-3-类"><a href="#4-3-类" class="headerlink" title="4.3    类"></a>4.3    类</h3><ul><li>使用 Pascal 大小写。</li><li>用名词或名词短语命名类。</li><li>使用全称避免缩写，除非缩写已是一种公认的约定，如URL、HTML。</li><li>不要使用类型前缀，如在类名称上对类使用 C 前缀。例如，使用类名称 FileStream，而不是 CFileStream。 </li></ul><h3 id="4-4-接口"><a href="#4-4-接口" class="headerlink" title="4.4    接口"></a>4.4    接口</h3><ul><li>用名词或名词短语，或者描述行为的形容词命名接口。例如，接口名称 IComponent 使用描述性名词。接口名称 ICustomAttributeProvider 使用名词短语。名称 IPersistable 使用形容词。 </li><li>使用 Pascal 大小写。 </li><li>少用缩写。 </li><li>给接口名称加上字母 I 前缀，以指示该类型为接口。在定义类/接口对（其中类是接口的标准实现）时使用相似的名称。两个名称的区别应该只是接口名称上有字母 I 前缀。</li><li>当类是接口的标准执行时，定义这一对类/接口组合就要使用相似的名称。两个名称的不同之处只是接口名前有一个I前缀。</li></ul><h3 id="4-5-属性-Attribute"><a href="#4-5-属性-Attribute" class="headerlink" title="4.5 属性 (Attribute)"></a>4.5 属性 (Attribute)</h3><ul><li>将后缀 Attribute 添加到自定义属性类。</li></ul><h3 id="4-6-枚举-Enum"><a href="#4-6-枚举-Enum" class="headerlink" title="4.6    枚举 (Enum)"></a>4.6    枚举 (Enum)</h3><ul><li>对于 Enum 类型和值名称使用 Pascal 大小写。 </li><li>少用缩写。 </li><li>不要在 Enum 类型名称上使用 Enum 后缀。</li></ul><h3 id="4-7-参数"><a href="#4-7-参数" class="headerlink" title="4.7    参数"></a>4.7    参数</h3><ul><li>使用描述性参数名称。参数名称应当具有足够的描述性，以便参数的名称及其类型可用于在大多数情况下确定它的含义。 </li><li>对参数名称使用 Camel 大小写。 </li><li>使用描述参数的含义的名称，而不要使用描述参数的类型的名称。开发工具将提供有关参数的类型的有意义的信息。因此， 通过描述意义，可以更好地使用参数的名称。少用基于类型的参数名称，仅在适合使用它们的地方使用它们。 </li><li>不要使用保留的参数。保留的参数是专用参数，如果需要，可以在未来的版本中公开它们。相反，如果在类库的未来版本中需要更多的数据，请为方法添加新的重载。 </li><li>不要给参数名称加匈牙利语类型表示法的前缀。 </li></ul><h3 id="4-8-方法"><a href="#4-8-方法" class="headerlink" title="4.8    方法"></a>4.8    方法</h3><ul><li>使用动词或动词短语命名方法。 </li><li>使用 Pascal 大小写。</li></ul><h3 id="4-9-属性-property"><a href="#4-9-属性-property" class="headerlink" title="4.9    属性 (property)"></a>4.9    属性 (property)</h3><ul><li>使用名词或名词短语命名属性。 </li><li>使用 Pascal 大小写。 </li><li>不要使用匈牙利语表示法。</li></ul><h3 id="4-10-常量-const"><a href="#4-10-常量-const" class="headerlink" title="4.10    常量 (const)"></a>4.10    常量 (const)</h3><ul><li>所有单词大写，多个单词之间用 “_” 隔开。</li></ul><h3 id="4-11-字段-Field"><a href="#4-11-字段-Field" class="headerlink" title="4.11 字段(Field)"></a>4.11 字段(Field)</h3><ul><li>private、protected 使用 Camel 大小写。</li><li>public 使用 Pascal 大小写。</li><li>为了区分字段和局部变量，建议在首字母前加一下划线_。<br><code>ps</code>：C# 中通常字段只有 private，若需暴露，请使用属性。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-规范制定原则&quot;&gt;&lt;a href=&quot;#1-规范制定原则&quot; class=&quot;headerlink&quot; title=&quot;1.    规范制定原则&quot;&gt;&lt;/a&gt;1.    规范制定原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;方便代码的交流和维护。&lt;/li&gt;
&lt;li&gt;不影响编码的效率，不与
      
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="01.CSharp" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-CSharp/"/>
    
    
      <category term="C#" scheme="http://www.venux.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>DDD-01介绍</title>
    <link href="http://www.venux.cn//posts/08.%E6%9E%B6%E6%9E%84/01.DDD/01.%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.venux.cn//posts/08.架构/01.DDD/01.介绍/</id>
    <published>2018-05-14T03:06:38.000Z</published>
    <updated>2018-06-11T06:09:03.153Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="08.架构" scheme="http://www.venux.cn/categories/08-%E6%9E%B6%E6%9E%84/"/>
    
      <category term="01.DDD" scheme="http://www.venux.cn/categories/08-%E6%9E%B6%E6%9E%84/01-DDD/"/>
    
    
      <category term="DDD" scheme="http://www.venux.cn/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>java-Tomcat</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-Tomcat/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-Tomcat/</id>
    <published>2018-04-18T14:13:30.000Z</published>
    <updated>2018-06-11T06:09:01.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>Apache 基金会下的一款开源的 web 服务器。</p><h2 id="2-下载"><a href="#2-下载" class="headerlink" title="2.下载"></a>2.下载</h2><p><a href="http://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">Tomcat下载</a></p><h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><p>解压缩到指定目录</p><h3 id="3-1-目录结构"><a href="#3-1-目录结构" class="headerlink" title="3.1 目录结构"></a>3.1 目录结构</h3><ul><li>bin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。</li><li>conf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。</li><li>lib：库文件。tomcat运行时需要的jar包所在的目录</li><li>logs：日志</li><li>temp：临时产生的文件，即缓存</li><li>webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问</li><li>work：编译以后的class文件。</li></ul><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><h3 id="4-1-环境变量配置"><a href="#4-1-环境变量配置" class="headerlink" title="4.1 环境变量配置"></a>4.1 环境变量配置</h3><ol><li><strong>CATALINA_HOME</strong>：C:\Program Files\Tomcat 8.5（注：结尾不加分号）</li><li><strong>PATH</strong>:%CATALINA_HOME%\bin;</li><li><strong>CLASS_PATH</strong>:%CATALINA_HOME%\lib;</li></ol><h3 id="4-2-配置文件"><a href="#4-2-配置文件" class="headerlink" title="4.2 配置文件"></a>4.2 配置文件</h3><p>$CATALINA_HOME 目录下的 conf 目录，核心配置文件 server.xml。</p><h2 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h2><p>进入 $CATALINA_HOME 目录下的 bin 目录，运行 startup.bat 即可。</p><h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h3><ul><li><strong>localhost:8080</strong>:Tomcat默认主页</li></ul><h3 id="7-Eclipse集成"><a href="#7-Eclipse集成" class="headerlink" title="7 Eclipse集成"></a>7 Eclipse集成</h3><ul><li>“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。</li></ul><a id="more"></a><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;p&gt;Apache 基金会下的一款开源的 web 服务器。&lt;/p&gt;
&lt;h2 id=&quot;2-下载&quot;&gt;&lt;a href=&quot;#2-下载&quot; class=&quot;headerlink&quot; title=&quot;2.下载&quot;&gt;&lt;/a&gt;2.下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://tomcat.apache.org/download-90.cgi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tomcat下载&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-安装&quot;&gt;&lt;a href=&quot;#3-安装&quot; class=&quot;headerlink&quot; title=&quot;3. 安装&quot;&gt;&lt;/a&gt;3. 安装&lt;/h2&gt;&lt;p&gt;解压缩到指定目录&lt;/p&gt;
&lt;h3 id=&quot;3-1-目录结构&quot;&gt;&lt;a href=&quot;#3-1-目录结构&quot; class=&quot;headerlink&quot; title=&quot;3.1 目录结构&quot;&gt;&lt;/a&gt;3.1 目录结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;bin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。&lt;/li&gt;
&lt;li&gt;conf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。&lt;/li&gt;
&lt;li&gt;lib：库文件。tomcat运行时需要的jar包所在的目录&lt;/li&gt;
&lt;li&gt;logs：日志&lt;/li&gt;
&lt;li&gt;temp：临时产生的文件，即缓存&lt;/li&gt;
&lt;li&gt;webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问&lt;/li&gt;
&lt;li&gt;work：编译以后的class文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-配置&quot;&gt;&lt;a href=&quot;#4-配置&quot; class=&quot;headerlink&quot; title=&quot;4. 配置&quot;&gt;&lt;/a&gt;4. 配置&lt;/h2&gt;&lt;h3 id=&quot;4-1-环境变量配置&quot;&gt;&lt;a href=&quot;#4-1-环境变量配置&quot; class=&quot;headerlink&quot; title=&quot;4.1 环境变量配置&quot;&gt;&lt;/a&gt;4.1 环境变量配置&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CATALINA_HOME&lt;/strong&gt;：C:\Program Files\Tomcat 8.5（注：结尾不加分号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PATH&lt;/strong&gt;:%CATALINA_HOME%\bin;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLASS_PATH&lt;/strong&gt;:%CATALINA_HOME%\lib;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;4-2-配置文件&quot;&gt;&lt;a href=&quot;#4-2-配置文件&quot; class=&quot;headerlink&quot; title=&quot;4.2 配置文件&quot;&gt;&lt;/a&gt;4.2 配置文件&lt;/h3&gt;&lt;p&gt;$CATALINA_HOME 目录下的 conf 目录，核心配置文件 server.xml。&lt;/p&gt;
&lt;h2 id=&quot;5-启动&quot;&gt;&lt;a href=&quot;#5-启动&quot; class=&quot;headerlink&quot; title=&quot;5. 启动&quot;&gt;&lt;/a&gt;5. 启动&lt;/h2&gt;&lt;p&gt;进入 $CATALINA_HOME 目录下的 bin 目录，运行 startup.bat 即可。&lt;/p&gt;
&lt;h3 id=&quot;6-测试&quot;&gt;&lt;a href=&quot;#6-测试&quot; class=&quot;headerlink&quot; title=&quot;6. 测试&quot;&gt;&lt;/a&gt;6. 测试&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;localhost:8080&lt;/strong&gt;:Tomcat默认主页&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;7-Eclipse集成&quot;&gt;&lt;a href=&quot;#7-Eclipse集成&quot; class=&quot;headerlink&quot; title=&quot;7 Eclipse集成&quot;&gt;&lt;/a&gt;7 Eclipse集成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;“Window”–“Preferences”–“Server”–“Runtime Environment”–“Add”–选择Tomcat安装目录。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-JSP</title>
    <link href="http://www.venux.cn//posts/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.Java/Java-JSP/"/>
    <id>http://www.venux.cn//posts/01.编程语言/02.Java/Java-JSP/</id>
    <published>2018-04-18T14:05:19.000Z</published>
    <updated>2018-06-11T06:09:01.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>JSP（Java Server Pages），一种动态网页开发技术，类似于 ASP。通常以<code>&lt;%</code>开头，以<code>%&gt;</code>结尾。</p><a id="more"></a><h2 id="2-特点（与CGI对比）"><a href="#2-特点（与CGI对比）" class="headerlink" title="2 特点（与CGI对比）"></a>2 特点（与CGI对比）</h2><ul><li>性能更加优越，因为JSP可以直接在HTML网页中动态嵌入元素而不需要单独引用CGI文件。</li><li>服务器调用的是已经编译好的JSP文件，而不像CGI/Perl那样必须先载入解释器和目标脚本。</li><li>JSP 基于Java Servlet API，因此，JSP拥有各种强大的企业级Java API，包括JDBC，JNDI，EJB，JAXP等等。</li><li>JSP页面可以与处理业务逻辑的 Servlet 一起使用，这种模式被Java servlet 模板引擎所支持。</li></ul><h2 id="3-JSP-流程"><a href="#3-JSP-流程" class="headerlink" title="3 JSP 流程"></a>3 JSP 流程</h2><p><img src="/images/posts/jsp-arch.jpg" alt="JSP 位置"><br><img src="/images/posts/jsp-processing.jpg" alt="JSP 流程"></p><ul><li>浏览器发送一个 HTTP 请求给服务器。</li><li>Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成。</li><li>JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码。</li><li>JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎。</li><li>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。</li><li>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。</li><li>Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样。</li></ul><h2 id="4-JSP-生命周期"><a href="#4-JSP-生命周期" class="headerlink" title="4 JSP 生命周期"></a>4 JSP 生命周期</h2><p><img src="/images/posts/jsp_life_cycle.jpg" alt="JSP 生命周期"></p><ul><li><strong>编译阶段</strong>：servlet容器编译servlet源文件，生成servlet类。若未修改，则跳过。<ul><li>解析JSP文件。</li><li>将JSP文件转为servlet。</li><li>编译servlet。</li></ul></li><li><p><strong>初始化阶段</strong>：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//JSP初始化代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行阶段</strong>：调用与JSP对应的servlet实例的服务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">  <span class="comment">//服务端处理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>销毁阶段</strong>：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//清理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-JSP-语法"><a href="#5-JSP-语法" class="headerlink" title="5 JSP 语法"></a>5 JSP 语法</h2><h3 id="5-1-脚本程序"><a href="#5-1-脚本程序" class="headerlink" title="5.1 脚本程序"></a>5.1 脚本程序</h3><p>可包含任意量的Java语句、变量、方法或表达式。格式：<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% 代码片段 %&gt;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:scriptlet&gt;</span><br><span class="line">  代码片段</span><br><span class="line">&lt;/jsp:scriptlet&gt;</span><br></pre></td></tr></table></figure></p><h3 id="5-2-头部支持中文"><a href="#5-2-头部支持中文" class="headerlink" title="5.2 头部支持中文"></a>5.2 头部支持中文</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html;charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="5-3-声明"><a href="#5-3-声明" class="headerlink" title="5.3 声明"></a>5.3 声明</h3><p>一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! declaration;[ declaration;]+ ... %&gt;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:declaration&gt;</span><br><span class="line">  代码片段</span><br><span class="line">&lt;/jsp:declaration&gt;</span><br></pre></td></tr></table></figure></p><h3 id="5-4-表达式"><a href="#5-4-表达式" class="headerlink" title="5.4 表达式"></a>5.4 表达式</h3><p>一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。<br><code>注意：</code>不能以分号来结束。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 表达式 %&gt;</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:expression&gt;</span><br><span class="line">   表达式</span><br><span class="line">&lt;/jsp:expression&gt;</span><br></pre></td></tr></table></figure></p><h3 id="5-5-注释"><a href="#5-5-注释" class="headerlink" title="5.5 注释"></a>5.5 注释</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--注释--%&gt;</span><br></pre></td></tr></table></figure><h3 id="5-6-指令"><a href="#5-6-指令" class="headerlink" title="5.6 指令"></a>5.6 指令</h3><p>设置与整个JSP页面相关的属性。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ directive attribute=<span class="string">"value"</span> %&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>&lt;%@ page … %&gt;</td><td>定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td></tr><tr><td>&lt;%@ include … %&gt;</td><td>包含其他文件</td></tr><tr><td>&lt;%@ taglib … %&gt;</td><td>引入标签库的定义，可以是自定义标签</td></tr></tbody></table><h3 id="5-7-行为"><a href="#5-7-行为" class="headerlink" title="5.7 行为"></a>5.7 行为</h3><p>使用XML语法结构来控制servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。<br>行为标签只有一种语法格式，它严格遵守XML标准。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:action_name attribute=<span class="string">"value"</span> /&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>jsp:include</td><td>用于在当前页面中包含静态或动态资源</td></tr><tr><td>jsp:useBean</td><td>寻找和初始化一个JavaBean组件</td></tr><tr><td>jsp:setProperty</td><td>设置 JavaBean组件的值</td></tr><tr><td>jsp:getProperty</td><td>将 JavaBean组件的值插入到 output中</td></tr><tr><td>jsp:forward</td><td>从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td></tr><tr><td>jsp:plugin</td><td>用于在生成的HTML页面中包含Applet和JavaBean对象</td></tr><tr><td>jsp:element</td><td>动态创建一个XML元素</td></tr><tr><td>jsp:attribute</td><td>定义动态创建的XML元素的属性</td></tr><tr><td>jsp:body</td><td>定义动态创建的XML元素的主体</td></tr><tr><td>jsp:text</td><td>用于封装模板数据</td></tr></tbody></table><h3 id="5-8-隐含对象"><a href="#5-8-隐含对象" class="headerlink" title="5.8 隐含对象"></a>5.8 隐含对象</h3><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>request</td><td>HttpServletRequest类的实例</td></tr><tr><td>response</td><td>HttpServletResponse类的实例</td></tr><tr><td>out</td><td>PrintWriter类的实例，用于把结果输出至网页上</td></tr><tr><td>session</td><td>HttpSession类的实例</td></tr><tr><td>application</td><td>ServletContext类的实例，与应用上下文有关</td></tr><tr><td>config</td><td>ServletConfig类的实例</td></tr><tr><td>pageContext</td><td>PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问</td></tr><tr><td>page</td><td>类似于Java类中的this关键字</td></tr><tr><td>Exception</td><td>Exception类的对象，代表发生错误的JSP页面中对应的异常对象</td></tr></tbody></table><h3 id="5-9-控制流语句"><a href="#5-9-控制流语句" class="headerlink" title="5.9 控制流语句"></a>5.9 控制流语句</h3><h4 id="5-9-1-判断语句"><a href="#5-9-1-判断语句" class="headerlink" title="5.9.1 判断语句"></a>5.9.1 判断语句</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;% <span class="keyword">if</span>(flag)&#123; %&gt;</span><br><span class="line">  &lt;p&gt;True&lt;/p&gt;</span><br><span class="line">&lt;% &#125;<span class="keyword">else</span>&#123; %&gt;</span><br><span class="line">  &lt;p&gt;False&lt;/p&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="5-9-2-循环语句"><a href="#5-9-2-循环语句" class="headerlink" title="5.9.2 循环语句"></a>5.9.2 循环语句</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">for</span> ( index = <span class="number">1</span>; index &lt;= <span class="number">3</span>; index++)&#123; %&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;%= index %&gt; </span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="5-10-运算符"><a href="#5-10-运算符" class="headerlink" title="5.10 运算符"></a>5.10 运算符</h3><p>JSP支持所有Java逻辑和算术运算符。</p><h3 id="5-11-字面量"><a href="#5-11-字面量" class="headerlink" title="5.11 字面量"></a>5.11 字面量</h3><ul><li>布尔值(boolean)：true 和 false;</li><li>整型(int)：与 Java 中的一样;</li><li>浮点型(float)：与 Java 中的一样;</li><li>字符串(string)：以单引号或双引号开始和结束;</li><li>Null：null。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1 <a href="http://www.venux.cn">博客</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文主要用于记录个人笔记，方便查看不明了之处，故可能摘抄许多文章，如有冒犯，请联系我删除。另由于个人查看，故可能忽略许多知识点，请自行查看相关资料，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;p&gt;JSP（Java Server Pages），一种动态网页开发技术，类似于 ASP。通常以&lt;code&gt;&amp;lt;%&lt;/code&gt;开头，以&lt;code&gt;%&amp;gt;&lt;/code&gt;结尾。&lt;/p&gt;
    
    </summary>
    
      <category term="01.编程语言" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="02.Java" scheme="http://www.venux.cn/categories/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-Java/"/>
    
    
      <category term="Java" scheme="http://www.venux.cn/tags/Java/"/>
    
  </entry>
  
</feed>
